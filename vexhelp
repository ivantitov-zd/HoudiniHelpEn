{
Du

Returns the derivative of the given value with respect to U.

USAGES
  float Du(float n, ...)
  vector Du(vector n, ...)
  vector4 Du(vector4 n, ...)


    The derivative of n with respect to U.

In shading contexts, this is the change in the variable over the area
being shaded.

DERIVATIVES OPTIONS

    Functions which compute derivatives take additional arguments to
    allow tuning of the derivative computation.


    extrapolate
        Whether derivatives are "smooth" across patch boundaries. In
        most cases this is true and if extrapolation is turned on,
        derivative computation should be exact for C2 surfaces. However,
        when the VEX variables are changing with a high frequency (for
        example, a high frequency displacement map causing high
        frequency changes to the P variable), extrapolation of
        derivative computation may cause exaggeration of discontinuities
        between patch boundaries.

    smooth
        Adjust the magnitude of the differentials non-uniformly over
        patches. This will usually reduce patch discontinuities in
        displacement/textured shaders. However, in some odd cases you
        may want to turn this feature off.

  > N = computenormal(P, "extrapolate", 1, "smooth", 0);

RELATED

  * Dv

  * Dw

}

{
Dv

Returns the derivative of the given value with respect to V.

USAGES
  float Dv(float n, ...)
  vector Dv(vector n, ...)
  vector4 Dv(vector4 n, ...)


    The derivative of n with respect to V.

In shading contexts, this is the change in the variable over the area
being shaded.

DERIVATIVES OPTIONS

    Functions which compute derivatives take additional arguments to
    allow tuning of the derivative computation.


    extrapolate
        Whether derivatives are "smooth" across patch boundaries. In
        most cases this is true and if extrapolation is turned on,
        derivative computation should be exact for C2 surfaces. However,
        when the VEX variables are changing with a high frequency (for
        example, a high frequency displacement map causing high
        frequency changes to the P variable), extrapolation of
        derivative computation may cause exaggeration of discontinuities
        between patch boundaries.

    smooth
        Adjust the magnitude of the differentials non-uniformly over
        patches. This will usually reduce patch discontinuities in
        displacement/textured shaders. However, in some odd cases you
        may want to turn this feature off.

  > N = computenormal(P, "extrapolate", 1, "smooth", 0);

RELATED

  * Du

  * Dw

}

{
Dw

Returns the derivative of the given value with respect to the 3rd axis
(for volume rendering).

USAGES
  float Dw(float p, ...)
  vector Dw(vector p, ...)
  vector4 Dw(vector4 p, ...)


    Returns the derivative of p with respect to W.

    When rendering surfaces, this function returns 0.

In shading contexts, this is the change in the variable over the volume
being shaded.

DERIVATIVES OPTIONS

    Functions which compute derivatives take additional arguments to
    allow tuning of the derivative computation.


    extrapolate
        Whether derivatives are "smooth" across patch boundaries. In
        most cases this is true and if extrapolation is turned on,
        derivative computation should be exact for C2 surfaces. However,
        when the VEX variables are changing with a high frequency (for
        example, a high frequency displacement map causing high
        frequency changes to the P variable), extrapolation of
        derivative computation may cause exaggeration of discontinuities
        between patch boundaries.

    smooth
        Adjust the magnitude of the differentials non-uniformly over
        patches. This will usually reduce patch discontinuities in
        displacement/textured shaders. However, in some odd cases you
        may want to turn this feature off.

  > N = computenormal(P, "extrapolate", 1, "smooth", 0);

RELATED

  * Du

  * Dv

}

SAMPLE ADAPTATION OPTIONS


    adaptive
        1 or 0. Turns on an automatic optimization that will reduce the
        number of samples when there is little variation in occlusion
        above the sample point. This can improve performance at the
        expense of some possible flickering or additional noise.

AREA SAMPLING OPTIONS

    For area sampling, you must specify both the angle and sample
    variadic parameters. For example:

  > surface
  > blurry_mirror(float angle = 3; int samples = 16; float bias=0.05)
  > {
  >     Cf = reflectlight(bias, 1, "angle", angle, "samples", samples);
  > }


bias
    Ray-tracing bias. Gives control over self-intersection.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

opinput
    The input number to read from, starting from 0. For example, the
    first input is 0, the second input is 1, and so on.

opinput
    The input number to read from, starting from 0. For example, the
    first input is 0, the second input is 1, and so on.

    If you specify -1, the function uses the current CHOP node or input
    0 if it is connected.

geometry
    A string specifying a geometry file (for example, a .bgeo) to read
    from. When running inside Houdini, this can be an op:/path/to/sop
    reference.

geohandle
    A handle to the geometry to write to. Currently the only valid value
    is 0 or geoself, which means the current geometry in a node. (This
    argument may be used in the future to allow writing to other
    geometries.)

attribclass
    One of "detail" (or "global"), "point", "prim", or "vertex".

    You can also use "primgroup", "pointgroup" or "vertexgroup" to read
    from groups.

attribute_name
    The name of the attribute (or intrinsic) to read.

elemnum
    The point/primitive/vertex number to read the attribute value from.
    For detail attributes, use 0 here (the argument is ignored for
    detail attributes).

    To get the linear vertex number given a primitive number and the
    vertex number on the primitive, use the primvertex function.

intrinsic_name
    The name of the intrinsic to read. For example, "pointattributes",
    "pointcount", or "bounds".

    "none"

    Don't transform.

    "point"

    Apply scales, rotations, and transformations.

    "hpoint"

    Apply scales, rotations, and transformations to this vector4.

    "vector"

    Apply scales and rotations, but not transformations.

    "normal"

    Apply rotations, apply scales with inverse-transpose.

    "color"

    Don't transform.

    "matrix"

    Apply scales, rotations, and transformations to this matrix.

    "quaternion"

    Apply rotations.

    "indexpair"

    Don't transform.

    "integer"

    Do not blend this value when points are averaged.

    "integer-blend"

    Integer values that blend when points are averaged.

    Returns the value of geohandle on success or -1 on failure.


    NOTE
        If the attribute does not exist, this function *creates the
        attribute* with a default value of zero, empty string, or an
        empty array. If you want to control the default value of a
        numeric attribute, use addattrib before setting the attribute.


mode
    (Optional) if given, this controls how the function modifies any
    existing value in the attribute.

    "set"

    Overwrite the attribute with the given value.

    "add"

    Add to the attribute the value.

    "min", "minimum"

    Set the attribute to the minimum of itself and the value.

    "max", "maximum"

    Set the attribute to the maximum of itself and the value.

    "mult", "multiply"

    Multiply the attribute by the value. For matrices, this will do
    matrix multiplication. For vectors, component-wise.

    "toggle"

    Toggles the attribute, independent of the source value. Useful for
    toggling group membership.

    "append"

    Valid for string and array attributes. Appends the source value to
    the end of the original value.

linearvertex
    The linear index of a vertex. If you have a point number and point
    vertex number, you can use vertexindex to convert them to a linear
    index.

  * Noise and randomness

  * anoise

  * curlnoise

  * flownoise

  * noise

  * onoise

  * pnoise

  * snoise

  * vnoise

  * wnoise

  * xnoise

DERIVATIVES OPTIONS

    Functions which compute derivatives take additional arguments to
    allow tuning of the derivative computation.


    extrapolate
        Whether derivatives are "smooth" across patch boundaries. In
        most cases this is true and if extrapolation is turned on,
        derivative computation should be exact for C2 surfaces. However,
        when the VEX variables are changing with a high frequency (for
        example, a high frequency displacement map causing high
        frequency changes to the P variable), extrapolation of
        derivative computation may cause exaggeration of discontinuities
        between patch boundaries.

    smooth
        Adjust the magnitude of the differentials non-uniformly over
        patches. This will usually reduce patch discontinuities in
        displacement/textured shaders. However, in some odd cases you
        may want to turn this feature off.

  > N = computenormal(P, "extrapolate", 1, "smooth", 0);

RAY SENDING OPTIONS


    width
        Specifies the filter width at the source of the ray. If angle is
        also specified, the filter width will become larger with
        increasing distance along the ray. By default, the filter width
        will be initialized from the current shading context, so it's
        normally not necessary to specify width directly. Negative
        values are ignored and will also cause the filter width to be
        initialized from the current shading context.

    distribution
        Determines the sampling distribution.

        For gather:

      * cosine -- Rays are distributed by the cosine (diffuse) function
        over the hemisphere.

      * uniform -- Rays are distributed uniformly over the hemisphere

        For sample_geometry:

      * area -- Samples are distributed by primitive area

      * parametric -- Samples are distributed by primitive ID,
        subdivision ID, and parametric surface coordinates (s, t).

      * solidangle -- Samples are distributed either by primitive area
        or by primitive area and solid angle subtended by the primitive.

    biasdir
        Overrides the bias direction when Bias Along Normal is enabled.
        When no biasdir is specified, the geometric normal Ng is used.
        When bias along normal is disabled, this option has no effect.

    SID
        Sample identifier to be passed to the called shader. If the
        calling shader has used SID to generate samples, it can be
        useful to pass the modified sample identifier to the called
        shader so that it can begin sampling at the specified offset.
        This value will be used to initialize the SID global in the hit
        surface.

    rayweight
        A hint to mantra to indicate the relative contribution of this
        ray to the final shading. This value is used by the ray clip
        threshold to limit sending of rays (similar to ray bounce).

    raystyle
        The type of rays you are sending. Mantra will use raystyle to
        determine both the default raytracing mask and bounce limit used
        for ray termination.

      * reflect -- Sending reflection rays. Mantra will use the
        reflection mask and reflection limit to terminate raytracing.

      * refract -- (default) Sending refraction rays. Mantra will use
        the refraction mask and refraction limit to terminate
        raytracing.

      * diffuse -- Sending diffuse rays. Mantra will use the diffuse
        limit for diffuse rays.

      * shadow -- Sending shadow rays. Mantra will not modify the
        raytracing level and will trace against shadowmask if inside a
        shadow or light shader.

      * primary -- Sending primary rays. This style can be used when a
        shader needs to change the direction of a primary ray without
        affecting the behavior of render settings that apply only to
        directly visible objects (such as matte and phantom). Mantra
        will still increment the raytracing level when sending primary
        rays.

      * nolimit -- Sending reflection rays with no limit on the number
        of raytracing bounces. Mantra will still increment the
        raytracing level when sending nolimit rays.

    categories
        A category expression used to select the objects which can be
        hit by rays. When specified, this overrides the existing
        reflectcategories and refractcategories parameters.

        For example, ^hidden will hit all objects which do not have the
        hidden category, and shiny|happy will hit all objects with
        either the shiny or happy category.

        The intersection of the scope and categories parameters are used
        to choose the objects which can be hit by rays.

    samplebase
        Typically, rays are distributed over the surface of the micro-
        polygon being shaded. This argument can be used to control the
        area. A value of 0 will force all rays to be sent from the same
        point. A value of 1 will cover the entire micro-polygon. (Gather
        only)

    transparentsamples
        The number of transparent samples to take for stochastic
        transparency with array outputs. Normally this value should be
        set to 1 unless you have requested exports in array variables -
        in which case the ray tracer will insert an entry in the array
        for each sample along the ray.


        NOTE
            transparentsamples must be 1 when importing F or
            ray:material using screendoor samplefilter.

SENDING INFORMATION TO THE SURFACE'S SHADER

    Using a keyword in the form "send:<name>", value, you can pass data
    from the originating surface to surfaces which are intersected by
    the ray. These arguments pass any values you want.

  > gather(P, dir, "send:N", normalize(N)) { ... }

    You can extract this passed data on the receiving end (that is, in
    the surface being hit by the ray) with the rayimport function. The
    first argument is the name (without the send: prefix) and the second
    argument is a variable in which to store the imported value.

    int rayimport(string name, <type> &value)

    rayimport returns 1 if the value was imported successfully.

IMPORTING INFORMATION FROM THE RAY

    You can specify names of global or exported variables to import from
    the hit shader in the form "<varname>", &var, typically including Cf
    (color vector of surface hit) and Of (opacity vector of surface
    hit).

  > vector  hitcf;
  > gather(P, dir, "bias", 0.01, "Cf", hitcf) {...}

    In addition, you can import the following special keywords to get
    information about the ray itself:


    ray:origin
        The origin of the ray (defined in else clause also).

    ray:direction
        The direction of the ray (defined in else clause also).

    ray:length
        The distance to the first surface which was hit by the ray.

    ray:area
        The total surface area of all the geometry in the raytracing
        scope.

    ray:solidangle
        The estimated solid angle subtended by all geometry in the
        raytracing scope. For large objects close to or enclosing the
        ray origin, this may be a very poor estimate while for
        individual primitives the estimate can be very good.

    You can retrieve information about more than one hit along the ray
    by requesting data in an array variable. When an imported value is
    of an array type, the trace function will automatically append an
    entry in the array for each individual hit point that was composited
    during ray tracing. For the opacity sample filter (see below), an
    entry will be created in the array for each semi-transparent sample
    encountered until full opacity is reached. When using array outputs,
    it may also be useful to use the all sample filter, which will cause
    all hits along the ray to be inserted regardless of whether the
    opacity limit was exceeded.

  > // Find the position and normal for all hit points along the ray,
  > // regardless of visibility.
  > vector a_pos[];
  > vector a_nml[];
  > trace(P, dir, Time,
  >         "samplefilter", "all",
  >             "P", a_pos,
  >             "N", a_nml);

SAMPLE FILTERING OPTIONS

    By default, Houdini composites the global variables using opacity
    blending. In some cases, it's more useful to get the value from the
    closest surface (regardless of whether it's transparent). You can
    use the special samplefilter keyword with a string value of either
    closest or opacity to control whether the value of a global is from
    the closest surface or opacity blended.


    samplefilter
        When the samplefilter keyword is encountered in the argument
        list, _all following_ import variables will use the specified
        filtering mode. You can specify multiple samplefilter arguments
        in a single gather statement to filter different variables in
        different ways.

        The current types of allowed for samplefilter are


        minimum
            Take the minimum value of all the samples. Note that with
            tuple values, the minimum value of each component will be
            used.

        maximum
            Take the maximum value of all the samples. Note that with
            tuple values, the maximum value of each component will be
            used.

        opacity
            Composite samples using the over operation.

        closest
            This is the default behavior, returning only the closest
            surface.

        screendoor
            Use stochastic compositing of the samples.

        sum
            Return the sum of the values for all samples.

        sum_square
            Return the sum of the squares of the values of all samples.

        sum_reciprocal
            Return the sum of the reciprocals of each sample.


    NOTE
        When using sample_geometry, the default samplefilter is set to
        closest by default, since opacity blending only works when
        compositing data along a ray.

  > gather(P, dir,
  >         "samplefilter", "opacity",
  >             "Cf", hitCf,
  >             "Of", hitOf,
  >         "samplefilter", "closest",
  >             "P", hitP,
  >             "N", hitN)
  > {
  >     trace(pos, dir, time,
  >             // Composite the bsdf of the hit surfaces using stochastic transparency
  >             "samplefilter", "screendoor",
  >             "F", hitF,
  >             // But find the closest sample's position
  >             "samplefilter", "closest",
  >             "P", hitP);
  > }

PIPELINE OPTIONS


    pipeline
        As you specify variables, you can intersperse pipeline keyword
        options to control where in the pipeline to fill out read/write
        variables. The value can be one of surface, atmosphere, or
        displacement. You can specify the pipeline option multiple
        times. Each use of the option affects any variables specified
        after it (up to the next usage of pipeline if any).

      > gather(p, d, "pipeline", "surface", "Cf", surfCf,
      >              "pipeline", "atmosphere" "Cf", fogCf, "P", hitP)

IMAGE FILTERING OPTIONS

    Examples of specifying filter parameters:

  > colormap(map, u, v, "smode", "decal", "tmode", "repeat", "border", {.1,1,1});
  > colormap(map, u, v, "mode", "clamp", "width", 1.3);
  > colormap(map, u, v, "filter", "gauss", "width", 1.3, "mode", "repeat");

    If the texture is a deep .rat file, you can use the "channel"
    keyword argument to specify a channel in the file:

  > string channelname = "N";
  > cf = colormap(map, u, v, "channel", channelname);

    wrap

        repeat or periodic
            The image map will repeat outside the range 0 to 1.
            Basically, the integer component of the texture coordinate
            is ignored. This is the default.

        clamp or edge or streak
            The texture coordinates will be clamped to the range 0 to 1.
            This causes evaluations outside the range to evaluate to the
            color at the closest edge of the image (the border pixels
            are streaked outside the range).

        black or decal or color
            Coordinates outside the range 0 to 1 will evaluate to the
            border color (rather than a color in the image). The border
            color is black (i.e. 0) by default.

    uwrap
        (AKA swrap) Specifies the behavior when the u coordinate is
        outside the range 0 to 1. The values are the same as with wrap.

    vwrap
        (AKA twrap) Specifies the behavior when the v coordinate is
        outside the range 0 to 1. The values are the same as with wrap.

    border
        Specifies the border color when Black/Decal/Color wrapping is
        used.

    channel
        Specifies the color channel for textures that have multiple
        color planes (for example, diffuse_indirect or N). For ptex
        images, this specifies the index of the first channel (for
        example, 0 or 4).

    blur
        Blurs in x and y directions. Blur is measured as a percentage of
        the image size - so a blur of 0.1 will blur 10% of the image
        width. Use xblur and yblur if you need different blur amounts in
        either dimension.

    xblur
        (AKA ublur, sblur) Blur amount in the x image direction.

    yblur
        (AKA vblur, tblur) Blur amount in the y image direction.

    pixelblur
        Blurs the texture by a floating point number of pixels.

      > Cf = texture("map.rat", ss, tt, "pixelblur", 2.0);

    xpixelblur
        Blurs the texture by a floating point number of pixels in the X
        direction.

    ypixelblur
        Blurs the texture by a floating point number of pixels in the Y
        direction.

    filter
        Specifies the type of anti-aliasing filter to be used for
        evaluation. The following argument should be a string specifying
        one of:


        point
            Point sampling (i.e. no filtering)

        box
            Box filter (default)

        gauss
            Gaussian filter

        bartlett
            Bartlett/Triangular filter

        sinc
            Sinc sharpening filter

        hanning
            Hanning filter

        blackman
            Blackman filter

        catrom
            Catmull-Rom filter

    xfilter
        (AKA ufilter, sfilter) Specifies the filter for the X direction.
        The filters are the same as with filter.

    yfilter
        (AKA vfilter, tfilter) Specifies the filter for the Y direction.
        The filters are the same as with filter.

    width
        Filter width in both X and Y directions.

    xwidth
        (AKA uwidth, swidth) Filter width in the X direction.

    ywidth
        (AKA vwidth, twidth) Filter width in the Y direction.

    zwidth
        Filter width in the Z direction (for shadow maps). This is
        measured in world space units, unlike the other width arguments.

    extrapolate
        whether to use derivative extrapolation when computing anti-
        aliasing information. Extrapolation of derivatives is on by
        default. The argument should be either 0 or 1.

    lerp
        Specifies whether RAT files should interpolate between different
        MIP levels. By default, this is turned off. Turning
        interpolation on will help remove discontinuities when different
        MIP levels of a .rat file are accessed. However, the results of
        texture evaluation will be slightly softer (i.e. blurrier) and
        will take more time.

        There are three possible values for this argument.


        0
            Disable MIP map interpolation (fastest).

        1
            Approximate MIP map interpolation (fast).

        2
            High Quality MIP map interpolation (slower but highest
            quality).

    depthinterp
        Specifies the depth interpolation mode for deep shadow maps, to
        control the opacity value that will be returned when the map is
        sampled between two z-records.

        The argument must be a string.


        discrete
            (default) Return the first z-record before the sample point.

        linear
            Linearly interpolate the opacities of the z-records before
            and after the sample point.

        See deep shadow maps for more on the difference between the two
        modes.

    beerlambert
        When evaluating volumetric deep shadow maps, this will enable
        Beer-Lambert interpolation of opacity. Beer-Lambert is more a
        accurate but more expensive form of interpolation.

        The argument should be either 0 or 1.

    srccolorspace
        Specifies the color space in which the texture is stored. When
        texture values are accessed, they will be translated from this
        space into linear space for rendering if needed.


        auto
            (default) Determine the source color space based on the
            file. Currently, this will assume sRGB color space for 8-bit
            textures and linear for all other textures.

        linear
            Transform to linear space. This currently only affects 8-bit
            textures, since all others are assumed to be already in
            linear space. Use this option to force linear interpretation
            of textures used for bump or displacement maps.

    face
        When using a Ptex texture map, the face argument is used to
        specify the face for ptexture lookup.

    ptexorient
        When using Ptex textures, the implicit texture coordinates on
        polygons are used as the interpolants for texture lookup
        (combined with the face). However, different software may have
        different beliefs about winding and orientation. This keyword
        argument allows you to control the interpretation of orientation
        for Houdini polygons. The ptexorient expects an integer argument
        which is composed of a bit-field

        For example, a value of 6 (0x4|0x2) is equivalent to calling
        texture(map, 1-t, s) instead of texture(map, s, t).

        The default ptexorient is 0, which works correctly with the
        examples found at .

LIGHT INCLUSION/EXCLUSION OPTIONS


    categories
        Specifies lights to include/exclude by their "category" tags.
        This is the preferred include/exclude lights rather than pattern
        matching light names with the "lightmask" keyword argument.

        For example:

      > diff = diffuse(nml, "lightmask", "hero | fill");

        See light categories for more information.

    lightmask
        When evaluating light and shadow shaders, objects have pre-
        defined light masks. This mask is usually specified in the
        geometry object and specifies a list of lights which are used to
        illuminate a surface or fog shader. It is possible to override
        the default light mask by specifying a "lightmask" argument.

        For example:

      > diff = diffuse(nml, "lightmask", "light*,^light2");

        ...will cause all lights whose names begin with "light" except
        for a light named "light2" to be considered for diffuse
        illumination.

        All Houdini scoping patterns, excepting group expansion, are
        supported:

      * * - wild-card match

      * ? - single character match

      * ^ - exclusion operator

      * [list] - character list match

RAY OPTIONS


    TIP
        When you specify a texture, such as with the "environment"
        keyword, you can also use the image filtering keyword arguments.
        See environment for a listing of the image filter keyword
        arguments.


    scope
        A list of objects which can be hit by the rays. When specified,
        scope overrides the default scope that would have been selected
        for the given raystyle. The "scope:default" value will cause the
        scope argument to use the default scope for the current context
        - as if the argument were not specified.

        Allows an override of the scope for ray-intersections. A special
        scope argument, scope:self, will match the currently shading
        object.

    maxdist
        The maximum distance to search for objects. This can be used to
        limit the search of objects to nearby objects only. If the
        maxdist given is negative, then it will act as if there is no
        maximum distance.

        Allows an override of the maximum distance the ray can travel
        when testing for intersections. Some functions (such as
        fastshadow) have the maximum distance implicitly defined (by the
        length of the ray) and should probably avoid using this option.
        However, this option can be used effectively when computing
        reflections, global illumination, refraction etc.

    variancevar
        The name of a VEX export variable to use for variance anti-
        aliasing. The renderer compares the value with adjacent
        micropolygons in micropolygon rendering to decide what shading
        points need additional samples (using vm_variance property as a
        threshold). If more samples are required, the algorithm takes
        samples up to the specified maximum ray samples.

        This variable must be imported from the hit surface, so it must
        be in the list of imported names (see "importing information
        back from the ray" below). If the named variable is not
        imported, this option will be ignored.

        Variance antialiasing puts more samples in areas of the image
        with high variance, for example a sharp shadow edge. It is only
        used when vm_dorayvariance is enabled. Otherwise, only the min
        ray samples (or an explicitly supplied "samples" value) are used
        for antialiasing of the gather loop.

        Overrides the global variance control (mantra's -v option) which
        is used to determine anti-aliasing quality of ray tracing. For
        more information please refer to the documentation on mantra.

    angle
        The distribution angle (specified in radians). For gather(),
        rays will be distributed over this angle. For trace(), the angle
        is used to indicate the rate at which the filter width should
        increase with increasing intersection distance. Larger angles
        will cause farther hit surfaces to use larger derivatives,
        leading to improved texturing and displacement performance.

        To be effective, the samples parameter should also be specified.

    samples
        How many samples should be sent out to filter rays. For the
        irradiance and occlusion functions, specifying a samples
        parameter will override the default irradiance sampling.

    environment
        If the ray sent out to the scene misses everything, then it's
        possible to specify an environment map to evaluate.

        Using the ray's direction, the environment map specified will be
        evaluated and the resulting color will be returned. Most likely,
        it will be necessary to specify a transform space for the
        environment map evaluations.

        In the case of refractlight and trace the Of and Af variables
        will be set to 0 regardless of the background color specified.
        the resulting color.

        When an environment map is specified, the filtering options from
        texture() are also supported.

        See how to create an environment/reflection map.

    envobject
        If an environment map is used, the orientation of the
        environment map can be specified by transforming the ray into
        the space of another object, light or fog object in the scene.
        In Houdini, null objects can be used to specify the orientation.
        For example:

      > Cf = R*reflectlight(bias, max(R), "environment", "map.rat", "envobject", "null_object_name");

    envlight
        If an environment map is used, the orientation of the
        environment map can be specified by transforming the ray into
        the space of a light in the scene.

    envtint
        If an environment map is used, tint it with this color.

    background
        If a ray misses all objects, use this as the background color of
        the scene. In the case of refractlight and trace the Of and Af
        variables will be set to 0 regardless of the background color
        specified.

    distribution
        *Functions*: irradiance, occlusion

        Distribution for computing irradiance. The default is to use a
        cosine distribution (diffuse illumination). The possible values
        for the style are "nonweighted" for uniform sampling or "cosine"
        for cosine weighted sampling.

The possible values for the space arguments are:

An object path

Use the object space of an object specified by a path string.


TIP
    In some cases, such as point instancing, mantra may automatically
    mangle object paths. You can generate an .ifd file and look inside
    to try to find what mantra is calling the object you want.

"space:object"

Object space of the _current_ object.

"space:light"

Object space of the _current_ light when executing a shadow or light
shader.

"space:world"

Houdini world space.

"space:camera"

mantra camera space.

"space:ndc"

Normal Device Coordinate space.

"space:lightndc"

Normal Device Coordinate space for the _current_ light when executing a
shadow or light shader.

"space:current"

The current space the vector is in.

"space:world"

Houdini world space.

{
abs

Returns the absolute value of the argument.

USAGES
  int abs(int n)
  float abs(float n)
  <vector> abs(<vector> v)
  Returns the absolute (positive) equivalent of the number. For vectors,
  this is done per-component.

EXAMPLES


    Scalar example
      > if (abs(n) > 1) {
      >     // n is greater than 1 or less than -1
      > }
    Vector example
      > vector v = {1.0, -0.5, 1.1}
      > if (abs(v) > 1.0) {
      >     // vector is greater than unit scale
      > }

RELATED

  * sign

}

{
accessframe

Tells the COP manager that you need access to the given frame.

USAGE
  void accessframe(int frame)

RELATED

  * Time Machine

  * Time Filter

}

{
acos

Returns the inverse cosine of the argument.

USAGES
  float acos(float v)
  Returns the inverse cosine of n, where n is in radians. The return
  value is in the range 0 to pi.

  vector2 acos(vector2 v)
  vector4 acos(vector4 v)
  vector acos(vector v)
  Returns a new vector with acos applied to each component.

RELATED

  * cos

  * sin

  * tan

}

{
addattrib

Adds an attribute to a geometry.

If you know the class of attribute you want to add ahead of time, using
adddetailattrib, addprimattrib, addpointattrib, or addvertexattrib may
be faster.

USAGES
  int addattrib(int geohandle, string attribclass, string name, <type>
  defvalue)
  int addattrib(int geohandle, string attribclass, string name, <type>
  defvalue[])


texttype
    A handle to the geometry to write to. Currently the only valid value
    is 0 or geoself, which means the current geometry in a node. (This
    argument may be used in the future to allow writing to other
    geometries.)

texttype
    One of "detail" (or "global"), "point", "prim", or "vertex".

    You can also use "primgroup", "pointgroup" or "vertexgroup" to read
    from groups.

name
    The name of the attribute to create.

defvalue
    The default value for the attribute and determines the type of
    attribute to create. String and array attributes cannot have
    defaults, so only the type is used in those cases.

    geohandle on success, or -1 on failure.

  * If an attribute of the same name already exists, the function will
    try to convert it to the new type.

RELATED

  * adddetailattrib

  * addprimattrib

  * addpointattrib

  * addvertexattrib

}

{
addattribute

WARNING
    This function has been deprecated. Use addattrib or setattrib
    instead.

RELATED

}

{
adddetailattrib

Adds a detail attribute to a geometry.

If you don't know the class of attribute until runtime, use addattrib.

USAGES
  int adddetailattrib(int geohandle, string name, <type> defvalue)
  int adddetailattrib(int geohandle, string name, <type> defvalue[])
  Adds a detail attribute to the given geometry.

  int adddetailattrib(int geohandle, string name, <type> defvalue,
  string typeinfo)
  int adddetailattrib(int geohandle, string name, <type> defvalue[],
  string typeinfo)
  Adds a detail attribute with the given transformation info. See
  attribtypeinfo for more details.



    texttype
        A handle to the geometry to write to. Currently the only valid
        value is 0 or geoself, which means the current geometry in a
        node. (This argument may be used in the future to allow writing
        to other geometries.)

    name
        The name of the attribute to create.

    defvalue
        The default value for the attribute and determines the type of
        attribute to create. String and array attributes cannot have
        defaults, so only the type is used in those cases.

        geohandle on success, or -1 on failure.

  * If an attribute of the same name already exists, the function will
    try to convert it to the new type.

RELATED

  * addattrib

  * addprimattrib

  * addpointattrib

  * addvertexattrib

}

{
addgroup

WARNING
    This function has been deprecated. Use setattrib instead.

RELATED

}

{
addpoint

Adds a point to the geometry.

USAGES
  int addpoint(int geohandle, int point_number)
  Creates a new point with all the attributes and group memberships of
  the point with the given point number.

  int addpoint(int geohandle, vector pos)
  Creates a new point with the given position.


    A point number for the created point, or -1 if the point could not
    be created.

    You can use the return value with setpointattrib to set attributes
    on the new point, however it may not be the final number of the
    point.

RELATED

  * addvertex

  * addprim

}

{
addpointattrib

Adds a point attribute to a geometry.

If you don't know the class of attribute until runtime, use addattrib.

USAGES
  int addpointattrib(int geohandle, string name, <type> defvalue)
  int addpointattrib(int geohandle, string name, <type> defvalue[])
  Adds a point attribute to the given geometry.

  int addpointattrib(int geohandle, string name, <type> defvalue, string
  typeinfo)
  int addpointattrib(int geohandle, string name, <type> defvalue[],
  string typeinfo)
  Adds a point attribute with the given transformation info. See
  attribtypeinfo for more details.



    texttype
        A handle to the geometry to write to. Currently the only valid
        value is 0 or geoself, which means the current geometry in a
        node. (This argument may be used in the future to allow writing
        to other geometries.)

    texttype
        The name of the attribute to create.

    texttype
        The default value for the attribute and determines the type of
        attribute to create. String and array attributes cannot have
        defaults, so only the type is used in those cases.

        geohandle on success, or -1 on failure.

  * If an attribute of the same name already exists, the function will
    try to convert it to the new type.

RELATED

  * addattrib

  * adddetailattrib

  * addprimattrib

  * addvertexattrib

}

{
addprim

Adds a primitive to the geometry.

USAGES
  int addprim(int geohandle, string type)
  Create a polygon or polyline without any points. You can then add
  vertices to the primitive with addvertex.

  Make sure to add at least one vertex to the created primitive. While
  we attempt to make sure Houdini's code can deal with empty polygons,
  it's possible they could cause strange results or failures.

  int addprim(int geohandle, string type, int pt0)
  int addprim(int geohandle, string type, int pt0, int pt1)
  int addprim(int geohandle, string type, int pt0, int pt1, int pt2)
  int addprim(int geohandle, string type, int pt0, int pt1, int pt2, int
  pt3)
  Create a primitive using points specified by point numbers.

  int addprim(int geohandle, string type, int points[])
  Create a primitive using points specified in an array of point
  numbers.

  void addprim(int &prim_num, int geohandle, string type, int pt0, int
  &vertices[])
  void addprim(int &prim_num, int geohandle, string type, int pt0, int
  pt1, int &vertices[])
  void addprim(int &prim_num, int geohandle, string type, int pt0, int
  pt1, int pt2, int &vertices[])
  void addprim(int &prim_num, int geohandle, string type, int pt0, int
  pt1, int pt2, int pt3, int &vertices[])
  void addprim(int &prim_num, int geohandle, string type, int points[],
  int &vertices[])
  These signatures fill the given vertices array with the new
  primitive's vertex numbers corresponding to the given points. You can
  use these numbers with setvertexattrib to set attributes on the
  vertices, however they may not be the final numbers of the vertices.

  If the primitive was created, but any points were invalid, the
  corresponding vertex numbers in the array will be -1.

  These signatures overwrite the primnum variable with the new primitive
  number instead of returning it.


texttype
    A handle to the geometry to write to. Currently the only valid value
    is 0 or geoself, which means the current geometry in a node. (This
    argument may be used in the future to allow writing to other
    geometries.)

type
    One of the following strings:

    "poly"

    Closed polygon. Can use 0 or more points.

    "polyline"

    Open polygon. Can use 0 or more points.

    "tet"

    Tetrahedron primitive. Requires exactly 4 points. You cannot add
    vertices to this primitive.

    "sphere", "circle", "tube", "metaball", "metasquad"

    Sphere, circle, tube, metaball, or metasuperquadric primitive.
    Require exactly 1 point. You cannot add vertices to these
    primitives.

    "AlembicRef", "PackedDisk"

    Packed Alembic or packed disk primitive. Require exactly 1 point.
    You cannot add vertices to these primitives.

    A primitive number for the created primitive, or -1 if the point
    could not be created.

    You can use the return value with setprimattrib to set attributes on
    the new point, however it may not be the final number of the point.

You can set a primitive's transforms using setprimintrinsic, for
example:

> matrix3 transform_value = {{0, 0, 0}, {0, 0, 0}, {1, 1, 1}};
> setprimintrinsic(geoself(), "transform", prim, transform_value);

You can also set Alembic and packed primitive intrinsics, for example:

> setprimintrinsic(geoself(), "unexpandedfilename", prim, "test.bgeo");`

RELATED

  * addvertex

  * addpoint

}

{
addprimattrib

Adds a primitive attribute to a geometry.

If you don't know the class of attribute until runtime, use addattrib.

USAGES
  int addprimattrib(int geohandle, string name, <type> defvalue)
  int addprimattrib(int geohandle, string name, <type> defvalue[])
  Adds a primitive attribute to the given geometry.

  int addprimattrib(int geohandle, string name, <type> defvalue, string
  typeinfo)
  int addprimattrib(int geohandle, string name, <type> defvalue[],
  string typeinfo)
  Adds a primitive attribute with the given transformation info. See
  attribtypeinfo for more details.



    texttype
        A handle to the geometry to write to. Currently the only valid
        value is 0 or geoself, which means the current geometry in a
        node. (This argument may be used in the future to allow writing
        to other geometries.)

    texttype
        The name of the attribute to create.

    texttype
        The default value for the attribute and determines the type of
        attribute to create. String and array attributes cannot have
        defaults, so only the type is used in those cases.

        geohandle on success, or -1 on failure.

  * If an attribute of the same name already exists, the function will
    try to convert it to the new type.

RELATED

  * addattrib

  * adddetailattrib

  * addpointattrib

  * addvertexattrib

}

{
addvariablename

Adds a mapping for an attribute to a local variable.

USAGES
  void addvariablename(string aname, string vname)
  In contexts with current geometry, this adds a mapping to the
  geometry.

  int addvariablename(int geohandle, string aname, string vname)
  Adds the mapping to the given geometry. Returns the geohandle on
  success.


  texttype
      A handle to the geometry to write to. Currently the only valid
      value is 0 or geoself, which means the current geometry in a node.
      (This argument may be used in the future to allow writing to other
      geometries.)

Adds the mapping of the attribute aname to the local variable vname. In
SOPs that support this, you will then have the local variable $<vname>
referencing the attribute <aname>. This emulates the behavior of the
AttribCreate SOP.

RELATED

}

{
addvertex

Adds a vertex to a primitive in a geometry.

USAGE
  int addvertex(int geohandle, int prim_num, int point_num)


texttype
    A handle to the geometry to write to. Currently the only valid value
    is 0 or geoself, which means the current geometry in a node. (This
    argument may be used in the future to allow writing to other
    geometries.)

prim_num
    The primitive number to add the vertex to.

point_num
    The point number to wire the new vertex to.

    Returns a _linear_ vertex index, or -1 if the vertex could not be
    added. You can use this number with setvertexattrib to set
    attributes on the new vertex, however this number may not be the
    final vertex index.

RELATED

  * addprim

  * addpoint

}

{
addvertexattrib

Adds a vertex attribute to a geometry.

If you don't know the class of attribute until runtime, use addattrib.

USAGES
  int addvertexattrib(int geohandle, string name, <type> defvalue)
  int addvertexattrib(int geohandle, string name, <type> defvalue[])
  Adds a vertex attribute to the given geometry.

  int addvertexattrib(int geohandle, string name, <type> defvalue,
  string typeinfo)
  int addvertexattrib(int geohandle, string name, <type> defvalue[],
  string typeinfo)
  Adds a vertex attribute with the given transformation info. See
  attribtypeinfo for more details.



    texttype
        A handle to the geometry to write to. Currently the only valid
        value is 0 or geoself, which means the current geometry in a
        node. (This argument may be used in the future to allow writing
        to other geometries.)

    texttype
        The name of the attribute to create.

    texttype
        The default value for the attribute and determines the type of
        attribute to create. String and array attributes cannot have
        defaults, so only the type is used in those cases.

        geohandle on success, or -1 on failure.

  * If an attribute of the same name already exists, the function will
    try to convert it to the new type.

RELATED

  * addattrib

  * adddetailattrib

  * addprimattrib

  * addpointattrib

}

{
addvisualizer

Appends to a geometry's visualizer detail attribute.

This function creates the visualizer detail string array attribute if it
doesn't exist, then appends the given visualizer string to it. If the
visualizer string already exists in the array, the function does not add
it again.

USAGE
  int addvisualizer(int geohandle, string op_url)


geohandle
    A handle to the geometry to write to. geoself() can be used to get a
    handle to the current geometry.

op_url
    A string in the form"op:/path/to/node". The geometry will use that
    node's visualizers.

  * Houdini looks up the visualizers by the op: reference, so changes to
    the visualizers on the referenced nodes will be reflected in the
    visualization of the geometry.

RELATED

  * adddetailattrib

}

{
agentaddclip

Add a clip into an agent's definition.

USAGE
  int agentaddclip(int geohandle, int prim, string clipname, string
  clippath, int keepref)

This function adds a .clip or .bclip file saved from a CHOP (or
generated by an Agent ROP) to the definition of the given agent
primitive. Clips in an agent definition contains transform animation for
driving the agent's skeleton.

The channels within the clip should of the form
transform_name:channel_name where _transform_name_ is a string matching
the values returned by agenttransformnames and _channel_name_ is one of
tx, ty, tz, rx, ry, rz, sx, sy, or sz. The channels starting with t
denote translation, r denote rotation, and s denote scale. The resulting
transforms will be treated as _local_ transforms, such as those returned
by agentlocaltransform (ie. they are relative to the corresponding
parent transform in the agent's skeleton).


geohandle
    Handle to the geometry to write to. geoself() can be used to get a
    handle to the current geometry.

prim
    The primitive number of the agent primitive whose definition is to
    be modified.

clipname
    The name to identify the clip. All clips in an agent definition must
    have unique names.

clippath
    The filename of the .clip or .bclip file saved from a CHOP or
    generated by the Agent ROP. Use op:full_path_to_chop to directly
    refer to a CHOP in the scene.

keepref
    When clippath refers to a filename on disk, this boolean flag
    indicates whether the external reference should be maintained when
    the geometry will be saved. If the reference is maintained, then the
    original source of the clip needs to be available when the saved
    geometry is used. Otherwise, a copy of the clip will be inlined when
    saving out the geometry so that the original clip is no longer
    needed.

RELATED

  * agentlocaltransform

  * agentlocaltransforms

  * agentrigparent

  * agenttransformnames

}

{
agentclipcatalog

Returns all of the animation clips that have been loaded for an agent
primitive.

USAGE
  string[] agentclipcatalog(<geometry>, int prim)

Returns an empty array if prim is out of range or is not an agent
primitive.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

prim
    The primitive number.

RELATED

  * agentcliplength

  * agentclipnames

  * agentclipsamplelocal

  * agentclipsampleworld

  * agentcliptimes

  * agentclipweights

  * setagentclipnames

  * setagentcliptimes

  * setagentclipweights

}

{
agentclipchannel

Finds the index of a channel in an agent's animation clip.

USAGE
  int agentclipchannel(<geometry>, int prim, string clipname, string
  channel)

Returns the index of a channel in the specified animation clip. Returns
-1 if clipname is not one of the agent's animation clips, prim is out of
range, prim is not an agent primitive, or channel does not exist.

For sampling the clip's transform channels, use agentrigfind and either
agentclipsamplelocal or agentclipsampleworld.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

clipname
    The name of the animation clip.

channel
    Name of a channel in the animation clip.

RELATED

  * agentclipcatalog

  * agentclipnames

  * agentclipsample

}

{
agentcliplength

Returns the length (in seconds) of an agent's animation clip.

USAGE
  float agentcliplength(<geometry>, int prim, string clipname)

Returns 0 if prim is out of range or is not an agent primitive, or if
clipname is not one of the agent's animation clips.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

clipname
    The name of the animation clip.

RELATED

  * agentclipcatalog

  * agentclipnames

  * agentclipsamplelocal

  * agentclipsamplerate

  * agentclipsampleworld

  * agentcliptimes

  * agentclipweights

  * setagentclipnames

  * setagentcliptimes

  * setagentclipweights

}

{
agentclipnames

Returns an agent primitive's current animation clips.

USAGE
  string[] agentclipnames(<geometry>, int prim)

Returns an empty array if prim is out of range or is not an agent
primitive.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

RELATED

  * agentclipcatalog

  * agentcliplength

  * agentclipsamplelocal

  * agentclipsampleworld

  * agentcliptimes

  * agentclipweights

  * agentlocaltransforms

  * agentworldtransforms

  * setagentclipnames

  * setagentcliptimes

  * setagentclipweights

}

{
agentclipsample

Samples a channel of an agent's clip at a specific time.

USAGES
  float agentclipsample(<geometry>, int prim, string clipname, float
  time, int channel_index)
  float agentclipsample(<geometry>, int prim, string clipname, float
  time, string channel)

Evaluates the clip at the given time and returns the value of the
specified channel. Returns zero if clipname is not one of the agent's
animation clips, prim is out of range, prim is not an agent primitive,
channel_index is out of range, or channel does not exist.

For sampling the clip's transform channels, use agentclipsamplelocal or
agentclipsampleworld instead.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

clipname
    The name of the animation clip.

time
    The time (in seconds) to evaluate the clip at. If this time is
    greater than the clip's length, it will be wrapped around.

channel_index
    Index of a channel in the animation clip, as returned by
    agentclipchannel.

channel
    Name of a channel in the animation clip.

EXAMPLES

    Sample a channel of the walk clip after 1.2 seconds.

  > float value = agentclipsample(0, @primnum, "walk", 1.2, "latch_leftfoot");

RELATED

  * agentclipcatalog

  * agentclipchannel

  * agentclipnames

  * agentcliplength

  * agentclipsamplelocal

  * agentclipsamplerate

  * agentclipsampleworld

  * agentcliptimes

  * agentclipweights

}

{
agentclipsamplelocal

Samples an agent's animation clip at a specific time.

USAGES
  matrix[] agentclipsamplelocal(<geometry>, int prim, string clipname,
  float time)
  matrix agentclipsamplelocal(<geometry>, int prim, string clipname,
  float time, int transform)

Evaluates the clip at the given time and returns the local transforms of
the agent's rig. Returns an empty array if clipname is not one of the
agent's animation clips, prim is out of range, prim is not an agent
primitive, or transform is out of range. The matrix signature is more
efficient than the matrix[] signature for sampling a single transform.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

clipname
    The name of the animation clip.

time
    The time (in seconds) to evaluate the clip at. If this time is
    greater than the clip's length, it will be wrapped around.

transform
    Index of a transform in the agent's rig.

EXAMPLES

    Sample the local transforms of the walk clip after 1.2 seconds.

  > matrix xforms[] = agentclipsamplelocal(0, @primnum, "agent1_clip.walk", 1.2);

RELATED

  * agentclipcatalog

  * agentclipnames

  * agentcliplength

  * agentclipsampleworld

  * agentcliptimes

  * agentclipweights

  * agenttransformcount

  * agenttransformtoworld

  * setagentclipnames

  * setagentcliptimes

  * setagentclipweights

}

{
agentclipsamplerate

Returns the sample rate of an agent's animation clip.

USAGE
  float agentclipsamplerate(<geometry>, int prim, string clipname)

Returns 0 if prim is out of range or is not an agent primitive, or if
clipname is not one of the agent's animation clips.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

clipname
    The name of the animation clip.

RELATED

  * agentclipcatalog

  * agentcliplength

  * agentclipnames

  * agentclipsamplelocal

  * agentclipsampleworld

  * agentcliptimes

  * agentclipweights

  * setagentclipnames

  * setagentcliptimes

  * setagentclipweights

}

{
agentclipsampleworld

Samples an agent's animation clip at a specific time.

USAGES
  matrix[] agentclipsampleworld(<geometry>, int prim, string clipname,
  float time)
  matrix agentclipsampleworld(<geometry>, int prim, string clipname,
  float time, int transform)

Evaluates the clip at the given time and returns the world transforms of
the agent's rig. Returns an empty array if clipname is not one of the
agent's animation clips, prim is out of range, prim is not an agent
primitive, or transform is out of range. The matrix signature is more
efficient than the matrix[] signature for sampling a single transform.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

clipname
    The name of the animation clip.

time
    The time (in seconds) to evaluate the clip at. If this time is
    greater than the clip's length, it will be wrapped around.

transform
    Index of a transform in the agent's rig.

EXAMPLES

    Sample the world transforms of the walk clip after 1.2 seconds.

  > matrix xforms[] = agentclipsampleworld(0, @primnum, "agent1_clip.walk", 1.2);

RELATED

  * agentclipcatalog

  * agentclipnames

  * agentcliplength

  * agentclipsamplelocal

  * agentcliptimes

  * agentclipweights

  * agenttransformcount

  * agenttransformtoworld

  * setagentclipnames

  * setagentcliptimes

  * setagentclipweights

}

{
agentcliptimes

Returns the current times for an agent primitive's animation clips.

USAGE
  float[] agentcliptimes(<geometry>, int prim)

Returns an empty array if prim is out of range or is not an agent
primitive.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

RELATED

  * agentclipcatalog

  * agentcliplength

  * agentclipnames

  * agentclipsamplelocal

  * agentclipsampleworld

  * agentclipweights

  * setagentclipnames

  * setagentcliptimes

  * setagentclipweights

}

{
agentcliptransformgroups

Returns the transform groups for an agent primitive's current animation
clips.

See Transform Groups for more information.

USAGE
  string[] agentcliptransformgroups(<geometry>, int prim)

Returns an empty array if prim is out of range or is not an agent
primitive.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

RELATED

  * agenttransformgroupmember

  * agenttransformgroups

  * hou.AgentTransformGroup

}

{
agentclipweights

Returns the blend weights for an agent primitive's animation clips.

USAGE
  float[] agentclipweights(<geometry>, int prim)

Returns an empty array if prim is out of range or is not an agent
primitive.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

RELATED

  * agentclipcatalog

  * agentcliplength

  * agentclipnames

  * agentclipsamplelocal

  * agentclipsampleworld

  * agentcliptimes

  * setagentclipnames

  * setagentcliptimes

  * setagentclipweights

}

{
agentcollisionlayer

Returns the name of the collision layer of an agent primitive.

USAGE
  string agentcollisionlayer(<geometry>, int prim)

Returns an empty string if prim is out of range or is not an agent
primitive.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

RELATED

  * agentcurrentlayer

  * agentlayerbindings

  * agentlayers

  * agentlayershapes

  * setagentcollisionlayer

  * setagentcurrentlayer

}

{
agentcurrentlayer

Returns the name of the current layer of an agent primitive.

USAGE
  string agentcurrentlayer(<geometry>, int prim)

Returns an empty string if prim is out of range or is not an agent
primitive.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

RELATED

  * agentcollisionlayer

  * agentlayerbindings

  * agentlayers

  * agentlayershapes

  * setagentcollisionlayer

  * setagentcurrentlayer

}

{
agentfindtransformgroup

Finds the index of a transform group in an agent's definition.

USAGE
  int agentfindtransformgroup(<geometry>, int prim, string
  transformgroup)

Returns the index of a transform group in the agent's definition.
Returns -1 if prim is out of range, prim is not an agent primitive, or
the transform group does not exist.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

transformgroup
    Name of a transform group in the agent's definition.

RELATED

  * agenttransformgroupmember

  * agenttransformgroups

}

{
agentlayerbindings

Returns the transform that each shape in an agent's layer is bound to.

USAGE
  int[] agentlayerbindings(<geometry>, int prim, string layername,
  string shapetype)

Returns an empty array if layername is not one of the agent's layers,
shapetype is invalid, prim is out of range, or prim is not an agent
primitive.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

layername
    The name of one of the agent's layers.

shapetype
    Whether to inspect "static", "deforming", or "all" shapes from the
    specified layer.

EXAMPLES

    Find the current world transform of each static shape in the
    collision layer.

  > string layer = agentcollisionlayer(0, @primnum);
  > int[] bindings = agentlayerbindings(0, @primnum, layer, "static");
  > matrix xforms[] = agentworldtransforms(0, @primnum);
  > 
  > foreach (int idx; bindings) {
  > matrix xform = xforms[idx];
  > }

RELATED

  * agentcollisionlayer

  * agentcurrentlayer

  * agentlayers

  * agentlayershapes

  * setagentcollisionlayer

  * setagentcurrentlayer

}

{
agentlayers

Returns all of the layers that have been loaded for an agent primitive.

USAGE
  string[] agentlayers(<geometry>, int prim)

Returns an empty array if prim is out of range or is not an agent
primitive.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

RELATED

  * agentcollisionlayer

  * agentcurrentlayer

  * agentlayerbindings

  * agentlayershapes

  * setagentcollisionlayer

  * setagentcurrentlayer

}

{
agentlayershapes

Returns the names of the shapes referenced by an agent primitive's
layer.

USAGES
  string[] agentlayershapes(<geometry>, int prim, string layername,
  string shapetype)
  Returns the names of all shapes that are referenced by the layer and
  satisfy the shapetype filter.

  string[] agentlayershapes(<geometry>, int prim, string layername, int
  transform)
  Returns the names of all shapes that are referenced by the layer and
  are bound to the specified transform.

Returns an empty array if layername is not one of the agent's layers,
shapetype is invalid, transform is out of range, prim is out of range,
or prim is not an agent primitive.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

layername
    The name of one of the agent's layers.

shapetype
    Whether to inspect "static", "deforming", or "all" shapes from the
    specified layer.

transform
    Index of a transform in the agent's rig.

RELATED

  * agentcollisionlayer

  * agentcurrentlayer

  * agentlayerbindings

  * agentlayers

  * setagentcollisionlayer

  * setagentcurrentlayer

}

{
agentlocaltransform

Returns the current local space transform of an agent primitive's bone.

USAGE
  matrix agentlocaltransform(<geometry>, int prim, int transform)

Returns an identity matrix if transform is out of range, prim is out of
range, or prim is not an agent primitive.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

transform
    Index of a transform in the agent's rig.

RELATED

  * agentlocaltransforms

  * agenttransformtolocal

  * agenttransformtoworld

  * agentworldtransform

  * agentworldtransforms

  * setagentlocaltransform

  * setagentlocaltransforms

  * setagentworldtransform

  * setagentworldtransforms

}

{
agentlocaltransforms

Returns the current local space transforms of an agent primitive.

USAGE
  matrix[] agentlocaltransforms(<geometry>, int prim)

If only a single transform is needed, using agentlocaltransform instead
can be significantly faster.

Returns an empty array if prim is out of range or is not an agent
primitive.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

RELATED

  * agentlocaltransform

  * agenttransformtolocal

  * agenttransformtoworld

  * agentworldtransform

  * agentworldtransforms

  * setagentlocaltransform

  * setagentlocaltransforms

  * setagentworldtransform

  * setagentworldtransforms

}

{
agentrigchildren

Returns the child transforms of a transform in an agent primitive's rig.

USAGE
  int[] agentrigchildren(<geometry>, int prim, int transform)

Returns a list of the direct children of the given transform.

Returns an empty array if transform is out of range, prim is out of
range, or prim is not an agent primitive.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

transform
    Index of a transform in the agent's rig.

EXAMPLES

    Visit all of the children of a given transform.

  > int[] queue = { transform };
  > 
  > while (len(queue) > 0) {
  > int i = removeindex(queue, 0);
  > printf("%d\n", i);
  > 
  > foreach (int child; agentrigchildren(0, @primnum, i))
  > push(queue, child);
  > }

RELATED

  * agentlocaltransforms

  * agentrigfind

  * agentrigparent

  * agenttransformcount

  * agenttransformtolocal

  * agenttransformtoworld

  * agentworldtransforms

}

{
agentrigfind

Finds the index of a transform in an agent primitive's rig.

USAGE
  int agentrigfind(<geometry>, int prim, string transformname)

Returns -1 if transformname was not found in the rig, prim is out of
range, or prim is not an agent primitive.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

transformname
    The name of a transform in the agent's rig.

EXAMPLES

    Find the current local transform of a given bone.

  > int idx = agentrigfind(0, @primnum, "Hips");
  > if (idx >= 0) {
  > matrix local_xforms[] = agentlocaltransforms(0, @primnum);
  > matrix xform = local_xforms[idx];
  > }

RELATED

  * agentrigchildren

  * agentrigparent

  * agenttransformcount

  * agenttransformnames

}

{
agentrigparent

Returns the parent transform of a transform in an agent primitive's rig.

USAGE
  int agentrigparent(<geometry>, int prim, int transform)

Returns -1 if transform is a root of the transform hierarchy, transform
is out of range, prim is out of range, or prim is not an agent
primitive.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

transform
    Index of a transform in the agent's rig.

EXAMPLES

    Find the world transform of the rig's root, beginning from a given
    bone.

  > int root;
  > while (true) {
  > int parent = agentrigparent(0, @primnum, transform);
  > 
  > if (parent < 0)
  > {
  > root = transform;
  > break;
  > }
  > else
  > transform = parent;
  > }
  > 
  > matrix root_xform = agentworldtransform(0, @primnum, root);

RELATED

  * agentlocaltransform

  * agentlocaltransforms

  * agentrigchildren

  * agentrigfind

  * agenttransformcount

  * agenttransformtolocal

  * agenttransformtoworld

  * agentworldtransform

  * agentworldtransforms

}

{
agenttransformcount

Returns the number of transforms in an agent primitive's rig.

USAGE
  int agenttransformcount(<geometry>, int prim)

Returns -1 if prim is out of range or is not an agent primitive.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

RELATED

  * agentlocaltransforms

  * agentrigchildren

  * agentrigfind

  * agentrigparent

  * agenttransformtolocal

  * agenttransformtoworld

  * agentworldtransforms

}

{
agenttransformgroupmember

Returns whether a transform is a member of the specified transform
group.

See Transform Groups for more information.

USAGES
  int agenttransformgroupmember(<geometry>, int prim, string
  transformgroup, int transform)
  int agenttransformgroupmember(<geometry>, int prim, int
  transformgroupidx, int transform)

Returns a non-zero value if the transform is a member of the specified
transform group, and zero otherwise.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

transformgroup
    Name of a transform group in the agent's definition.

transformgroupidx
    Index of a transform group in the agent's definition. A transform
    group's index can be obtained via agentfindtransformgroup.

transform
    Index of a transform in the agent's rig.

RELATED

  * agentcliptransformgroups

  * agentfindtransformgroup

  * agentrigfind

  * agenttransformgroups

  * hou.AgentTransformGroup

}

{
agenttransformgroups

Returns the names of the transform groups in an agent's definition.

See Transform Groups for more information.

USAGE
  string[] agenttransformgroups(<geometry>, int prim)

Returns an empty array if prim is out of range or is not an agent
primitive.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

RELATED

  * agentcliptransformgroups

  * agentfindtransformgroup

  * agenttransformgroupmember

  * hou.AgentTransformGroup

}

{
agenttransformgroupweight

Returns the weight of a member of the specified transform group.

See Transform Groups for more information.

USAGE
  float agenttransformgroupweight(<geometry>, int prim, int
  transformgroup, int transform)

Returns the transform's weight if it is a member of the specified
transform group, and zero otherwise.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

transformgroup
    Index of a transform group in the agent's definition. A transform
    group's index can be obtained via agentfindtransformgroup.

transform
    Index of a transform in the agent's rig.

RELATED

  * agentcliptransformgroups

  * agentfindtransformgroup

  * agentrigfind

  * agenttransformgroups

  * hou.AgentTransformGroup

}

{
agenttransformnames

Returns the name of each transform in an agent primitive's rig.

USAGE
  string[] agenttransformnames(<geometry>, int prim)

Returns an empty array if prim is out of range or is not an agent
primitive.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

RELATED

  * agentrigfind

  * agenttransformcount

}

{
agenttransformtolocal

Converts transforms from world space to local space for an agent
primitive.

USAGE
  int agenttransformtolocal(<geometry>, int prim, matrix &transforms[])

Returns -1 if len(transforms) does not match the number of transforms in
the agent's rig, prim is out of range, or prim is not an agent
primitive.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

transforms
    The transforms to convert from world space to local space.

RELATED

  * agentlocaltransforms

  * agenttransformtoworld

  * agentworldtransforms

  * setagentlocaltransforms

  * setagentworldtransforms

}

{
agenttransformtoworld

Converts transforms from local space to world space for an agent
primitive.

USAGE
  int agenttransformtoworld(<geometry>, int prim, matrix &transforms[])

Returns -1 if len(transforms) does not match the number of transforms in
the agent's rig, prim is out of range, or prim is not an agent
primitive.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

transforms
    The transforms to convert from local space to world space.

RELATED

  * agentlocaltransforms

  * agenttransformtolocal

  * agentworldtransforms

  * setagentlocaltransforms

  * setagentworldtransforms

}

{
agentworldtransform

Returns the current world space transform of an agent primitive's bone.

USAGE
  matrix agentworldtransform(<geometry>, int prim, int transform)

Returns an identity matrix if transform is out of range, prim is out of
range, or prim is not an agent primitive.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

transform
    Index of a transform in the agent's rig.

RELATED

  * agentlocaltransform

  * agentlocaltransforms

  * agenttransformtolocal

  * agenttransformtoworld

  * agentworldtransforms

  * setagentlocaltransform

  * setagentlocaltransforms

  * setagentworldtransform

  * setagentworldtransforms

}

{
agentworldtransforms

Returns the current world space transforms of an agent primitive.

USAGE
  matrix[] agentworldtransforms(<geometry>, int prim)

If only a single transform is needed, using agentworldtransform instead
can be significantly faster.

Returns an empty array if prim is out of range or is not an agent
primitive.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

opinput
    The number of the input to reference. The first input is number 0,
    the second is 1, etc.

prim
    The primitive number.

RELATED

  * agentlocaltransform

  * agentlocaltransforms

  * agenttransformtolocal

  * agenttransformtoworld

  * agentworldtransform

  * setagentlocaltransform

  * setagentlocaltransforms

  * setagentworldtransform

  * setagentworldtransforms

}

{
albedo

Returns the albedo (percentage of reflected light) for a bsdf given the
outgoing light direction.

USAGES
  vector albedo(bsdf b, ...)
  vector albedo(bsdf b, int mask, ...)
  vector albedo(bsdf b, vector viewer, ...)
  vector albedo(bsdf b, vector viewer, int mask, ...)


viewer
    Vector toward viewer.

mask
    A bitmask composed from values representing different shading
    components.

    See bouncemask for information on component label bitmasks.

RELATED

  * bouncemask

  * eval_bsdf

  * sample_bsdf

}

{
alphaname

Returns the default name of the alpha plane (as it appears in the
compositor preferences).

USAGE
  string alphaname()

Returns the default name of the alpha plane (as it appears in the
compositor preferences). Using this instead of hardcoding the default
makes your code more portable. Default is "A".

RELATED

}

{
ambient

Returns the color of ambient light in the scene.

USAGE
  vector ambient( ... )

Returns the color of ambient light in the scene.

LIGHT INCLUSION/EXCLUSION OPTIONS


    categories
        Specifies lights to include/exclude by their "category" tags.
        This is the preferred include/exclude lights rather than pattern
        matching light names with the "lightmask" keyword argument.

        For example:

      > diff = diffuse(nml, "lightmask", "hero | fill");

        See light categories for more information.

    lightmask
        When evaluating light and shadow shaders, objects have pre-
        defined light masks. This mask is usually specified in the
        geometry object and specifies a list of lights which are used to
        illuminate a surface or fog shader. It is possible to override
        the default light mask by specifying a "lightmask" argument.

        For example:

      > diff = diffuse(nml, "lightmask", "light*,^light2");

        ...will cause all lights whose names begin with "light" except
        for a light named "light2" to be considered for diffuse
        illumination.

        All Houdini scoping patterns, excepting group expansion, are
        supported:

      * * - wild-card match

      * ? - single character match

      * ^ - exclusion operator

      * [list] - character list match

RELATED

}

{
anoise

Generates "alligator" noise.

USAGES
  float anoise(vector pos)
  vector anoise(vector pos)
  float anoise(vector pos, int turbulence, float rough, float atten)
  vector anoise(vector pos, int turbulence, float rough, float atten)

These functions generate "alligator" noise, a type of cellular noise
similar to Worley noise (wnoise). It is currently not possible to
simulate alligator noise using the Worley functions, but it's possible
to get a very similar "look".

The bounds on the noise are roughly (0, 1). This function only supports
3D noise.

RELATED

  * Noise and randomness

  * anoise

  * curlnoise

  * flownoise

  * noise

  * onoise

  * pnoise

  * snoise

  * vnoise

  * wnoise

  * xnoise

}

{
append

Adds an item to an array or string.

USAGES
  void append(string &array; string value)
  Appends the second string to the first.

  void append(<type> &array[]; <type> value)
  Appends the given value to the end of the array. Increases the size of
  array by 1. This is the same as push(array, value).

  void append(<type> &array[]; <type> values[])
  Concatenates the values from the values array to the end of array.
  Increases the size of array by len(values). This is the same as
  push(array, values).


TIP
    You can set an individual item in an array using array[n] = x.

RELATED

  * Arrays

  * len

  * push

  * resize

}

{
area

Returns the area of the micropolygon containing a variable such as P.

USAGE
  float area(vector p, ...)

This is a more accurate and convenient method to get the micropolygon
area than multiplying the length of Du(P) by the length of Dv(P). This
function is typically used to get the shading area in pixels.


NOTE
    This function works because VEX "knows" that the variable P has
    derivatives (dPdu and dPdv). Passing a literal vector instead of a
    special variables such as P will return 0 since VEX will not be able
    to access the derivatives.

DERIVATIVES OPTIONS

    Functions which compute derivatives take additional arguments to
    allow tuning of the derivative computation.


    extrapolate
        Whether derivatives are "smooth" across patch boundaries. In
        most cases this is true and if extrapolation is turned on,
        derivative computation should be exact for C2 surfaces. However,
        when the VEX variables are changing with a high frequency (for
        example, a high frequency displacement map causing high
        frequency changes to the P variable), extrapolation of
        derivative computation may cause exaggeration of discontinuities
        between patch boundaries.

    smooth
        Adjust the magnitude of the differentials non-uniformly over
        patches. This will usually reduce patch discontinuities in
        displacement/textured shaders. However, in some odd cases you
        may want to turn this feature off.

  > N = computenormal(P, "extrapolate", 1, "smooth", 0);

EXAMPLES

    Return the area of the current micro-polygon in camera space:

  > area(P)

    Return the area of the current micro-polygon in NDC space:

  > area(transform("ndc", P))

    Returns 0, since the argument is not a variable VEX knows the
    derivatives for:

  > area({0.1, 2.3, 4.5})

RELATED

  * volume

  * Du

  * Dv

}

{
argsort

Returns the indices of a sorted version of an array.

USAGE
  int [] argsort(<type> value[])
  Returns a list of indices that, if applied to the given array, will
  give a sorted sequence in increasing order.

  This lets sort an array by some property of the items in the array
  rather than by the values themselves.


  * argsort and sort use a stable sort.

  * Use reverse to reverse the order of the sort.

EXAMPLES


    Sort strings by their length
      > cvex main()
      > {
      >     // Given an array of strings...
      >     string colors[] = {"Red", "Green", "Blue", "Orange", "Violet", "Indigo"};
      > 
      >     // Create an array with the corrensponding lengths
      >     int[] lengths = {};
      >     foreach (string name; colors) {
      >         push(lengths, len(name));
      >     }
      > 
      >     // Sort the lengths and return an array containing the new ordering
      >     int[] ordering = argsort(lengths);
      > 
      >     // Get the array of color names but sorted by name length
      >     string colors_by_len[] = reorder(colors, ordering);
      > 
      >     printf("%s\n", colors_by_len);
      > }
      > 
      > // Prints {Red, Blue, Green, Orange, Violet, Indigo}

RELATED

  * Arrays

  * reorder

  * sort

}

{
array

Efficiently creates an array from its arguments.

USAGE
  <type>[] array(...)
  Returns an array of items of the given type.

You should use function-style casting to ensure the array members have
the correct type:

> vector v[] = vector[](array( 1, {1,2,3}, 3, s, t, Cl, P, N));
> float  f[] = float[](array(1, 2, s, t, length(P-L), length(N)));

RELATED

  * Arrays

  * len

  * resize

}

{
ashikhmin

Returns a specular BSDF using the Ashikhmin shading model.

USAGES
  bsdf ashikhmin(float exponentx, float exponenty, vector framex, vector
  framey, ...)
  bsdf ashikhmin(vector nml, float exponentx, float exponenty, vector
  framex, vector framey, ...)


An anisotropic bsdf similar to phong() but with independent controls for
the highlight size along 2 tangent vectors.


exponentx
    Phong exponent along the framex vector.

exponenty
    Phong exponent along the framey vector.

framex
    Highlight X direction.

framey
    Highlight Y direction.

RELATED

  * phong

  * phonglobe

  * Writing a PBR shader

}

{
asin

Returns the inverse sine of the argument.

USAGES
  float asin(float n)
  The inverse sine of n, where n is in radians. The return value is in
  the range -pi/2 to pi/2.

  vector2 asin(vector2 n)
  vector asin(vector n)
  vector4 asin(vector4 n)
  Returns a new vector with asin() applied to all components.

RELATED

  * sin

  * cos

  * tan

}

{
assert_enabled

Returns 1 if the VEX assertions are enabled (see HOUDINI_VEX_ASSERT) or
0 if assertions are disabled. Used the implement the assert macro.

USAGE
  int assert_enabled()
  Returns 1 if the environment variable HOUDINI_VEX_ASSERT is set or 0
  if the variable isn't set.

The assert() macro uses this function to only execute assertions when
HOUDINI_VEX_ASSERT is set:

> #define assert(EXPR)    \
>     if (assert_enabled()) { \
>         if (!(EXPR)) print_once(sprintf('VEX Assertion Failed %s:%d - (%s)\n', \
>                 __FILE__, __LINE__, #EXPR)); \
>     }

You could use this function to write your own assert macro (for example,
you might write a macro that used your studio's logging infrastructure).

See using assertions in VEX for more information.

RELATED

}

{
assign

An efficient way of extracting the components of a vector or matrix into
float variables.

USAGES
  void assign(float &c1, float &c2, vector2 source)
  void assign(float &c1, float &c2, float &c3, vector source)
  void assign(float &c1, float &c2, float &c3, float &c4, vector4
  source)
  void assign(float &c1, float &c2, float &c3, float &c4, matrix2
  source)
  void assign(float &c1, float &c2, float &c3, float &c4, float &c5,
  float &c6, float &c7, float &c8, float &c9, matrix3 source)
  void assign(float &c1, float &c2, float &c3, float &c4, float &c5,
  float &c6, float &c7, float &c8, float &c9, float &c10, float &c11,
  float &c12, float &c13, float &c14, float &c15, float &c16, matrix
  source)

This function overwrites the float variables with the components from
the final vector or matrix argument.

RELATED

}

{
atan

Returns the inverse tangent of the argument.

USAGES
  float atan(float n)
  Returns the inverse tangent of n, where n is in radians. The return
  value is in the range -pi/2 to pi/2.

  float atan(float y, float x)
  Alias for atan2.

  <vector> atan(<vector> v)
  Returns a new vector with atan() applied to each component.

RELATED

  * atan2

  * tan

  * sin

  * cos

}

{
atan2

Returns the inverse tangent of y/x.

USAGE
  float atan2(float y, float x)

Returns the principal value of the inverse tangent of y/x, using the
signs of the two arguments to determine the quadrant of the result. The
return value is in the range -pi to pi.

RELATED

  * atan

  * tan

  * sin

  * cos

}

{
atof

Converts a string to a float.

USAGE
  float atof(string str)

Converts a string to a floating point value.

  * This function ignores whitespace around the number.

  * Returns 0.0 if the string does not contain a number.

  * The string can contain exponential notation (for example "1.25e+5").

RELATED

  * atoi

}

{
atoi

Converts a string to an integer.

USAGE
  int atoi(string str)

Converts the string argument to an integer value.

  * This function ignores whitespace around the number.

  * Returns 0 if the string does not contain a number.

  * The string can contain exponential notation (for example "1.25e+5").

RELATED

  * atof

}

{
atten

Computes attenuated falloff.

USAGE
  float atten(float attenuation, float distance)

Computes attenuated falloff. This is equivalent to <attenuation> /
(<attenuation> + <distance>).

RELATED

}

{
attrib

Reads the value of an attribute from geometry.

USAGES
  <type> attrib(<geometry>, string attribclass, string name, int
  elemnum)
  <type>[] attrib(<geometry>, string attribclass, string name, int
  elemnum)
  This general form lets you specify the attribute "class" at run-time.
  This can be useful for writing general code that can work on different
  classes. If you know the class of attribute you want to read ahead of
  time, using detail, prim, point, or vertex may be faster.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

texttype
    One of "detail" (or "global"), "point", "prim", or "vertex".

    You can also use "primgroup", "pointgroup" or "vertexgroup" to read
    from groups.

name
    The name of the attribute, group, or intrinsic to read from.

elemnum
    Which element (e.g. point number, primitive number, vertex number)
    to read from. Ignored for detail attributes. You can use vertexindex
    to convert a primitive/point pair into a vertex number.

    Zero/empty value if the attribute does not exist. Use getattrib if
    you want to check whether the attribute existed.

RELATED

}

{
attribclass

Returns the class of a geometry attribute.

USAGE
  string attribclass(<geometry>, string attribute_name)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

attribute_name
    The name of the attribute to read.

    If attributes with the same name exist at multiple "levels", returns
    the _lowest level_ at which the attribute exists. For example, if
    there is a primitive attribute foo and a vertex attribute foo,
    attribclass(0, "foo") will return "vertex".

    A string describing the class ("detail", "prim", "point", or
    "vertex") of the given attribute. If the attribute does not exist,
    returns an empty string ("").

RELATED

  * addattrib

  * attrib

  * getattrib

  * attribtype

}

{
attribsize

Returns the size of a geometry attribute.

If you know the attribute class ahead of time, using detailattribsize,
primattribsize, pointattribsize, or vertexattribsize may be faster.

USAGE
  int attribsize(<geometry>, string attribclass, string attribute_name)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

texttype
    One of "detail" (or "global"), "point", "prim", or "vertex".

    You can also use "primgroup", "pointgroup" or "vertexgroup" to read
    from groups.

    The size of an attribute's _type_.

  * For a vector type, this is the number of components.

  * For an integer, float, or string, this returns 1.

  * For an array attribute, this returns the size of the tuples in the
    array. The tuple size is controlled by the Size parameter on the
    Attribute Create node.

    If the attribute does not exist, returns 0.

  * This function works with the attribute's _type_. It does not return
    the size of an attribute _value_. You can't use this function to get
    the length of a string or array value.

EXAMPLES

  > // Get the size of the position attribute of "defgeo.bgeo"
  > int size = attribsize("defgeo.bgeo", "point", "P");

RELATED

  * addattrib

  * attrib

  * getattrib

  * attribtype

}

{
attribtype

Returns the type of a geometry attribute.

If you know the attribute class ahead of time, using detailattribtype,
primattribtype, pointattribtype, or vertexattribtype may be faster.

USAGE
  int attribtype(<geometry>, string attribclass, string attribute_name)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

texttype
    One of "detail" (or "global"), "point", "prim", or "vertex".

    You can also use "primgroup", "pointgroup" or "vertexgroup" to read
    from groups.

    A numeric code indicating the attribute type:

    -1

    Attribute not found, or unknown type.

    0

    Integer

    1

    Float or vector

    2

    String

    3

    Array of integers (or integer tuples)

    4

    Array of floats (or float tuples)

    5

    Array of strings.

EXAMPLES

  > 
  > // Get the type of the position attribute of "defgeo.bgeo"
  > int type = attribtype("defgeo.bgeo", "point", "P");

RELATED

RELATED

  * addattrib

  * attrib

  * getattrib

  * attribsize

}

{
attribtypeinfo

Returns the transformation metadata of a geometry attribute.

USAGE
  string attribtypeinfo(<geometry>, string attribclass, string
  attribute_name)
  This general form lets you specify the attribute "class" at run-time.
  This can be useful for writing general code that can work on different
  classes. If you know the attribute class ahead of time, using
  detailattribtypeinfo, primattribtypeinfo, pointattribtypeinfo, or
  vertexattribtypeinfo may be faster.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

texttype
    One of "detail" (or "global"), "point", "prim", or "vertex".

    You can also use "primgroup", "pointgroup" or "vertexgroup" to read
    from groups.

texttype
    The name of the attribute (or intrinsic) to read.

    A string indicating the metadata for a given geometry attribute, or
    the empty string ("") if the attribute does not exist.

    "none"

    Don't transform.

    "point"

    Apply scales, rotations, and transformations.

    "hpoint"

    Apply scales, rotations, and transformations to this vector4.

    "vector"

    Apply scales and rotations, but not transformations.

    "normal"

    Apply rotations, apply scales with inverse-transpose.

    "color"

    Don't transform.

    "matrix"

    Apply scales, rotations, and transformations to this matrix.

    "quaternion"

    Apply rotations.

    "indexpair"

    Don't transform.

    "integer"

    Do not blend this value when points are averaged.

    "integer-blend"

    Integer values that blend when points are averaged.

RELATED

}

{
avg

Returns the average value of the input(s)

USAGES
  int avg(int a)
  float avg(float a)
  Returns a.

  float avg(float a, float b, ...)
  Returns the average of the arguments.

  float avg(vector2 v)
  float avg(vector v)
  float avg(vector4 v)
  Returns the average of the values in the components of v.

  vector2 avg(vector2 a, vector2 b, ...)
  vector avg(vector a, vector b, ...)
  vector4 avg(vector4 a, vector4 b, ...)
  Returns a new vector where each component is the average of the
  corresponding components in the arguments.

  <type> avg(<type> arr[])
  Returns the average of the values in the array.

RELATED

}

{
binput

Samples a 2x2 pixel block around the given UV position, and bilinearly
interpolates these pixels.

USAGES
  vector binput(int u, int v, ...)
  vector4 binput(int u, int v, ...)
  vector binput(float u, float v, ...)
  vector4 binput(float u, float v, ...)
  Sample from the currently cooking plane on input 0 at the current
  frame.

  float binput(int comp, int u, int v, ...)
  float binput(int comp, float u, float v, ...)
  Sample one component the given component index of the currently
  cooking plane on input 0 at the current frame.

  vector binput(int opinput, int plane, int u, int v, ...)
  vector4 binput(int opinput, int plane, int u, int v, ...)
  vector binput(int opinput, int plane, float u, float v, ...)
  vector4 binput(int opinput, int plane, float u, float v, ...)
  Sample from the given input/plane at the current frame.

  float binput(int opinput, int plane, int comp, int u, int v, ...)
  float binput(int opinput, int plane, int comp, float u, float v, ...)
  Sample one component the the given input/plane/component at the
  current frame.

  float binput(int opinput, int plane, int array_index, int comp, int u,
  int v, int frame, ...)
  float binput(int opinput, int plane, int array_index, int comp, float
  u, float v, int frame, ...)
  Sample one component from the given input/plane/component at the given
  frame.

  vector binput(int opinput, int plane, int array_index, int u, int v,
  int frame, ...)
  vector4 binput(int opinput, int plane, int array_index, int u, int v,
  int frame, ...)
  vector binput(int opinput, int plane, int array_index, float u, float
  v, int frame, ...)
  vector4 binput(int opinput, int plane, int array_index, float u, float
  v, int frame, ...)
  Sample from the given input/plane/component at the given frame.


opinput
    The input number to read the pixels from. Versions that don't
    specify this always use the first input (0).

plane
    The index of a plane in the input. Versions that don't specify this
    always use the currently cooking plane.

array_index
    For use if the plane has array values. Generally, just pass 0 here.

comp
    The index of a component within the plane. For example, 0 for red, 1
    for green, 2 for blue in an RGB plane. The versions that return
    vectors do not take this argument and return all components at once.

u, v
    If you give floating point UVs, the values are interpreted as unit
    (0-1) values. For example, 0.5, 0.5 would be the center of the
    image. If you give integer UVs, the values are in pixels, ranging
    from 0,0 to XRES-1, YRES-1.

frame
    Frame number to sample at. Versions that don't specify this always
    use the current frame.

    A float, vector or vector4 value. If the channel does not exist,
    returns 0. Whenever possible, use the vector versions rather than
    reading individual components separately.

See COP pixel sampling functions for more information.

RELATED

  * COP pixel sampling functions

  * cinput

  * finput

  * ninput

}

{
blackbody

Compute the color value of an incandescent black body.

USAGE
  vector blackbody(const float temperature, float luminance)

Given a temperature, in Kelvin, and a luminance value, computes the
color of an incandescent black body as CIE XYZ tristimulus values.

The computation uses a fast approximation, which is valid for
temperature values between 1666K and 25000K. Values outside of this
range are clamped to the nearest valid in-range value.

The returned value can be converted to linear sRGB values using the
xyztorgb function.

RELATED

  * xyztorgb

  * blackbody

}

{
blinn

Returns a Blinn BSDF or computes Blinn shading.

USAGES
  bsdf blinn(float exponent, ...)
  bsdf blinn(vector nml, float exponent, ...)
  Returns a Blinn BSDF.

  See writing a PBR shader for information on BSDFs.

  vector blinn(vector nml, vector V, float roughness, ...)
  Computes Blinn shading.


nml
    The normal of the surface to use for evaluate.

V
    The incidence vector.

exponent
    The exponent value. The higher the value, the tighter the specular
    lobe.

Each of the functions can also take an optional light mask.


RELATED

  * phong

  * wireblinn

  * matchvex_blinn

  * Writing a PBR shader

}

{
blinnBRDF

USAGE
  float blinnBRDF(vector L, vector N, vector V, float rough)

specularBRDF, phongBRDF, blinnBRDF, and diffuseBRDF return the computed
BRDF for the different lighting models used in VEX shading. You can use
them in custom illuminance loops to replicate the lighting models of the
corresponding VEX lighting functions.

See specularBRDF for some example code.

RELATED

  * specularBRDF

  * phongBRDF

  * diffuseBRDF

  * illuminance

}

{
bouncelabel

USAGE
  string bouncelabel(int mask)

Returns the label associated with the given bounce mask.

RELATED

  * bouncemask

}

{
bouncemask

USAGE
  int bouncemask(string labels)


labels
    A label or space-separated list of labels.

    A bitmask that matches any of the labels.

Mantra tags different types of rays using shading component _labels_,
such as "diffuse", "reflect", "refract", "volume", and "sss". A custom
BSDF can also specify its own labels in addition to existing ones (see
cvex_bsdf for more information).

Some VEX functions take or return a _component bitmask_, which specifies
a combination of one or more of these labels using the bits of an
integer.

To get the bit value associated with a label, use bouncemask, for
example bouncemask("diffuse"). To get a mask that matches multiple
labels, use a space-separated list:

> reflect_or_refract = bouncemask("reflect refract")

To construct a bitmask that matches all labels, use bouncemask("all").
To match no labels, use 0.

When you get a bitmask as a return value, you can check if it matches a
certain label using &. For example:

> mask = getbounces(mybsdf)
> if (mask & bouncemask("reflect")) {
>     ...
> }

(As an alternative to basic uses of bouncemask(), you can #import
"pbr.h" and work with the constants PBR_DIFFUSE_MASK, PBR_REFLECT_MASK,
PBR_REFRACT_MASK, PBR_VOLUME_MASK, PBR_SSS_MASK, as well as PBR_ALL_MASK
and PBR_NO_MASK. You can combine the constants using |, for example
reflect_or_refract = PBR_REFLECT_MASK | PBR_REFRACT_MASK.)

RELATED

  * getbounces

  * nbouncetypes

}

{
bumpmap

WARNING
    This function is deprecated. Use Du(texture()), Dv(texture())
    instead. See Du, Dv and texture.

RELATED

}

{
bumpmapA

WARNING
    This function is deprecated. Use Du(texture()), Dv(texture())
    instead. See Du, Dv and texture.

RELATED

}

{
bumpmapB

WARNING
    This function is deprecated. Use Du(texture()), Dv(texture())
    instead. See Du, Dv and texture.

RELATED

}

{
bumpmapG

WARNING
    This function is deprecated. Use Du(texture()), Dv(texture())
    instead. See Du, Dv and texture.

RELATED

}

{
bumpmapL

WARNING
    This function is deprecated. Use Du(texture()), Dv(texture())
    instead. See Du, Dv and texture.

RELATED

}

{
bumpmapR

WARNING
    This function is deprecated. Use Du(texture()), Dv(texture())
    instead. See Du, Dv and texture.

RELATED

}

{
bumpname

Returns the default name of the bump plane (as it appears in the
compositor preferences).

USAGE
  string bumpname()

Returns the default name of the bump plane (as it appears in the
compositor preferences). Using this instead of hardcoding the default
makes your code more portable. Default is "B".

RELATED

}

{
cbrt

Returns the cube root of the argument.

USAGES
  float cbrt(float n)
  Returns the cube-root of n.

  vector2 cbrt(vector2 v)
  vector cbrt(vector v )
  vector4 cbrt(vector4 v )
  Returns a new vector where each component is the cube-root of the
  corresponding component in v.

RELATED

}

{
ceil

Returns the smallest integer greater than or equal to the argument.

USAGES
  float ceil(float n)
  <vector> ceil(<vector> v)
  Returns the smallest integer greater than or equal to n. For vectors,
  this is done per-component.

RELATED

}

{
ch

Evaluates a channel (or parameter) and return its value.

USAGES
  float ch(string channel)
  float ch(string channel, float time_in_sec)
  string ch(string channel)
  string ch(string channel, float time_in_sec)


    Evaluates a channel (or parameter) and return its value. The time is
    specified in _seconds_, not in frames. If you don't specify the
    time, the function returns the value at the current time.

    Houdini includes several functions to evaluate channels/parameters
    of different types.

  * To get a float or string without needing to know the parameter type,
    use ch.

  * To get a float, use chf.

  * To get a string, use chs.

  * For integer parameters, use chi

  * For matrix type parameters, use ch3 or ch4.

  * For a ramp parameter, use chramp.

EXAMPLES

  > // Get the X transform of the box1 SOP at 1.5s into the animation
  > float tx = ch("/obj/geo1/box1/tx", 1.5)

RELATED

  * attrib

  * chf

  * chs

  * chi

  * chv

  * ch3

  * ch4

  * chramp

}

{
ch2

Evaluates a channel (or parameter) and return its value.

USAGES
  matrix2 ch2(string channel)
  matrix2 ch2(string channel, float time)

If the node parameter referenced by channel is a matrix type, the base
parameter name can be used to return the all components as a matrix.


    Evaluates a channel (or parameter) and return its value. The time is
    specified in _seconds_, not in frames. If you don't specify the
    time, the function returns the value at the current time.

    Houdini includes several functions to evaluate channels/parameters
    of different types.

  * To get a float or string without needing to know the parameter type,
    use ch.

  * To get a float, use chf.

  * To get a string, use chs.

  * For integer parameters, use chi

  * For matrix type parameters, use ch3 or ch4.

  * For a ramp parameter, use chramp.

RELATED

  * ch

  * chf

  * chs

  * chi

  * chu

  * chv

  * chp

  * ch3

  * ch4

  * chramp

}

{
ch3

Evaluates a channel (or parameter) and return its value.

USAGES
  matrix3 ch3(string channel)
  matrix3 ch3(string channel, float time)

If the node parameter referenced by channel is a matrix type, the base
parameter name can be used to return the all components as a matrix.


    Evaluates a channel (or parameter) and return its value. The time is
    specified in _seconds_, not in frames. If you don't specify the
    time, the function returns the value at the current time.

    Houdini includes several functions to evaluate channels/parameters
    of different types.

  * To get a float or string without needing to know the parameter type,
    use ch.

  * To get a float, use chf.

  * To get a string, use chs.

  * For integer parameters, use chi

  * For matrix type parameters, use ch3 or ch4.

  * For a ramp parameter, use chramp.

RELATED

  * ch

  * chf

  * chs

  * chi

  * chu

  * chv

  * ch4

  * chramp

}

{
ch4

Evaluates a channel (or parameter) and return its value.

USAGES
  matrix ch4(string channel)
  matrix ch4(string channel, float time)

If the node parameter referenced by channel is a matrix type, the base
parameter name can be used to return the all components as a matrix.


    Evaluates a channel (or parameter) and return its value. The time is
    specified in _seconds_, not in frames. If you don't specify the
    time, the function returns the value at the current time.

    Houdini includes several functions to evaluate channels/parameters
    of different types.

  * To get a float or string without needing to know the parameter type,
    use ch.

  * To get a float, use chf.

  * To get a string, use chs.

  * For integer parameters, use chi

  * For matrix type parameters, use ch3 or ch4.

  * For a ramp parameter, use chramp.

RELATED

  * ch

  * chf

  * chs

  * chi

  * chv

  * ch3

  * chramp

}

{
chadd

Adds new channels to a CHOP node.

USAGES
  int chadd(string channel_names)
  int chadd(string channel_names[])

This function adds new channels to a CHOP node. It works only when
iterating over Clip, Channel or Samples, not when iterating over
ChannelSample. You can't control the default channel values when adding
channels using this function. You need to add another Channel Wrangle
and compute the channel data inside it.

Returns 1 on success, 0 otherwise.


channel_names
    The names of the attributes to add. Can be an array or a space
    separated list of channel names.

RELATED

}

{
chattr

Reads from a CHOP attribute.

USAGES
  <type> chattr( string attrname; int &success )
  <type> chattr( int opinput; string attrname; int &success )
  Get the value of a clip-level attribute. The version without opinput
  assumes the first input (0).

  <type> chattr( string attrname; int channel; int &success )
  <type> chattr( int opinput; string attrname; int channel; int &success
  )
  Get the value of a channel-level attribute. The version without
  opinput assumes the first input (0).

  <type> chattr( string attrname; int channel; int sample; int &success
  )
  <type> chattr( int opinput; string attrname; int channel; int sample;
  int &success )
  Get the value of an attribute. The function guesses the attribute
  class from the other arguments. The version without opinput assumes
  the first input (0).

  <type> chattr( string attrclass; string attrname; int channel; int
  sample; int &success )
  <type> chattr( int opinput, string attribclass, string attrname, int
  channel, int sample, int &success)
  Get the value of an attribute of a specific class. The version without
  opinput assumes the first input (0).


    CHOP attributes store metadata on clips, channels, samples, or
    channel/sample pairs.

This function reads the value of a CHOP attribute. Use chsetattr to set
CHOP attributes.


texttype
    The input number to read from, starting from 0. For example, the
    first input is 0, the second input is 1, and so on.

attribclass
    The "level" of the attribute:


    "clip"
        An attribute on a whole clip.

    "channel"
        An attribute on a whole channel.

    "sample"
        An attribute on a sample (across all channels).

    "channelsample"
        An attribute on a specific channel/sample pair.

    ""
        Pass an empty string to have the function figure out the class
        based on the other arguments.

    Signatures that don't have this parameter act the same as if you
    passed the empty string.

attrname
    The name of the attribute to read.

channel
    When reading a channel or channelsample attribute, this is the index
    of the channel. If you are reading a clip or sample attribute, use
    -1 here.

sample
    When reading a sample or channelsample attribute, this is the sample
    number. If you are reading a clip or channel attribute, use -1 here.

success
    If the given attribute exists and can be read, the function sets
    this variable to 1. Otherwise, it sets this variable to 0.

    The value of the attribute.

EXAMPLES


    Read the "export" attribute on a channel
      > int success = 0
      > int input = 0;
      > string attrname = "export";
      > string attrclass = "channel";
      > int channel = 0; // Or use C global variable for current channel index.
      > int sample = -1; // Or use I global variable for current sample index.
      > string s = chattr(input, attrname, attrclass, channel, sample, success )
      > if (success) {
      >     // Do something with s
      >     printf("s=%s\n", s);
      > } else {
      >     // Couldn't read attribute, usually because an attribute with that
      >     // name doesn't exist
      > }

RELATED

  * chsetattr

  * chattrnames

}

{
chattrnames

Reads CHOP attribute names of a given attribute class from a CHOP input.

USAGES
  string[] chattrnames(int opinput, string attribclass)
  string[] chattrnames(string attrclass)

Returns all the CHOP attribute names of a given attribute class from a
CHOP input.


    CHOP attributes store metadata on clips, channels, samples, or
    channel/sample pairs.


texttype
    The input number to read from, starting from 0. For example, the
    first input is 0, the second input is 1, and so on.

attribclass
    The "level" of the attribute:


    "clip"
        An attribute on a whole clip.

    "channel"
        An attribute on a whole channel.

    "sample"
        An attribute on a sample (across all channels).

    "channelsample"
        An attribute on a specific channel/sample pair.

    ""
        Pass an empty string to have the function figure out the class
        based on the other arguments.

    The attribute names as a string array.

RELATED

  * chattr

  * chsetattr

}

{
chend

Returns the sample number of the last sample in a given CHOP input.

USAGE
  int chend(int opinput=0)
  Returns the index of the last sample in the channel data in the given
  CHOP input.

To get the end frame, use chendf. To get the end time in seconds, use
chendt.

RELATED

  * chendf

  * chendt

}

{
chendf

Returns the frame corresponding to the last sample of the input
specified.

USAGE
  float chendf(int opinput=0)
  Returns the frame number corresponding to the last sample of the given
  CHOP input.

To get the end sample number, use chend. To get the end time in seconds,
use chendt.

RELATED

  * chend

  * chendt

}

{
chendt

Returns the time corresponding to the last sample of the input
specified.

USAGE
  float chendt(int opinput=0)
  Returns the time (in seconds) corresponding to the last sample in the
  given CHOP input.

To get the end sample number, use chend. To get the end frame, use
chendf.

RELATED

  * chend

  * chendf

}

{
chexpr

Evaluates a channel with a new segment expression.

USAGE
  float chexpr(string channel, string new_expr_function)

Evaluates a channel with a new segment expression and return its value.

RELATED

  * chexprf

  * chexprt

}

{
chexprf

Evaluates a channel with a new segment expression at a given frame.

USAGE
  float chexprf(string channel, string new_expr_function, float frame)

Evaluates a channel with a new segment expression at a given frame and
return its value.

RELATED

  * chexpr

  * chexprt

}

{
chexprt

Evaluates a channel with a new segment expression at a given time.

USAGE
  float chexprt(string channel, string new_expr_function, float
  time_in_seconds)

Evaluates a channel with a new segment expression at a given time and
return its value.

RELATED

  * chexpr

  * chexprf

}

{
chf

Evaluates a channel (or parameter) and return its value.

USAGES
  float chf(string channel)
  float chf(string channel, float time_in_sec)


    Evaluates a channel (or parameter) and return its value. The time is
    specified in _seconds_, not in frames. If you don't specify the
    time, the function returns the value at the current time.

    Houdini includes several functions to evaluate channels/parameters
    of different types.

  * To get a float or string without needing to know the parameter type,
    use ch.

  * To get a float, use chf.

  * To get a string, use chs.

  * For integer parameters, use chi

  * For matrix type parameters, use ch3 or ch4.

  * For a ramp parameter, use chramp.

RELATED

  * ch

  * chs

  * chi

  * chv

  * ch3

  * ch4

  * chramp

}

{
chi

Evaluates a channel (or parameter) and return its value.

USAGES
  int chi(string channel)
  int chi(string channel, float time)


    Evaluates a channel (or parameter) and return its value. The time is
    specified in _seconds_, not in frames. If you don't specify the
    time, the function returns the value at the current time.

    Houdini includes several functions to evaluate channels/parameters
    of different types.

  * To get a float or string without needing to know the parameter type,
    use ch.

  * To get a float, use chf.

  * To get a string, use chs.

  * For integer parameters, use chi

  * For matrix type parameters, use ch3 or ch4.

  * For a ramp parameter, use chramp.

RELATED

  * ch

  * chf

  * chv

  * chs

  * ch3

  * ch4

  * chramp

}

{
chindex

Returns the channel index from a input given a channel name.

USAGES
  int chindex(int opinput, string name)
  int chindex(string name)
  int[] chindex(string names[])

Returns the channel index from a input given a channel name or -1 on
failure.


opinput
    CHOP Input index or -1 if ommitted.

name
    Channel name to lookup.

names
    Array of Channel names to lookup.

RELATED

}

{
chinput

Returns the value of a channel at the specified sample.

USAGES
  <type> chinput(int channel_index, int|float sample)
  <type> chinput(int opinput, int channel_index, int|float sample)
  Read a sample from the channel at the given index. The version without
  opinput assumes the first input (0).

  <type> chinput(string channel_name, int|float sample)
  <type> chinput(int opinput, string channel_name, int|float sample)
  Read a sample from the channel with the given name. The version
  without opinput assumes the first input (0).


texttype
    The input number to read from, starting from 0. For example, the
    first input is 0, the second input is 1, and so on.

sample
    If this is fractional, the value is linearly interpolated from the
    two nearest points.

    The value of a channel at the specified sample in an input.

RELATED

}

{
chinputlimits

Computes the minimum and maximum value of samples in an input channel.

USAGE
  int chinputlimits(int opinput, int channel, float &channel_min, float
  &channel_max)


opinput
    CHOP Input index or -1 if omitted.

texttype
    When reading a channel or channelsample attribute, this is the index
    of the channel. If you are reading a clip or sample attribute, use
    -1 here.

channel_min
    Computed minimum channel value;

channel_max
    Computed maximum channel value;

    Returns 1 on success or 0 on failure.

RELATED

}

{
chname

Returns the name of a numbered channel.

COPS

    USAGE
      string chname(int plane_index, int chindex)
      Returns the name of the channel on the plane (for example, "r", or
      "x").

CHOPS

    USAGES
      string chname(int channel_index)
      string chname(int opinput, int channel_index)
      Returns the name of the channel, for example "tx". To get a list
      of all channel names, use chnames.


    texttype
        The input number to read from, starting from 0. For example, the
        first input is 0, the second input is 1, and so on.

        If you specify -1, the function uses the current CHOP node or
        input 0 if it is connected.

RELATED

}

{
chnames

Returns all the CHOP channel names of a given CHOP input.

USAGES
  string[] chnames()
  Uses -1 as the opinput.

  string[] chnames(int opinput)
  Returns an array of channel names in the given input.


texttype
    The input number to read from, starting from 0. For example, the
    first input is 0, the second input is 1, and so on.

    If you specify -1, the function uses the current CHOP node or input
    0 if it is connected.

RELATED

  * chname

}

{
chnumchan

Returns the number of channels in the input specified.

USAGES
  int chnumchan()
  Uses -1 for opinput

  int chnumchan(int opinput)
  Returns the number of channels in the input specified.


texttype
    The input number to read from, starting from 0. For example, the
    first input is 0, the second input is 1, and so on.

    If you specify -1, the function uses the current CHOP node or input
    0 if it is connected.

RELATED

}

{
chp

Evaluates a channel (or parameter) and return its value.

USAGES
  vector4 chp(string channel)
  vector4 chp(string channel, float time)

Evaluates a channel (or parameter) and return its value.

If the parameter is a vector parameter, the base parameter name can be
used to return the all components as a vector.

The time is specified in seconds, not in frames.

RELATED

}

{
chr

Converts an unicode codepoint to a UTF8 string.

USAGE
  string chr(int value)

Returns a string encoding the giving unicode codepoint as a UTF8 value.
For values less than 128, this is a one-byte string of that value.
Higher values will produce multiple byte strings.

If the given code point isn't a valid codepoint, an empty string is
returned.

RELATED

  * ord

}

{
chramp

Evaluates a ramp parameter and return its value.

USAGES
  float chramp(string channel, float ramppos)
  float chramp(string channel, float ramppos, float time)
  vector chramp(string channel, float ramppos)
  vector chramp(string channel, float ramppos, float time)

Evaluates a ramp parameter and return its value.

The ramppos is where on the ramp to evaluate.

The time parameter can be used if the ramp is animated to evaluate at
other than the current time.

RELATED

}

{
chrate

Returns the sample rate of the input specified.

USAGES
  float chrate()
  Uses -1 as the opinput.

  float chrate(int opinput)
  Returns the sample rate of the given input.


texttype
    The input number to read from, starting from 0. For example, the
    first input is 0, the second input is 1, and so on.

    If you specify -1, the function uses the current CHOP node or input
    0 if it is connected.

RELATED

}

{
chreadbuf

Returns the value of CHOP context temporary buffer at the specified
index.

USAGE
  float chreadbuf(int index)

Returns the value of a CHOP context temporary buffer at the specified
index.

RELATED

}

{
chremove

Removes channels from a CHOP node.

USAGES
  int chremove(int channel_index)
  int chremove(int channel_indices[])
  int chremove(string channel_name)
  int chremove(string channel_names[])

This function removes channels from a CHOP node. It works only when
iterating over Clip, Channel or Samples, not when iterating over
ChannelSample.

Returns 1 if all channels were removed or 0 otherwise.


channel_index
    The channel index to remove.

channel_indices
    The array of channel indices to remove.

channel_name
    The channel name to remove.

channel_names
    The array of channel names to remove.

RELATED

}

{
chremoveattr

Removes a CHOP attribute.

USAGES
  int chremoveattr(string attrclass, string attrname)
  int chremoveattr(string attrclass, string attrnames[])
  int chremoveattr(string attrname)
  int chremoveattr(string attrnames[])


    CHOP attributes store metadata on clips, channels, samples, or
    channel/sample pairs.

This function removes CHOP attribute.


texttype
    The "level" of the attribute:


    "clip"
        An attribute on a whole clip.

    "channel"
        An attribute on a whole channel.

    "sample"
        An attribute on a sample (across all channels).

    "channelsample"
        An attribute on a specific channel/sample pair.

    ""
        Pass an empty string to have the function figure out the class
        based on the other arguments.

    Signatures that don't have this parameter act the same as if you
    passed the empty string.

attrname
    The name of the attribute to remove.

attrnames
    The names of the attributes to remove.

    Returns 1 if the operation succeeded, or 0 otherwise.

RELATED

  * chattr

}

{
chrename

Renames a CHOP channel.

USAGES
  int chrename(int channel_index, string new_name)
  int chrename(string channel_name, string new_name)

This function renames a CHOP channel . It works only when iterating over
Clip, Channel or Samples, not when iterating over ChannelSample.

Returns 1 if channel was renamed or 0 otherwise.


channel_index
    The channel index to rename.

channel_name
    The channel to rename.

new_name
    The new name.

RELATED

}

{
chresizebuf

Resize the CHOP context temporary buffer

USAGE
  int chresizebuf(int size)

Resizes the CHOP context temporary buffer. Return 1 if the resize
succeeded, 0 otherwise.

RELATED

}

{
chs

Evaluates a channel (or parameter) and return its value.

USAGES
  string chs(string channel)
  string chs(string channel, float time)

Evaluates a channel (or parameter) and return its value.

The time is specified in seconds, not in frames.

RELATED

}

{
chsetattr

Sets the value of a CHOP attribute.

USAGES
  int chsetattr(string attrclass, string attrname, int channel, int
  sample, <type> value)
  Sets the attribute to the given value in the current CHOP.

  int chsetattr(string attrname, int channel, int sample, <type> value)
  This version assumes the attribute class argument to be "" (guess the
  class from the other arguments).


    CHOP attributes store metadata on clips, channels, samples, or
    channel/sample pairs.

This function sets the value of a CHOP attribute. Use chattr to read
CHOP attributes.


texttype
    The "level" of the attribute:


    "clip"
        An attribute on a whole clip.

    "channel"
        An attribute on a whole channel.

    "sample"
        An attribute on a sample (across all channels).

    "channelsample"
        An attribute on a specific channel/sample pair.

    ""
        Pass an empty string to have the function figure out the class
        based on the other arguments.

    Signatures that don't have this parameter act the same as if you
    passed the empty string.

attrname
    The name of the attribute to write.

texttype
    When reading a channel or channelsample attribute, this is the index
    of the channel. If you are reading a clip or sample attribute, use
    -1 here.

texttype
    When reading a sample or channelsample attribute, this is the sample
    number. If you are reading a clip or channel attribute, use -1 here.

value
    The new attribute value. The type of the argment determines the type
    of the attribute.

    Returns 1 if the write succeeded, or 0 otherwise.

RELATED

  * chattr

  * chattrnames

}

{
chsetlength

Sets the length of the CHOP channel data.

USAGE
  int chsetlength(int clip_length)
  Sets the length of the channel data.

RELATED

}

{
chsetrate

Sets the sampling rate of the CHOP channel data.

USAGES
  int chsetrate(int clip_rate)
  int chsetrate(float clip_rate)
  Sets the sampling rate of the channel data.

RELATED

}

{
chsetstart

Sets the CHOP start sample in the channel data.

USAGES
  int chsetstart(int start)
  int chsetstart(float start)
  Sets the index of the first sample in the channel data.

RELATED

}

{
chsraw

Returns the raw string channel (or parameter).

USAGE
  string chsraw(string channel)

Returns the raw expression value of the channel without actually
evaluating the contents of the channel.

RELATED

}

{
chstart

Returns the start sample of the input specified.

USAGES
  int chstart()
  Uses -1 as the opinput.

  int chstart(int opinput)
  Returns the index of the first sample in the channel data in the given
  CHOP input.


texttype
    The input number to read from, starting from 0. For example, the
    first input is 0, the second input is 1, and so on.

    If you specify -1, the function uses the current CHOP node or input
    0 if it is connected.

To get the start frame, use chstartf. To get the start time in seconds,
use chstartt.

RELATED

  * chstartf

  * chstartt

}

{
chstartf

Returns the frame corresponding to the first sample of the input
specified.

USAGES
  float chstartf()
  Uses -1 as the opinput.

  float chstartf(int opinput)
  Returns the frame corresponding to the first sample of the given CHOP
  input.

To get the first sample number, use chstart. To get the start time in
seconds, use chstartt.

RELATED

  * chstart

  * chstartt

}

{
chstartt

Returns the time corresponding to the first sample of the input
specified.

USAGES
  float chstartt()
  Uses -1 as the opinput.

  float chstartt(int opinput)
  Returns the time (in seconds) corresponding to the first sample of the
  given CHOP input.

To get the start sample number, use chstart. To get the start sample
frame number, use chstartf.

RELATED

  * chstart

  * chstartf

}

{
chu

Evaluates a channel or parameter, and return its value.

USAGES
  vector2 chu(string channel)
  vector2 chu(string channel, float time)

Evaluates a channel or parameter, and return its value.

If the parameter is a vector parameter, the base parameter name can be
used to return the all components as a vector.

The time is specified in seconds, not in frames.

RELATED

}

{
chv

Evaluates a channel or parameter, and return its value.

USAGES
  vector chv(string channel)
  vector chv(string channel, float time)

Evaluates a channel or parameter, and return its value.

If the parameter is a vector parameter, the base parameter name can be
used to return the all components as a vector.

The time is specified in seconds, not in frames.

RELATED

}

{
chwritebuf

Writes a value of CHOP context temporary buffer at the specified index.

USAGE
  int chwritebuf(int index, float value)

Writes a value of a CHOP context temporary buffer at the specified
index. Return 1 if the write succeeded, 0 otherwise.

RELATED

}

{
cinput

Samples the exact (unfiltered) pixel color at the given coordinates.

USAGES
  vector cinput(int u, int v, ...)
  vector4 cinput(int u, int v, ...)
  vector cinput(float u, float v, ...)
  vector4 cinput(float u, float v, ...)
  float cinput(int component, int u, int v, ...)
  float cinput(int component, float u, float v, ...)
  vector cinput(int opinput, int planeindex, int u, int v, ...)
  vector4 cinput(int opinput, int planeindex, int u, int v, ...)
  vector cinput(int opinput, int planeindex, float u, float v, ...)
  vector4 cinput(int opinput, int planeindex, float u, float v, ...)
  float cinput(int opinput, int planeindex, int component, int u, int v,
  ...)
  float cinput(int opinput, int planeindex, int component, float u,
  float v, ...)
  vector cinput(int opinput, int planeindex, int arrayindex, int u, int
  v, int frame, ...)
  vector4 cinput(int opinput, int planeindex, int arrayindex, int u, int
  v, int frame, ...)
  vector cinput(int opinput, int planeindex, int arrayindex, float u,
  float v, int frame, ...)
  vector4 cinput(int opinput, int planeindex, int arrayindex, float u,
  float v, int frame, ...)
  float cinput(int opinput, int planeindex, int arrayindex, int
  component, int u, int v, int frame, ...)
  float cinput(int opinput, int planeindex, int arrayindex, int
  component, float u, float v, int frame, ...)

See COP pixel sampling functions for more information.

RELATED

  * COP pixel sampling functions

  * binput

  * finput

  * ninput

}

{
ckspline

Samples a Catmull-Rom (Cardinal) spline defined by position/value keys.

To specify the curve using uniformly spaced value keys, use cspline.

USAGES
  float ckspline(float t, float value, float pos, ...)
  vector ckspline(float t, vector value, float pos, ...)
  vector4 ckspline(float t, vector4 value, float pos, ...)


t
    The position along the spline to sample.

value, pos, ...
    A series of pairs of key values and positions that defines the curve
    to sample.

    The interpolated value at position t along the curve.

Computes a Catmull-Rom (Cardinal) spline between the key points
specified. The values are spaced according to the keys given. The domain
of the interpolant (t) should be between the second and second last key
value specified. The keys should be specified in ascending order or
results will be unpredictable.

Because of the nature of the Cardinal spline, the value associated with
the first and last keys will never be returned. However, these keys are
used to determine the shape of the curve on entry and exit. For example:

EXAMPLES


    Find the value at position t along a curve
      > Cf = ckspline(t,
      >     {1,1,1},    -0.25,    // First key
      >     {.5,.5,.5},  0.0,    // Second key
      >     {.5, 0,.5},  0.25,    // Third key
      >     {0,0,.8},    1.0,    // Fourth key
      >     {0,0,0},     1.25    // Fifth key
      > );
        The Catmull-Rom spline defined by the above keys would be valid
        for interpolants in the range 0 to 1. The first and last keys
        are used solely to determine the slope of the curve at the
        second and second last keys.

RELATED

  * cspline

}

{
clamp

Returns value clamped between min and max.

USAGES
  int clamp(int value, int min, int max)
  float clamp(float value, float min, float max)
  Returns <value> clamped between <min> and <max>.

  vector2 clamp(vector2 value, vector2 min, vector2 max)
  vector clamp(vector value, vector min, vector max)
  vector4 clamp(vector4 value, vector4 min, vector4 max)
  Returns a new vector containing the clamped value of each component.

RELATED

  * fit

  * fit01

  * fit10

  * fit11

  * efit

}

{
clip

Clip the line segment between p0 and p1.

USAGE
  void clip(int &result, vector &p0, vector &p1, vector4 plane)

clip the line segment against an arbitrary 3D plane specified by the
plane equation (plane.x*x + plane.y*y + plane.z*z + plane.w).

USAGE
  void clip(int &result, vector &p0, vector &p1, vector min, vector max)

clip the line segment to the bounding box specified by the min and max
corner points.

clip the line segment between p0 and p1.

If the line is entirely clipped out of the result will be set to 0.
otherwise, the values p0 and p1 will be clipped to the constraints
specified and the result will be 1.

RELATED

}

{
colormap

Looks up a (filtered) color from a texture file.

This function does bilinear interpolation of the pixel values. To get
unfiltered pixel values, use rawcolormap.

USAGES
  vector|vector4 colormap(string filename, vector uvw, ...)
  Uses the first two components of <uvw> as unit (0-1) coordinates to
  point sample the texture file.

  vector|vector4 colormap(string filename, float u, float v, ...)
  Uses <u> and <v> as unit (0-1) coordinates to point sample the texture
  file.

  vector|vector4 colormap(string filename, vector uv, vector du, vector
  dv, int samples, ...)
  Uses the quadrilateral formed by (uv)-(uv+du)-(uv+du+dv)-(uv+dv) to
  area sample the texture file. Takes <samples> number of stochastic
  samples (unless the image is a .rat file).

  vector|vector4 colormap(string filename, vector uv0, vector uv1,
  vector uv2, vector uv3, ...)
  Uses the quadrilateral formed by (uv0)-(uv1)-(uv2)-(uv3) to area
  sample the texture file.

  vector|vector4 colormap(string filename, vector uv0, vector uv1,
  vector uv2, vector uv3, int samples, ...)
  Uses the quadrilateral formed by (uv0)-(uv1)-(uv2)-(uv3) to area
  sample the texture file. Takes <samples> number of stochastic samples
  (unless the image is a .rat file).

  vector|vector4 colormap(string filename, float u0, float v0, float u1,
  float v1, float u2, float v2, float u3, float v3, int samples, ...)
  Uses the quadrilateral formed by (uv0)-(uv1)-(uv2)-(uv3) to area
  sample the texture file. Takes <samples> number of stochastic samples
  (unless the image is a .rat file).


    If you call the function with a vector4 return type, the fourth
    component is the alpha channel of the texture. If the image does not
    have alpha, the fourth component is always 1.

IMAGE FILTERING OPTIONS

    Examples of specifying filter parameters:

  > colormap(map, u, v, "smode", "decal", "tmode", "repeat", "border", {.1,1,1});
  > colormap(map, u, v, "mode", "clamp", "width", 1.3);
  > colormap(map, u, v, "filter", "gauss", "width", 1.3, "mode", "repeat");

    If the texture is a deep .rat file, you can use the "channel"
    keyword argument to specify a channel in the file:

  > string channelname = "N";
  > cf = colormap(map, u, v, "channel", channelname);

    wrap

        repeat or periodic
            The image map will repeat outside the range 0 to 1.
            Basically, the integer component of the texture coordinate
            is ignored. This is the default.

        clamp or edge or streak
            The texture coordinates will be clamped to the range 0 to 1.
            This causes evaluations outside the range to evaluate to the
            color at the closest edge of the image (the border pixels
            are streaked outside the range).

        black or decal or color
            Coordinates outside the range 0 to 1 will evaluate to the
            border color (rather than a color in the image). The border
            color is black (i.e. 0) by default.

    uwrap
        (AKA swrap) Specifies the behavior when the u coordinate is
        outside the range 0 to 1. The values are the same as with wrap.

    vwrap
        (AKA twrap) Specifies the behavior when the v coordinate is
        outside the range 0 to 1. The values are the same as with wrap.

    border
        Specifies the border color when Black/Decal/Color wrapping is
        used.

    channel
        Specifies the color channel for textures that have multiple
        color planes (for example, diffuse_indirect or N). For ptex
        images, this specifies the index of the first channel (for
        example, 0 or 4).

    blur
        Blurs in x and y directions. Blur is measured as a percentage of
        the image size - so a blur of 0.1 will blur 10% of the image
        width. Use xblur and yblur if you need different blur amounts in
        either dimension.

    xblur
        (AKA ublur, sblur) Blur amount in the x image direction.

    yblur
        (AKA vblur, tblur) Blur amount in the y image direction.

    pixelblur
        Blurs the texture by a floating point number of pixels.

      > Cf = texture("map.rat", ss, tt, "pixelblur", 2.0);

    xpixelblur
        Blurs the texture by a floating point number of pixels in the X
        direction.

    ypixelblur
        Blurs the texture by a floating point number of pixels in the Y
        direction.

    filter
        Specifies the type of anti-aliasing filter to be used for
        evaluation. The following argument should be a string specifying
        one of:


        point
            Point sampling (i.e. no filtering)

        box
            Box filter (default)

        gauss
            Gaussian filter

        bartlett
            Bartlett/Triangular filter

        sinc
            Sinc sharpening filter

        hanning
            Hanning filter

        blackman
            Blackman filter

        catrom
            Catmull-Rom filter

    xfilter
        (AKA ufilter, sfilter) Specifies the filter for the X direction.
        The filters are the same as with filter.

    yfilter
        (AKA vfilter, tfilter) Specifies the filter for the Y direction.
        The filters are the same as with filter.

    width
        Filter width in both X and Y directions.

    xwidth
        (AKA uwidth, swidth) Filter width in the X direction.

    ywidth
        (AKA vwidth, twidth) Filter width in the Y direction.

    zwidth
        Filter width in the Z direction (for shadow maps). This is
        measured in world space units, unlike the other width arguments.

    extrapolate
        whether to use derivative extrapolation when computing anti-
        aliasing information. Extrapolation of derivatives is on by
        default. The argument should be either 0 or 1.

    lerp
        Specifies whether RAT files should interpolate between different
        MIP levels. By default, this is turned off. Turning
        interpolation on will help remove discontinuities when different
        MIP levels of a .rat file are accessed. However, the results of
        texture evaluation will be slightly softer (i.e. blurrier) and
        will take more time.

        There are three possible values for this argument.


        0
            Disable MIP map interpolation (fastest).

        1
            Approximate MIP map interpolation (fast).

        2
            High Quality MIP map interpolation (slower but highest
            quality).

    depthinterp
        Specifies the depth interpolation mode for deep shadow maps, to
        control the opacity value that will be returned when the map is
        sampled between two z-records.

        The argument must be a string.


        discrete
            (default) Return the first z-record before the sample point.

        linear
            Linearly interpolate the opacities of the z-records before
            and after the sample point.

        See deep shadow maps for more on the difference between the two
        modes.

    beerlambert
        When evaluating volumetric deep shadow maps, this will enable
        Beer-Lambert interpolation of opacity. Beer-Lambert is more a
        accurate but more expensive form of interpolation.

        The argument should be either 0 or 1.

    srccolorspace
        Specifies the color space in which the texture is stored. When
        texture values are accessed, they will be translated from this
        space into linear space for rendering if needed.


        auto
            (default) Determine the source color space based on the
            file. Currently, this will assume sRGB color space for 8-bit
            textures and linear for all other textures.

        linear
            Transform to linear space. This currently only affects 8-bit
            textures, since all others are assumed to be already in
            linear space. Use this option to force linear interpretation
            of textures used for bump or displacement maps.

    face
        When using a Ptex texture map, the face argument is used to
        specify the face for ptexture lookup.

    ptexorient
        When using Ptex textures, the implicit texture coordinates on
        polygons are used as the interpolants for texture lookup
        (combined with the face). However, different software may have
        different beliefs about winding and orientation. This keyword
        argument allows you to control the interpretation of orientation
        for Houdini polygons. The ptexorient expects an integer argument
        which is composed of a bit-field

        For example, a value of 6 (0x4|0x2) is equivalent to calling
        texture(map, 1-t, s) instead of texture(map, s, t).

        The default ptexorient is 0, which works correctly with the
        examples found at .

RELATED

  * rawcolormap

  * texture

}

{
colorname

Returns the default name of the color plane (as it appears in the
compositor preferences).

USAGE
  string colorname()

Returns the default name of the color plane (as it appears in the
compositor preferences). Using this instead of hardcoding the default
makes your code more portable. Default is "C".

RELATED

}

{
computenormal

In shading contexts, computes a normal. In the SOP contexts, sets
how/whether to recompute normals.

USAGES
  vector computenormal(vector P, ...)
  In shading contexts, computes the normal for position P using the
  cross product of the derivatives of P.

  vector computenormal(vector P, vector N, vector Ng, ...)
  In shading contexts, computes the normal for position P using the
  cross product of the derivatives of P. <N> is the original surface
  normal and <Ng> is the geometric normal. This version "adjusts" the
  computed normal so interpolated normals will be relatively correct.

  void computenormal(int i)
  (Obsolete) In SOP context, sets the hint for whether normals should be
  recomputed when P or N change (0=never, 1=automatic, 2=always).

DERIVATIVES OPTIONS

    Functions which compute derivatives take additional arguments to
    allow tuning of the derivative computation.


    extrapolate
        Whether derivatives are "smooth" across patch boundaries. In
        most cases this is true and if extrapolation is turned on,
        derivative computation should be exact for C2 surfaces. However,
        when the VEX variables are changing with a high frequency (for
        example, a high frequency displacement map causing high
        frequency changes to the P variable), extrapolation of
        derivative computation may cause exaggeration of discontinuities
        between patch boundaries.

    smooth
        Adjust the magnitude of the differentials non-uniformly over
        patches. This will usually reduce patch discontinuities in
        displacement/textured shaders. However, in some odd cases you
        may want to turn this feature off.

  > N = computenormal(P, "extrapolate", 1, "smooth", 0);

RELATED

}

{
concat

Concatenate all the strings specified to form a single string.

USAGE
  string concat(string s1, string s2, ...)

Concatenate the arguments to form a single string.

This is equivalent to s1 + s2 + s3 .... However, concat() is slightly
more efficient with more than 2 strings.

RELATED

}

{
cone

Returns a cone reflection BSDF.

USAGES
  bsdf cone(vector normal, vector dir, float angle, ...)
  Returns a bsdf representing a cone reflection along a given direction
  vector. This BSDF is constant within the given <angle>, producing a
  similar result to the gather or irradiance loops.

  bsdf cone(vector dir, float angle, ...)
  In shading contexts, fills in the current surface normal
  automatically.



normal
    The surface normal direction.

dir
    The direction of specularity.

angle
    Cone angle *in radians*.

RELATED

  * Writing a PBR shader

}

{
cos

Returns the cosine of the argument.

USAGES
  float cos(float n)
  Returns the cosine of n, where n is in radians.

  vector2 cos(vector2 n )
  vector cos(vector n )
  vector4 cos(vector4 n )
  Returns a new vector with cos() applied to each component.

RELATED

  * acos

  * cosh

  * sin

  * tan

}

{
cosh

Returns the hyperbolic cosine of the argument.

USAGES
  float cosh(float n)
  Returns the hyperbolic cosine of the argument.

  vector2 cosh(vector2 v)
  vector cosh(vector v)
  vector4 cosh(vector4 v)
  Returns a new vector with cosh() applied to each component.

RELATED

  * cos

  * sinh

  * tanh

}

{
cracktransform

Depending on the value of c, returns the translate (c=0), rotate (c=1),
scale (c=2), or shears (c=3) component of the transform (xform).

USAGES
  vector cracktransform(int trs, int xyz, int c, vector pivot, vector
  pivot_rotate, matrix xform)
  vector cracktransform(int trs, int xyz, int c, vector pivot, matrix
  xform)

Depending on the value of <c>, returns the translate (c=0), rotate
(c=1), scale (c=2) or shears (c=3) component of the transform (<xform>).
The function uses the given transform and rotation orders (<trs> and
<xyz>) , the given pivot point (<pivot>) and optional pivot rotation
(<pr>) to calculate the return value. The specifications for the <trs>
and <xyz> parameters can be found in $HFS/houdini/vex/include/math.h.


NOTE
    Rotation angles (when c=1) are returned in degrees, whereas many
    other VEX functions use radians. You can use the radians VEX
    function to convert the vector of angles in degrees to a vector of
    angles in radians. For example: vector angles =
    radians(cracktransform(XFORM_TRS, XFORM_XYZ, 1, {0,0,0}, M));

USAGE
  void cracktransform(int trs, int xyz, vector pivot, vector
  pivot_rotate, matrix xform, vector &t, vector &r, vector &s, vector
  &shears)

Returns the translate, rotate, scale, and shear components of <xform> in
<t>, <r>, <s>, and <shears>, respectively. If more than one component is
needed, using this overload is more efficient than making multiple calls
to the other function signature.

USAGE
  void cracktransform(int trs, int xyz, vector pivot, matrix xform,
  vector &t, vector &r, vector &s)

Returns the translate, rotate, and scale of <xform> in <t>, <r>, <s>
respectively. This overload doesn't support pivot_rotate or shears. If
more than one component is needed, using this overload is more efficient
than making multiple calls to the other function signature.

RELATED

  * quaternion

  * polardecomp

  * eulertoquaternion

  * qconvert

}

{
cross

Returns the cross product between the two vectors.

USAGE
  vector cross(vector a, vector b)

Returns the cross product between the two vectors.

RELATED

  * dot

}

{
cspline

Samples a Catmull-Rom (Cardinal) spline defined by uniformly spaced
keys.

To specify the curve using unevenly spaced keys, use ckspline.

USAGES
  float cspline(float t, float val1, ...)
  vector cspline(float t, vector val1, ...)
  vector4 cspline(float t, vector4 val1, ...)


t
    The position along the spline to sample.

val1, val2, ...
    A series of of key values. The keys are assumed to be uniformly
    spaced along a range from 0 to 1.

    The interpolated value at position t along the curve.

Computes a Catmull-Rom (Cardinal) spline between the key points
specified.

Because of the nature of the Cardinal spline, the value associated with
the first and last keys will never be returned. However, these keys are
used to determine the shape of the curve on entry and exit.

RELATED

  * ckspline

}

{
ctransform

Transforms between color spaces.

USAGES
  vector ctransform(string fromspace, string tospace; vector clr)
  vector ctransform(string tospace; vector clr)

If you don't give a <fromspace>, assumes "cspace:rgb".

Transforms color tuple <clr> from one color space to another.


NOTE
    The hue-based systems are normalized with the hue going from 0 to 1.
    LAB and TMI are not normalized.

The possible arguments for <fromspace> and <tospace> are "cspace:rgb",
"cspace:hsl", "cspace:hsv", "cspace:XYZ", "cspace:Lab", and
"cspace::tmi".

RELATED

}

{
curlnoise

Computes divergence free noise based on Perlin noise.

USAGES
  vector curlnoise(vector xyz)
  vector curlnoise(vector4 xyzt)

Computes a divergence free vector field based on the cross product of
the derivatives of two Perlin noise functions.

RELATED

  * Noise and randomness

  * anoise

  * curlnoise

  * flownoise

  * noise

  * onoise

  * pnoise

  * snoise

  * vnoise

  * wnoise

  * xnoise

}

{
curlnoise2d

Computes 2d divergence free noise based on Perlin noise.

USAGES
  vector curlnoise2d(float x, float y)
  vector curlnoise2d(vector xyt)

Computes a divergence free vector field based on the cross product of
the derivatives of two Perlin noise functions.

The resulting vectors all lie along the X-Y plane.


NOTE
    This is not the same as projecting a curlnoise to a plane.

See noise and randomness in the VEX language guide for more information.

RELATED

  * pnoise

}

{
curlxnoise

Computes divergence free noise based on Simplex noise.

USAGES
  vector curlxnoise(vector xyz)
  vector curlxnoise(vector4 xyzt)

Computes a divergence free vector field based on the cross product of
the derivatives of two simplex noise functions.

See noise and randomness in the VEX language guide for more information.

RELATED

  * pnoise

}

{
curlxnoise2d

Computes 2d divergence free noise based on simplex noise.

USAGES
  vector curlxnoise2d(float x, float y)
  vector curlxnoise2d(vector xyt)

Computes a divergence free vector field based on the cross product of
the derivatives of two simplex noise functions.

The resulting vectors all lie along the X-Y plane.


NOTE
    This is not the same as projecting a curlnoise to a plane!

See noise and randomness in the VEX language guide for more information.

RELATED

  * pnoise

}

{
cvex_bsdf

Creates a bsdf object from two CVEX shader strings.

USAGE
  bsdf cvex_bsdf(string eval_cvex_shader, string sampler_cvex_shader,
  ...)

This function lets you define a BSDF reflectance function through a pair
of cvex shaders: One to evaluate the reflectance function and another to
sample it.

You pass the shaders as VEX source strings in the first two arguments.
You can then use variadic arguments to define arbitrary data that will
be passed to the shaders when they are invoked.


WARNING
    This interface is subject to change in future versions of Houdini,
    though any potential changes will likely not require fundamental
    changes to the structure of your shaders.

EVALUATION FUNCTION

    The evaluation function must accept the following arguments:

  > (vector u, vector v, int bounces, int reverse, vector &refl, vector &eval, float &pdf)

    u
        Outgoing light direction, from the surface to the viewer.

    v
        Incoming light direction, from the surface to the light.

    bounces
        A mask specifying the type of reflections that should be
        evaluated.

    reverse
        Whether evaluating from the camera (0) or the light source (1).

    refl
        The function must overwrite this variable with the reflectivity
        (albedo) of the BSDF.

        This should not be dependent on the v vector, since it is used
        as an average reflectivity over all lighting directions. This is
        the value that the albedo function will return.

    eval
        The function must overwrite this variable with the evaluated
        reflectance for the given directions.

        Set this to 0 to indicates to mantra whether the BSDF is a delta
        function. Delta functions reflect light in specific directions
        or lines, and are handled as a special case in the lighting
        algorithm to produce less noisy results. The behavior of a delta
        BSDF is determined by the sampling function (below).

    pdf
        The function must overwrite this variable with the sampling pdf
        for the given directions. The integral of this value over the
        sphere should be equal to luminance(refl)*2*PI. For perfect
        importance sampling, pdf == luminance(eval).

SAMPLING FUNCTION

    The sampling function is responsible for selecting a random
    reflection direction that is importance sampled from the
    distribution defined by the evaluation function (above).

    The sampling function must accept the following arguments:

  > (vector u, float sx, float sy, int bounces, vector &refl, vector &v, int &bouncetype, float &pdf)

    If the evaluation function is a delta function (indicated by the
    evaluation function setting eval to 0), you are free to choose the
    sampling directions in any way you want. Otherwise, you should
    choose directions from a distribution that either matches the
    evaluation function or is close to it. The sx and sy inputs are
    available to help produce high quality sample distributions. These
    values are initialized directly from mantra's pixel sampling
    patterns.


    u
        Outgoing light direction, from the surface to the viewer.

    sx
        Uniform random value between 0 and 1, correlated with sy in a 2D
        sampling pattern.

    sy
        Uniform random value between 0 and 1, correlated with sx in a 2D
        sampling pattern.

    bounces
        A mask specifying the type of reflections that should be
        evaluated.

    refl
        The reflectivity (albedo) of the BSDF, tinted by the color of
        the light in the sampled direction. The luminance of this value
        should match refl from the evaluation function. If the sampling
        distribution does not match the evaluation function exactly,
        this value should be scaled by the ratio of the evaluation
        distribution to the sampling distribution.

    v
        Sampled light direction, from the surface to the light.

    bouncetype
        The specific component type selected by sampling.

    pdf
        The sampling pdf. The integral of this value over the sphere
        should be a constant 2*PI. Note that this differs from the pdf
        produced by the evaluation function by a factor of
        luminance(refl).

    Since Houdini 13, it is not necessary for the sampling function to
    directly sample from the evaluation function's distribution. To use
    a different sampling function, adjust the pdf outputs from both the
    evaluation and sampling shaders so that they reflect the
    distribution being sampled.

COMPONENT MASK IMPLICIT ARGUMENT

    If you add an int mybounces output argument to your evaluation or
    sample shader, it will be filled in with the component mask for the
    BSDF. You can check this against an extra "label" variadic argument
    passed to the cvex_bsdf() function to see if it should apply. This
    allows you to use the same CVEX shader source code for different
    component types.

    See bouncemask for information on component label bitmasks.

CUSTOM VARIADIC ARGUMENTS

    Any extra "key", value pairs passed to the cvex_bsdf() after the
    shader strings define custom arguments that will be passed to the
    shaders when they are invoked.

  > F = cvex_bsdf("...", "...", "label", "diffuse", "N", N);

    In particular, you should provide a "label" keyword argument to
    specify the type of component for the new BSDF (for example,
    "diffuse" or "reflect"). You can specify multiple labels in a space-
    separated list (for example, "label", "reflect refract").

VALIDATION

    There are 2 main approaches available to verify whether you have
    implemented the cvex_bsdf evaluation and sampling functions
    correctly.

  * You can use mantra's multiple importance sampling algorithm to
    ensure that renders match in brightness apart from noise for
    different sampling techniques. To do this, create an environment
    light (with a map assigned) and render with different values of the
    MIS Bias parameter. You will need to add the MIS Bias parameter from
    the rendering properties dialog, since it is not available on the
    light by default. A value of -1 means to sample only from the BSDF
    while a value of 1 means to sample only from light source. To verify
    the refl value in the sampling function, set the environment light
    rendering mode to Ray Tracing Background. If the rendered results
    are the same (apart from noise) with values of -1, 0, 1, and for ray
    tracing background, your shader is bias-free.

  * Second, the Verify BSDF object can be used to verify that the
    albedo, pdf, and sampling function all align correctly and that they
    integrate to the correct values. This approach uses point-based
    random sampling in SOPs and additionally will show the shape of the
    BSDF visually as a polar point cloud.

EXAMPLES

    EXAMPLE: DIFFUSE

        Creation:

      > F = cvex_bsdf("diffuse_eval", "diffuse_sample", "label", "diffuse", "N", N);

        Evaluation shader:

      > #include "pbr.h"
      > 
      > cvex diffuse_eval(
      >     vector u = 0;
      >     vector v = 0;
      >     int bounces = 0;
      >     int reverse = 0;
      >     export vector refl = 0;
      >     export vector eval = 0;
      >     export float pdf = 0;
      > 
      >     int mybounces = 0;
      >     vector N = 0)
      > {
      >     if (bounces & mybounces)
      >     {
      >         // If evaluating reversed, the incoming light direction is needed for
      >         // evaluation rather than the outgoing direction.  The select statement
      >         // swaps based on the value of the "reverse" toggle.
      >         vector vvec = select(reverse, u, v);
      >         pdf = max(dot(vvec, normalize(N)), 0);
      >         eval = pdf;
      >         refl = 0.5;
      >     }
      > }

        Sample shader:

      > #include "math.h"
      > #include "pbr.h"
      > 
      > cvex diffuse_sample(
      >     vector u = 0;
      >     float sx = 0;
      >     float sy = 0;
      >     int bounces = 0;
      > 
      >     export vector refl = 0;
      >     export vector v = 0;
      >     export int bouncetype = 0;
      >     export float pdf = 0;
      > 
      >     int mybounces = 0;
      >     vector N = 0)
      > {
      >     if (bounces & mybounces)
      >     {
      >         vector nml = normalize(N);
      > 
      >         v = set(cos(sx*PI*2), sin(sx*PI*2), 0);
      >         v *= sqrt(sy);
      >         v.z = sqrt(1-sy);
      > 
      >         pdf = 2*v.z;
      > 
      >         // Transform v into the reference frame for nml
      >         vector framex = normalize(cross(nml, u));
      >         vector framey = cross(nml, framex);
      > 
      >         v = framex * v.x + framey * v.y + nml*v.z;
      > 
      >         bouncetype = mybounces;
      >         refl = 0.5; // Luminance needs to match albedo
      >     }
      > }

    EXAMPLE: SPECULAR

        Creation:

      > F = cvex_bsdf("specular_eval", "specular_sample", "label", "reflect", "dir", reflect(I, N));

        Evaluation shader:

      > #include "pbr.h"
      > 
      > cvex specular_eval(
      >     vector u = 0;
      >     vector v = 0;
      >     int bounces = 0;
      >     int reverse = 1;
      >     export vector refl = 0;
      >     export vector eval = 0; // Delta bsdf
      > 
      >     int mybounces = 0;
      >     vector dir = 0)
      > {
      >     if (bounces & mybounces)
      >         refl = 1;
      > }

        Sample shader:

      > #include "math.h"
      > #include "pbr.h"
      > 
      > cvex specular_sample(
      >     vector u = 0;
      >     float sx = 0;
      >     float sy = 0;
      >     int bounces = 0;
      > 
      >     export vector refl = 0;
      >     export vector v = 0;
      >     export int bouncetype = 0;
      >     export float pdf = 0;
      > 
      >     int mybounces = 0;
      >     vector dir = 0)
      > {
      >     if (bounces & mybounces)
      >     {
      >         pdf = 1e6F;
      >         v = dir;
      >         bouncetype = mybounces;
      >         refl = 1; // Needs to match albedo
      >     }
      > }

RELATED

  * diffuse

  * specular

  * Writing a PBR shader

  * Verify BSDF

}

{
cwnoise

Generates Worley (cellular) noise using a Chebyshev distance metric.

USAGES
  void cwnoise( float position; int &seed; float &f1; float &f2 )
  void cwnoise( float position; int &seed; float &f1; float &f2; float
  &f3; float &f4 )
  Generates 1D noise.

  void cwnoise( float position; int &seed; float &f1; float &f2; int
  peiod)
  void cwnoise( float position; int &seed; float &f1; float &f2; float
  &f4; float &f4; int period)
  Generates periodic 1D noise.

  void cwnoise( float posx; float posy; int &seed; float &f1; float &f2
  )
  void cwnoise( float posx; float posy; int &seed; float &f1; float &f2;
  float &f3; float &f4 )
  Generates 2D noise. This is similar to the other forms but uses pairs
  of floats instead of a vector.

  void cwnoise( float posx; float posy; int &seed; float &f1; float &f2;
  int periodx; int periody )
  void cwnoise( float posx; float posy; int &seed; float &f1; float &f2;
  float &f3; float &f4; int periodx; int periody)
  Generates periodic 2D noise.

  void cwnoise( vector2 position; int &seed; float &f1; float &f2 )
  void cwnoise( vector2 position; int &seed; float &f1; float &f2; float
  &f3; float &f4 )
  Generates 2D noise.

  void cwnoise( vector2 position; int &seed; float &f1; float &f2; int
  periodx; int periody )
  void cwnoise( vector2 position; int &seed; float &f1; float &f2; float
  &f3; float &f4; int periodx; int periody)
  Generates periodic 2D noise.

  void cwnoise( vector position; int &seed; float &f1; float &f2 )
  void cwnoise( vector position; int &seed; float &f1; float &f2; float
  &f3; float &f4 )
  Generates 3D noise.

  void cwnoise( vector position; int &seed; float &f1; float &f2; int
  periodx; int periody; int periodx )
  void cwnoise( vector position; int &seed; float &f1; float &f2; float
  &f3; float &f4; int periodx; int periody; int periodz )
  Generates periodic 3D noise.

  void cwnoise( vector4 position; int &seed; float &f1; float &f2 )
  void cwnoise( vector4 position; int &seed; float &f1; float &f2; float
  &f3; float &f4 )
  Generates 4D noise.

  void cwnoise( vector4 position; int &seed; float &f1; float &f2; int
  periodx; int periody; int periodz; int periodw )
  void cwnoise( vector4 position; int &seed; float &f1; float &f2; float
  &f3; float &f4; int periodx; int periody; int periodz; int periodw )
  Generates periodic 4D noise.


position
    The position at which to sample the noise.

seed
    Outputs an integer value associated with the nearest seed point.
    This seed is pretty much guaranteed to be unique for every point
    (meaning that it's unlikely that two points close by have the same
    seed associated with them).

f1, f2, f3, f4
    These variables are overwritten with the distances to the nearest
    seed points, in order of closeness.

    You can combine these distances to generate noise patterns. The
    noise generated tends to be very "cellular" in nature. In fact, one
    of the nice things is that you can determine "cell" boundaries by
    using the expression: if (f2 - f1) which will be true if the point
    in space is crossing the boundary between two cells.

period, periodx, periody, periodz, periodw
    If you include the period argument(s), the function generates
    repeating (periodic) noise.

Worley noise scatters seed points randomly through space (according to a
nice Poisson distribution). The functions outputs the distances to the 2
(or 4) seed points nearest to the sample position.

RELATED

  * Noise and randomness

  * anoise

  * curlnoise

  * flownoise

  * noise

  * onoise

  * pnoise

  * snoise

  * vnoise

  * wnoise

  * xnoise

}

{
degrees

Converts the argument from radians into degrees.

USAGES
  float degrees(float num_in_rads)
  Returns the given radians in degrees.

  vector2 degrees(vector2 nums_in_rads)
  vector degrees(vector nums_in_rads)
  vector4 degrees(vector4 nums_in_rads)
  Returns a new vector with the components converted to degrees.

Most VEX trig functions work with radians, but most users are more
comfortable with degrees. You may want to convert from degrees in the UI
to radians for internal use.

RELATED

  * radians

}

{
depthmap

The depthmap functions work on an image which was rendered as a z-depth
image from mantra.

USAGES
  float depthmap(string filename, vector uvw)
  float depthmap(string filename, float u, float v)

The depthmap functions work on an image which was rendered as a z-depth
image from mantra. They return the floating point distance from the
camera to the pixel in question. There is no area sampling done when
sampling depth values. As well, if the u/v values are not in the range 0
to 1, a value of 1E6 will be returned (indicating a "far" value).

RELATED

  * shadowmap

}

{
depthname

Returns the default name of the depth plane (as it appears in the
compositor preferences).

USAGE
  string depthname()

Returns the default name of the depth plane (as it appears in the
compositor preferences). Using this instead of hardcoding the default
makes your code more portable. Default is "Z".

RELATED

}

{
detail

Reads the value of a detail attribute value from a geometry.

USAGES
  <type> detail(<geometry>, string attribute_name, int ignored=0)
  <type>[] detail(<geometry>, string attribute_name, int ignored=0)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

texttype
    The name of the attribute (or intrinsic) to read.

ignored
    The last argument is always ignored. It is just there so you can
    change a prim/point/vertex call (which each have an element number
    argument) to a detail call by changing the name without having to
    change the arguments as well.

    0 if importing the attribute failed, or the value of the attribute
    on success.

RELATED

}

{
detailattrib

Reads a detail attribute value from a geometry.

USAGES
  <type> detailattrib(<geometry>, string attribute_name, int ignored,
  int &success)
  <type>[] detailattrib(<geometry>, string attribute_name, int ignored,
  int &success)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

texttype
    The name of the attribute (or intrinsic) to read.

ignored
    Pass 0 for this argument.

success
    The function sets this variable to 1 if the attribute was
    successfully read, or 0 otherwise.

    0 if importing the attribute failed, the value of the attribute on
    success.

RELATED

}

{
detailattribsize

Returns the size of a geometry detail attribute.

USAGE
  int detailattribsize(<geometry>, string attribute_name)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

See attribsize for more information.

Returns 0 if the attribute cannot be found.

RELATED

}

{
detailattribtype

Returns the type of a geometry detail attribute.

USAGE
  int detailattribtype(<geometry>, string attribute_name)

See attribtype for more information.

RELATED

}

{
detailattribtypeinfo

Returns the type info of a geometry attribute.

USAGE
  string detailattribtypeinfo(<geometry>, string attribute_name)

See attribtypeinfo for more information.

RELATED

}

{
detailintrinsic

Reads the value of a detail intrinsic from a geometry.


    Intrinsic values are similar to attributes, but are computed on-
    demand by Houdini rather than stored.

USAGES
  <type> detailintrinsic(<geometry>, string intrinsic_name)
  <type>[] detailintrinsic(<geometry>, string intrinsic_name)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

texttype
    The name of the intrinsic to read. For example, "pointattributes",
    "pointcount", or "bounds".

    The intrinsic value, or 0 if the given intrinsic does not exist.

RELATED

  * primintrinsic

}

{
determinant

Computes the determinant of the matrix.

USAGES
  float determinant(matrix2 m)
  float determinant(matrix3 m)
  float determinant(matrix m)

See matrix determinant.

RELATED

}

{
diffuse

Returns a diffuse BSDF or computes diffuse shading.


USAGES
  bsdf diffuse(...)
  bsdf diffuse(float roughness, ...)
  bsdf diffuse(vector nml, ...)
  bsdf diffuse(vector nml, float roughness, ...)
  bsdf diffuse(vector nml, vector geo_normal, ...)
  bsdf diffuse(vector nml, vector geo_normal, float roughness, ...)
  Diffuse reflections. This BSDF has an albedo of 0.5. If your shader or
  geometry has smooth normals (N and Ng differ) you should avoid the
  signature diffuse(vector nml) since it assumes that the shading normal
  matches the geometric normal.

  See writing a PBR shader for information on BSDFs.

  vector diffuse(vector nml, ...)
  vector diffuse(vector nml, vector V, float roughness, ...)
  This form uses the Oren-Nayar lighting model to compute the diffuse
  illumination for the surface. The Oren-Nayar lighting model is a more
  sophisticated lighting model than Lambertian lighting. The V vector
  represents a vector from the surface to the eye (i.e. -normalize(I)).
  With a roughness of 0, the Oren-Nayar lighting model is equivalent to
  the Lambertian model. As roughness increases toward 1, the
  illumination changes to mimic rougher materials (like clay). The Oren-
  Nayar form of diffuse() is more expensive than Lambertian diffuse
  lighting.

LIGHT INCLUSION/EXCLUSION OPTIONS


    categories
        Specifies lights to include/exclude by their "category" tags.
        This is the preferred include/exclude lights rather than pattern
        matching light names with the "lightmask" keyword argument.

        For example:

      > diff = diffuse(nml, "lightmask", "hero | fill");

        See light categories for more information.

    lightmask
        When evaluating light and shadow shaders, objects have pre-
        defined light masks. This mask is usually specified in the
        geometry object and specifies a list of lights which are used to
        illuminate a surface or fog shader. It is possible to override
        the default light mask by specifying a "lightmask" argument.

        For example:

      > diff = diffuse(nml, "lightmask", "light*,^light2");

        ...will cause all lights whose names begin with "light" except
        for a light named "light2" to be considered for diffuse
        illumination.

        All Houdini scoping patterns, excepting group expansion, are
        supported:

      * * - wild-card match

      * ? - single character match

      * ^ - exclusion operator

      * [list] - character list match

RELATED

  * wirediffuse

  * translucent

  * Writing a PBR shader

}

{
diffuseBRDF

USAGE
  float diffuseBRDF(vector L, vector N)

Equivalent to clamp(dot(L, N), 0, 1).

USAGE
  float diffuseBRDF(vector L, vector N, vector V, float rough)

specularBRDF, phongBRDF, blinnBRDF, and diffuseBRDF return the computed
BRDF for the different lighting models used in VEX shading. You can use
them in custom illuminance loops to replicate the lighting models of the
corresponding VEX lighting functions.

See specularBRDF for some example code.

RELATED

  * specularBRDF

}

{
dihedral

Computes the rotation matrix or quaternion which rotates the vector a
onto the vector b.

USAGE
  matrix3 dihedral(vector a, vector b)

Computes the rotation matrix which rotates the vector <a> onto the
vector <b>.

USAGE
  vector4 dihedral(vector a, vector b)

Computes the quaternion which rotates the vector <a> onto the vector
<b>.

RELATED

}

{
dimport

Reads a variable from the displacement shader for the surface.

USAGE
  int dimport(string name, <type> &out)

Reads a variable from the displacement shader for the surface.

Mantra runs the shaders for a surface in a fixed order:

 1. Displacement

 2. Surface (possibly calling light shaders in illuminance loops)

 3. Fog (possibly calling light shaders in illuminance loops)

Once the displacement shader has run, you can use dimport to retrieve
exported variables from it. Once the surface shader has run, you can use
simport to retrieve exported variables from it.

If the shader variable named by the first argument is defined and
exported, the function returns 1 and puts the value in the second
argument. Otherwise, it returns 0.

RELATED

  * simport

}

{
distance

Returns the distance between two points.

USAGES
  float distance(vector2 a, vector2 b)
  float distance(vector a, vector b)
  float distance(vector4 a, vector4 b)

If you want the squared distance, use distance2 instead of using this
and pow.

RELATED

  * distance2

}

{
distance2

Returns the squared distance between the two points.

USAGES
  float distance2(vector2 a, vector2 b)
  float distance2(vector a, vector b)
  float distance2(vector4 a, vector4 b)

This returns the squared distance. To get the plain distance, use
distance.

RELATED

  * distance

}

{
dot

Returns the dot product between the arguments.

USAGES
  float dot(vector2 a, vector2 b)
  float dot(vector a, vector b)
  float dot(vector4 a, vector4 b)
  float dot(vector a, vector4 b)
  float dot(vector4 a, vector b)
  Returns the dot product of the arguments. If you pass vector4
  arguments, the function only uses the first three components.

RELATED

  * cross

}

{
dsmpixel

Reads the z-records stored in a pixel of a deep shadow map or deep
camera map.

USAGE
  int dsmpixel(string map, string channel; int x, int y; <type>
  &values[])

Each pixel of a deep shadow map channel has multiple values. This
function will extract the list of the values associated with the channel
for the given pixel.

Returns 1 on success and 0 on failure. If the function fails, the
<values> variable will *not* be modified, and so may be left
uninitialized.

A DSM will always have Pz and Of channels. The Pz channel stores the
z-depth associated with each record. The Of channel stores the opacity.

RELATED

  * teximport

}

{
efit

Takes the value in one range and shifts it to the corresponding value in
a new range.

USAGES
  float efit(float value, float omin, float omax, float nmin, float
  nmax)
  Takes the value in the range (<omin>, <omax>) and shifts it to the
  corresponding value in the new range (<nmin>, <nmax>). Unlike fit,
  this function does not clamp values to the given range.

  <vector> efit(<vector> value, <vector> omin, <vector> omax, <vector>
  nmin, <vector> nmax)
  <vector> efit(<vector> value, <vector> omin, <vector> omax, float
  nmin, float nmax)
  The vector versions fit per-component. You can specify per-component
  min/max values using vectors, or common min/max values using floats.

EXAMPLES

  > fit(.3, 0, 1, 10, 20) == 13

RELATED

  * clamp

  * fit

  * fit01

  * fit10

  * fit11

}

{
eigenvalues

Computes the eigenvalues of a 3x3 matrix.

USAGE
  void eigenvalues(int &nroot, matrix3 mat, vector &real, vector
  &imaginary)

Computes the eigenvalues of a 3x3 matrix.


nroot
    The function overwrites this variable with the number of real roots.

mat
    The matrix to compute the eigenvalues for.

real, imaginary
    The components of these two vectors are overwritten with
    corresponding pairs of real and imaginary parts of each eigenvalue.
    For example, real[0] and imaginary[0] contain the real and imaginary
    parts of the first eigenvalue.

RELATED

}

{
endswith

Indicates the string ends with the specified string.

USAGE
  int endswith(const string haystack, const string needle)

Returns 1 if the string ends with the given string. 0 otherwise.

RELATED

  * startswith

}

{
environment

Returns the color of the environment texture.

USAGES
  vector environment(string texture_filename, vector relect_dir, ...)
  vector4 environment(string texture_filename, vector relect_dir, ...)
  vector environment(string texture_filename, vector relect_dir0, vector
  relect_dir1, vector relect_dir2, vector relect_dir3, ...)
  vector4 environment(string texture_filename, vector relect_dir0,
  vector relect_dir1, vector relect_dir2, vector relect_dir3, ...)
  vector environment(string texture_filename, vector relect_dir, float
  filter_angle, ...)
  vector4 environment(string texture_filename, vector relect_dir, float
  filter_angle, ...)

Returns the color of the environment texture in the direction given by
the reflect_dir argument. The signatures that specify four vectors
filter the map pixels found within the cone defined by the vectors.
Rather than specifying a filtering cone by providing four vectors, it is
also possible to indicate an angle to filter over using the filter_angle
argument with a single reflection direction.

The environment function can also be used to look up intensity values in
an IES photometric light map, with the correct angular mapping applied.


NOTE
    To perform environment map lookups in object space, you'll need to
    first transform the direction vector using the vtransform()
    function.

IMAGE FILTERING OPTIONS

    Examples of specifying filter parameters:

  > colormap(map, u, v, "smode", "decal", "tmode", "repeat", "border", {.1,1,1});
  > colormap(map, u, v, "mode", "clamp", "width", 1.3);
  > colormap(map, u, v, "filter", "gauss", "width", 1.3, "mode", "repeat");

    If the texture is a deep .rat file, you can use the "channel"
    keyword argument to specify a channel in the file:

  > string channelname = "N";
  > cf = colormap(map, u, v, "channel", channelname);

    wrap

        repeat or periodic
            The image map will repeat outside the range 0 to 1.
            Basically, the integer component of the texture coordinate
            is ignored. This is the default.

        clamp or edge or streak
            The texture coordinates will be clamped to the range 0 to 1.
            This causes evaluations outside the range to evaluate to the
            color at the closest edge of the image (the border pixels
            are streaked outside the range).

        black or decal or color
            Coordinates outside the range 0 to 1 will evaluate to the
            border color (rather than a color in the image). The border
            color is black (i.e. 0) by default.

    uwrap
        (AKA swrap) Specifies the behavior when the u coordinate is
        outside the range 0 to 1. The values are the same as with wrap.

    vwrap
        (AKA twrap) Specifies the behavior when the v coordinate is
        outside the range 0 to 1. The values are the same as with wrap.

    border
        Specifies the border color when Black/Decal/Color wrapping is
        used.

    channel
        Specifies the color channel for textures that have multiple
        color planes (for example, diffuse_indirect or N). For ptex
        images, this specifies the index of the first channel (for
        example, 0 or 4).

    blur
        Blurs in x and y directions. Blur is measured as a percentage of
        the image size - so a blur of 0.1 will blur 10% of the image
        width. Use xblur and yblur if you need different blur amounts in
        either dimension.

    xblur
        (AKA ublur, sblur) Blur amount in the x image direction.

    yblur
        (AKA vblur, tblur) Blur amount in the y image direction.

    pixelblur
        Blurs the texture by a floating point number of pixels.

      > Cf = texture("map.rat", ss, tt, "pixelblur", 2.0);

    xpixelblur
        Blurs the texture by a floating point number of pixels in the X
        direction.

    ypixelblur
        Blurs the texture by a floating point number of pixels in the Y
        direction.

    filter
        Specifies the type of anti-aliasing filter to be used for
        evaluation. The following argument should be a string specifying
        one of:


        point
            Point sampling (i.e. no filtering)

        box
            Box filter (default)

        gauss
            Gaussian filter

        bartlett
            Bartlett/Triangular filter

        sinc
            Sinc sharpening filter

        hanning
            Hanning filter

        blackman
            Blackman filter

        catrom
            Catmull-Rom filter

    xfilter
        (AKA ufilter, sfilter) Specifies the filter for the X direction.
        The filters are the same as with filter.

    yfilter
        (AKA vfilter, tfilter) Specifies the filter for the Y direction.
        The filters are the same as with filter.

    width
        Filter width in both X and Y directions.

    xwidth
        (AKA uwidth, swidth) Filter width in the X direction.

    ywidth
        (AKA vwidth, twidth) Filter width in the Y direction.

    zwidth
        Filter width in the Z direction (for shadow maps). This is
        measured in world space units, unlike the other width arguments.

    extrapolate
        whether to use derivative extrapolation when computing anti-
        aliasing information. Extrapolation of derivatives is on by
        default. The argument should be either 0 or 1.

    lerp
        Specifies whether RAT files should interpolate between different
        MIP levels. By default, this is turned off. Turning
        interpolation on will help remove discontinuities when different
        MIP levels of a .rat file are accessed. However, the results of
        texture evaluation will be slightly softer (i.e. blurrier) and
        will take more time.

        There are three possible values for this argument.


        0
            Disable MIP map interpolation (fastest).

        1
            Approximate MIP map interpolation (fast).

        2
            High Quality MIP map interpolation (slower but highest
            quality).

    depthinterp
        Specifies the depth interpolation mode for deep shadow maps, to
        control the opacity value that will be returned when the map is
        sampled between two z-records.

        The argument must be a string.


        discrete
            (default) Return the first z-record before the sample point.

        linear
            Linearly interpolate the opacities of the z-records before
            and after the sample point.

        See deep shadow maps for more on the difference between the two
        modes.

    beerlambert
        When evaluating volumetric deep shadow maps, this will enable
        Beer-Lambert interpolation of opacity. Beer-Lambert is more a
        accurate but more expensive form of interpolation.

        The argument should be either 0 or 1.

    srccolorspace
        Specifies the color space in which the texture is stored. When
        texture values are accessed, they will be translated from this
        space into linear space for rendering if needed.


        auto
            (default) Determine the source color space based on the
            file. Currently, this will assume sRGB color space for 8-bit
            textures and linear for all other textures.

        linear
            Transform to linear space. This currently only affects 8-bit
            textures, since all others are assumed to be already in
            linear space. Use this option to force linear interpretation
            of textures used for bump or displacement maps.

    face
        When using a Ptex texture map, the face argument is used to
        specify the face for ptexture lookup.

    ptexorient
        When using Ptex textures, the implicit texture coordinates on
        polygons are used as the interpolants for texture lookup
        (combined with the face). However, different software may have
        different beliefs about winding and orientation. This keyword
        argument allows you to control the interpretation of orientation
        for Houdini polygons. The ptexorient expects an integer argument
        which is composed of a bit-field

        For example, a value of 6 (0x4|0x2) is equivalent to calling
        texture(map, 1-t, s) instead of texture(map, s, t).

        The default ptexorient is 0, which works correctly with the
        examples found at .

EXAMPLES

  > vector dir = vtransform("space:current", "space:object", {0, 1, 0});
  > vector clr = environment("sky.rat", dir);

RELATED

  * isixpack

}

{
erf

Gauss error function.

USAGES
  float erf(float v)
  vector2 erf(vector2 v)

The Gauss error function. Houdini uses the Boost library's
implementation internally.

The erf(vector2) version computes the complex error function and returns
the complex result. This function is much slower than the erf(float)
function for real values.

RELATED

  * erf_inv

  * erfc

}

{
erf_inv

Inverse Gauss error function.

USAGE
  float erf_inv(float v)

The inverse of the Gauss error function.

erf_inv(erf(v)) = v = erf(erf_inv(v))

To generate a normally-distributed random number, n, with mean mu and
standard deviation sigma, from a uniformly-distributed random number, u,
between 0 and 1,

n = mu + sqrt(2)*sigma*erf_inv(2*u - 1)

RELATED

  * erf

  * erfc

}

{
erfc

Gauss error function's complement.

USAGE
  float erfc(float v)

Equal to 1 - erf(v).

RELATED

  * erf

  * erf_inv

}

{
error

Reports a custom runtime VEX error.

USAGE
  void error(string format, ...)
  Reports a custom runtime VEX error. This uses the same format string
  syntax as printf.

  If something can still be done as an acceptable fallback, instead of
  outright failing, it may be worth reporting a warning, instead of an
  error.

EXAMPLES

  > if (!pointattribtype(0,chs("nameattrib")) != 2) {
  >     error("Name attribute %s must be a string attribute!", chs("nameattrib"));
  >     return;
  > }
  > if (chf("distance") < 0) {
  >     error("")
  > }
  > float minimumValue = chf("min");
  > float maximumValue = chf("max");
  > if (minimumValue >= maximumValue) {
  >     error("Minimum (%f) must be strictly less than maximum (%f)!  It's unclear what should be done.", minimumValue, maximumValue);
  >     return;
  > }

RELATED

  * warning

  * printf

}

{
eulertoquaternion

Creates a vector4 representing a quaternion from euler angles.

USAGE
  vector4 eulertoquaternion(vector rotations, int order)

Creates a vector4 representing a quaternion from a vector representing
Euler rotations in X, Y, and Z.

The angles are in radians. Use the radians() function to convert degrees
into radians.

Specify the rotation order with the <order> integer. Use the constants
defined in $HH/vex/include/math.h (for example, XFORM_XYZ).

RELATED

  * dihedral

  * qconvert

  * quaternion

}

{
eval_bsdf

Evaluates a bsdf given two vectors.

USAGES
  vector eval_bsdf( bsdf b; vector viewer; vector light; ... )
  vector eval_bsdf( bsdf b; vector viewer; vector light; int mask; ... )
  vector eval_bsdf( bsdf b; vector viewer; vector light; float &pdf; int
  mask; ... )
  vector eval_bsdf( bsdf b; vector viewer; vector light; vector normal;
  ... )
  vector eval_bsdf( bsdf b; vector viewer; vector light; vector normal;
  int mask; ... )
  vector eval_bsdf( bsdf b; vector viewer; vector light; vector normal;
  float &pdf; int mask; ... )


b
    BSDF to evaluate.

viewer
    Vector toward viewer.

light
    Vector toward light.

normal
    Surface normal.

mask
    A bitmask indicating which types of shading component bounces to
    evaluate.

    See bouncemask for information on component label bitmasks.

&pdf
    The function overwrites this variable with the computed PDF for the
    given directions, scaled by the albedo.

VARIADIC ARGUMENTS

    The eval_bsdf function passes any extra "name", value argument pairs
    to the BSDF being evaluated. For custom BSDFs these keyword
    arguments are bound to shader arguments (e.g. indicating whether the
    BSDF is being evaluated for direct or indirect illumination). It's
    also possible for a BSDF to pass information back to eval_bsdf. To
    indicate that a keyword argument value should be imported from the
    BSDF prefix the keyword with "import:"

EXAMPLES

  > v = eval_bsdf(F, inI, dir,
  >     "direct", 0,                        // Specify indirect illumination
  >     "import:sssmfp", sssmfp,        // Read the exported sssmfp parameter
  >     ...
  > );

RELATED

  * albedo

  * sample_bsdf

  * emission_bsdf()

}

{
exp

Returns the exponential function of the argument.

USAGES
  float exp(float n)
  <vector> exp(<vector> n)
  Returns the Exponential function of n. For vectors, this is done per-
  component.

RELATED

}

{
expand_udim

Perform UDIM or UVTILE texture filename expansion.

USAGE
  string expand_udim(float u, float v; string path, ...)
  Scans the input path for special conversion characters to perform
  either UDIM or UVTILE style filename expansion.

This is similar to texprintf, with two significant differences:

  * There are no variadic print arguments. Only UDIM/UVTILE expansion is
    performed.

  * If UDIM/UVTILE expansion was performed, the function checks to see
    if the texture exists and is accessible.


u, v
    The texture coordinates to translate into a UDIM tile specification.

path
    A file path. Special character sequences in the path will be
    expanded into UDIM specifiers based on the given UV coordinates. The
    special conversion sequences are:

    %(UDIM)d

    The UDIM coordinate, as computed by 1000 + int(u)+1 + int(v)*10

    %(U)d

    The UVTILE style u-coordinate (int(u)+1)

    %(V)d

    The UVTILE style v-coordinate (int(v)+1)

    %(UVTILE)d

    Expands both u and v coordinates in the form u%d_v%d.

    The d conversion specifier for texture identification can be
    modified with field modifiers. For example %(U)02d or %(V)04d.

checkfile
    Normally, the function checks whether the expanded path exists and
    is readable. If you pass the "checkfile", 0 pair, the function will
    not perform this check.

    The path with any UDIM control sequences replaced.

    If the expanded file path does not exist or is not readable, the
    function will return an empty string, unless you turn off the
    checkfile variadic argument.

EXAMPLES

  * expand_udim(3.1, 4.15, "map_%(UDIM)d.rat") - Returns "map_1044.rat"

  * expand_udim(3.1, 4.15, "map_%(U)02d_%(V)02d.rat") - Returns
    "map_04_05.rat"

  * expand_udim(3.14, 11.5, "map_u%(U)d_v%(V)d.rat") - Returns
    "map_u4_v12.rat"

  * expand_udim(3.14, 11.5, "missing_file%(UDIM)d.rat") - Returns "" for
    missing files.

  * expand_udim(3.14, 11.5, "missing_file%(UDIM)d.rat", "checkfile", 0)
    - Returns "missing_file1044.rat" since "checkfile" is disabled.

  * expand_udim(3.14, 11.5, "/path/file.rat") - Returns "/path/file.rat"
    whether the file exists or not since there are no UDIM/UVTILE
    expansions.

  > 
  > // sprintf() will leave the %(UDIM)d format sequence unmodified.
  > string map = sprintf("%s/%s_%(UDIM)d.rat", texture_path, texture_base);
  > // Expand the %(UDIM)d, returning an empty string if the map doesn't exist.
  > map = expand_udim(u, v, map);
  > if (map != "")
  > Cf = texture(map, u, v);

RELATED

  * texprintf

  * texture

}

{
expandedgegroup

USAGES
  int [] expandedgegroup(string filename, string groupname)
  int [] expandedgegroup(int input, string groupname)

Returns a list of point pairs of the edges in the specified group of a
geometry file.

This can use ad-hoc groups, like 0 or p0-1. It matches the SOP group
naming convention, in particular that an empty string means all edges.

RELATED

  * inedgegroup

  * nedgesgroup

}

{
expandpointgroup

USAGE
  int [] expandpointgroup(<geometry>, string groupname)

Returns a list of points in the specified group of a geometry file.

This can use ad-hoc groups, like 0-3 or @Cd.x>0.5. It matches the SOP
group naming convention, in particular that an empty string means all
points.

RELATED

  * inpointgroup

  * npointsgroup

  * hasattrib

}

{
expandprimgroup

USAGE
  int [] expandprimgroup(<geometry>, string groupname)

Returns a list of primitives in the specified group of a geometry file.

This can use ad-hoc groups, like 0-3 or @Cd.x>0.5. It matches the SOP
group naming convention, in particular that an empty string means all
primitives.

RELATED

  * inprimgroup

  * nprimitivesgroup

  * hasattrib

}

{
fastshadow

Sends a ray from the position P along the direction specified by the
direction D.

USAGE
  float fastshadow(vector P, vector D, float bias, ...)

Sends a ray from the position <P> along the direction specified by the
direction <D>. The length of the <D> vector represents the farthest
distance considered when check for occlusion.

Returns 1 if there are no occluding objects found, or 0 if the ray hit
an object in between.

AREA SAMPLING OPTIONS

    For area sampling, you must specify both the angle and sample
    variadic parameters. For example:

  > surface
  > blurry_mirror(float angle = 3; int samples = 16; float bias=0.05)
  > {
  >     Cf = reflectlight(bias, 1, "angle", angle, "samples", samples);
  > }

RAY OPTIONS


    TIP
        When you specify a texture, such as with the "environment"
        keyword, you can also use the image filtering keyword arguments.
        See environment for a listing of the image filter keyword
        arguments.


    scope
        A list of objects which can be hit by the rays. When specified,
        scope overrides the default scope that would have been selected
        for the given raystyle. The "scope:default" value will cause the
        scope argument to use the default scope for the current context
        - as if the argument were not specified.

        Allows an override of the scope for ray-intersections. A special
        scope argument, scope:self, will match the currently shading
        object.

    maxdist
        The maximum distance to search for objects. This can be used to
        limit the search of objects to nearby objects only. If the
        maxdist given is negative, then it will act as if there is no
        maximum distance.

        Allows an override of the maximum distance the ray can travel
        when testing for intersections. Some functions (such as
        fastshadow) have the maximum distance implicitly defined (by the
        length of the ray) and should probably avoid using this option.
        However, this option can be used effectively when computing
        reflections, global illumination, refraction etc.

    variancevar
        The name of a VEX export variable to use for variance anti-
        aliasing. The renderer compares the value with adjacent
        micropolygons in micropolygon rendering to decide what shading
        points need additional samples (using vm_variance property as a
        threshold). If more samples are required, the algorithm takes
        samples up to the specified maximum ray samples.

        This variable must be imported from the hit surface, so it must
        be in the list of imported names (see "importing information
        back from the ray" below). If the named variable is not
        imported, this option will be ignored.

        Variance antialiasing puts more samples in areas of the image
        with high variance, for example a sharp shadow edge. It is only
        used when vm_dorayvariance is enabled. Otherwise, only the min
        ray samples (or an explicitly supplied "samples" value) are used
        for antialiasing of the gather loop.

        Overrides the global variance control (mantra's -v option) which
        is used to determine anti-aliasing quality of ray tracing. For
        more information please refer to the documentation on mantra.

    angle
        The distribution angle (specified in radians). For gather(),
        rays will be distributed over this angle. For trace(), the angle
        is used to indicate the rate at which the filter width should
        increase with increasing intersection distance. Larger angles
        will cause farther hit surfaces to use larger derivatives,
        leading to improved texturing and displacement performance.

        To be effective, the samples parameter should also be specified.

    samples
        How many samples should be sent out to filter rays. For the
        irradiance and occlusion functions, specifying a samples
        parameter will override the default irradiance sampling.

    environment
        If the ray sent out to the scene misses everything, then it's
        possible to specify an environment map to evaluate.

        Using the ray's direction, the environment map specified will be
        evaluated and the resulting color will be returned. Most likely,
        it will be necessary to specify a transform space for the
        environment map evaluations.

        In the case of refractlight and trace the Of and Af variables
        will be set to 0 regardless of the background color specified.
        the resulting color.

        When an environment map is specified, the filtering options from
        texture() are also supported.

        See how to create an environment/reflection map.

    envobject
        If an environment map is used, the orientation of the
        environment map can be specified by transforming the ray into
        the space of another object, light or fog object in the scene.
        In Houdini, null objects can be used to specify the orientation.
        For example:

      > Cf = R*reflectlight(bias, max(R), "environment", "map.rat", "envobject", "null_object_name");

    envlight
        If an environment map is used, the orientation of the
        environment map can be specified by transforming the ray into
        the space of a light in the scene.

    envtint
        If an environment map is used, tint it with this color.

    background
        If a ray misses all objects, use this as the background color of
        the scene. In the case of refractlight and trace the Of and Af
        variables will be set to 0 regardless of the background color
        specified.

    distribution
        *Functions*: irradiance, occlusion

        Distribution for computing irradiance. The default is to use a
        cosine distribution (diffuse illumination). The possible values
        for the style are "nonweighted" for uniform sampling or "cosine"
        for cosine weighted sampling.

RELATED

}

{
filamentsample

Samples the velocity field defined by a set of vortex filaments.

USAGE
  vector filamentsample(<geometry>, vector position)

Samples the velocity field defined by a set of vortex filaments at the
specified position. The inputnum or filename parameter specifies the
geometry to fetch the filament curves from. The strength and thickness
primitive attributes can be used on the geometry to customize the
strength and thickness of each filament. Returns the zero vector if
inputnum is out of range or the filename is invalid.

RELATED

}

{
file_stat

Returns file system status for a given file.

USAGE
  int file_stat(string filename, int &stat_data[], ...)
  Overwrites an integer array with data representing the file system
  information for the given file.

  *Do not use this function*. The file.h include file has more
  convenient versions of this function which return a struct.


usecache
    If this option is on, the function will use a persistent cache to
    store results of the function. The cache is persistent over the
    entire run of the application.

    1 if the path is valid or 0 otherwise.

BETTER FILE_STAT FUNCTIONS

    Instead of using the built-in file_stat, add this line at the top of
    the file:

  > #include <file.h>

    Then use the file_stat or cached_file_stat functions from that file.
    They take a file path string and return a struct with the following
    members:

    .st_size

    The size of the file in bytes.

    .st_sizemb

    The size of the file in megabytes.

    .st_mtime

    The last modified time of this file.

    ->isValid()

    Return 1 if the file path refers to a valid file.

    ->isFile()

    Returns 1 if the file path refers to a file (rather than a
    directory).

    ->isDir()

    Returns 1 if the file path refers to a directory (rather than a
    file).

    ->isRead()

    Returns 1 if the file is readable.

    ->isWrite()

    Returns 1 if the file is writable.

    ->isExecute()

    Returns 1 if the file is executable.

EXAMPLES

  > #include <file.h>
  > 
  > int file_size(string name)
  > {
  >     stat        info(name);
  >     return file_stat(name)->st_size;
  > }
  > 
  > int file_exists(string name)
  > {
  >     // Use cached file_stat() results
  >     return cached_file_stat(name)->isValid();
  > }
  > 
  > int file_isdir(string name)
  > {
  >     return file_stat(name)->isDir();
  > }

}

{
filtershadow

Sends a ray from the position P along direction D.

USAGE
  vector filtershadow(vector P, vector D, float bias, ...)

Sends a ray from the position <P> along direction <D>. The length of the
<D> vector represents the farthest distance considered when check for
occlusion.

Each occluding surface will be evaluated and its opacity will be added
to the total occlusion. The return code of this function is the total
occlusion of shaded surfaces between the point <P> and the point
specified by <P> + <D>.

AREA SAMPLING OPTIONS

    For area sampling, you must specify both the angle and sample
    variadic parameters. For example:

  > surface
  > blurry_mirror(float angle = 3; int samples = 16; float bias=0.05)
  > {
  >     Cf = reflectlight(bias, 1, "angle", angle, "samples", samples);
  > }

RAY OPTIONS


    TIP
        When you specify a texture, such as with the "environment"
        keyword, you can also use the image filtering keyword arguments.
        See environment for a listing of the image filter keyword
        arguments.


    scope
        A list of objects which can be hit by the rays. When specified,
        scope overrides the default scope that would have been selected
        for the given raystyle. The "scope:default" value will cause the
        scope argument to use the default scope for the current context
        - as if the argument were not specified.

        Allows an override of the scope for ray-intersections. A special
        scope argument, scope:self, will match the currently shading
        object.

    maxdist
        The maximum distance to search for objects. This can be used to
        limit the search of objects to nearby objects only. If the
        maxdist given is negative, then it will act as if there is no
        maximum distance.

        Allows an override of the maximum distance the ray can travel
        when testing for intersections. Some functions (such as
        fastshadow) have the maximum distance implicitly defined (by the
        length of the ray) and should probably avoid using this option.
        However, this option can be used effectively when computing
        reflections, global illumination, refraction etc.

    variancevar
        The name of a VEX export variable to use for variance anti-
        aliasing. The renderer compares the value with adjacent
        micropolygons in micropolygon rendering to decide what shading
        points need additional samples (using vm_variance property as a
        threshold). If more samples are required, the algorithm takes
        samples up to the specified maximum ray samples.

        This variable must be imported from the hit surface, so it must
        be in the list of imported names (see "importing information
        back from the ray" below). If the named variable is not
        imported, this option will be ignored.

        Variance antialiasing puts more samples in areas of the image
        with high variance, for example a sharp shadow edge. It is only
        used when vm_dorayvariance is enabled. Otherwise, only the min
        ray samples (or an explicitly supplied "samples" value) are used
        for antialiasing of the gather loop.

        Overrides the global variance control (mantra's -v option) which
        is used to determine anti-aliasing quality of ray tracing. For
        more information please refer to the documentation on mantra.

    angle
        The distribution angle (specified in radians). For gather(),
        rays will be distributed over this angle. For trace(), the angle
        is used to indicate the rate at which the filter width should
        increase with increasing intersection distance. Larger angles
        will cause farther hit surfaces to use larger derivatives,
        leading to improved texturing and displacement performance.

        To be effective, the samples parameter should also be specified.

    samples
        How many samples should be sent out to filter rays. For the
        irradiance and occlusion functions, specifying a samples
        parameter will override the default irradiance sampling.

    environment
        If the ray sent out to the scene misses everything, then it's
        possible to specify an environment map to evaluate.

        Using the ray's direction, the environment map specified will be
        evaluated and the resulting color will be returned. Most likely,
        it will be necessary to specify a transform space for the
        environment map evaluations.

        In the case of refractlight and trace the Of and Af variables
        will be set to 0 regardless of the background color specified.
        the resulting color.

        When an environment map is specified, the filtering options from
        texture() are also supported.

        See how to create an environment/reflection map.

    envobject
        If an environment map is used, the orientation of the
        environment map can be specified by transforming the ray into
        the space of another object, light or fog object in the scene.
        In Houdini, null objects can be used to specify the orientation.
        For example:

      > Cf = R*reflectlight(bias, max(R), "environment", "map.rat", "envobject", "null_object_name");

    envlight
        If an environment map is used, the orientation of the
        environment map can be specified by transforming the ray into
        the space of a light in the scene.

    envtint
        If an environment map is used, tint it with this color.

    background
        If a ray misses all objects, use this as the background color of
        the scene. In the case of refractlight and trace the Of and Af
        variables will be set to 0 regardless of the background color
        specified.

    distribution
        *Functions*: irradiance, occlusion

        Distribution for computing irradiance. The default is to use a
        cosine distribution (diffuse illumination). The possible values
        for the style are "nonweighted" for uniform sampling or "cosine"
        for cosine weighted sampling.

RELATED

}

{
filterstep

Returns the anti-aliased weight of the step function.

USAGES
  float filterstep(float edge, float x, ...)
  float filterstep(float edge, float x0, float x1, ...)

Returns the anti-aliased weight of the step function. The step function
returns 0 if x is less than edge and 1 if x is greater than edge.
filterstep returns a fraction representing the filtered area under the
step function. Filtering is computed using derivatives Du() and Dv()
which are only non-zero in shading and COP contexts, so filterstep will
not perform filtering in other contexts.

IMAGE FILTERING OPTIONS

    Examples of specifying filter parameters:

  > colormap(map, u, v, "smode", "decal", "tmode", "repeat", "border", {.1,1,1});
  > colormap(map, u, v, "mode", "clamp", "width", 1.3);
  > colormap(map, u, v, "filter", "gauss", "width", 1.3, "mode", "repeat");

    If the texture is a deep .rat file, you can use the "channel"
    keyword argument to specify a channel in the file:

  > string channelname = "N";
  > cf = colormap(map, u, v, "channel", channelname);

    wrap

        repeat or periodic
            The image map will repeat outside the range 0 to 1.
            Basically, the integer component of the texture coordinate
            is ignored. This is the default.

        clamp or edge or streak
            The texture coordinates will be clamped to the range 0 to 1.
            This causes evaluations outside the range to evaluate to the
            color at the closest edge of the image (the border pixels
            are streaked outside the range).

        black or decal or color
            Coordinates outside the range 0 to 1 will evaluate to the
            border color (rather than a color in the image). The border
            color is black (i.e. 0) by default.

    uwrap
        (AKA swrap) Specifies the behavior when the u coordinate is
        outside the range 0 to 1. The values are the same as with wrap.

    vwrap
        (AKA twrap) Specifies the behavior when the v coordinate is
        outside the range 0 to 1. The values are the same as with wrap.

    border
        Specifies the border color when Black/Decal/Color wrapping is
        used.

    channel
        Specifies the color channel for textures that have multiple
        color planes (for example, diffuse_indirect or N). For ptex
        images, this specifies the index of the first channel (for
        example, 0 or 4).

    blur
        Blurs in x and y directions. Blur is measured as a percentage of
        the image size - so a blur of 0.1 will blur 10% of the image
        width. Use xblur and yblur if you need different blur amounts in
        either dimension.

    xblur
        (AKA ublur, sblur) Blur amount in the x image direction.

    yblur
        (AKA vblur, tblur) Blur amount in the y image direction.

    pixelblur
        Blurs the texture by a floating point number of pixels.

      > Cf = texture("map.rat", ss, tt, "pixelblur", 2.0);

    xpixelblur
        Blurs the texture by a floating point number of pixels in the X
        direction.

    ypixelblur
        Blurs the texture by a floating point number of pixels in the Y
        direction.

    filter
        Specifies the type of anti-aliasing filter to be used for
        evaluation. The following argument should be a string specifying
        one of:


        point
            Point sampling (i.e. no filtering)

        box
            Box filter (default)

        gauss
            Gaussian filter

        bartlett
            Bartlett/Triangular filter

        sinc
            Sinc sharpening filter

        hanning
            Hanning filter

        blackman
            Blackman filter

        catrom
            Catmull-Rom filter

    xfilter
        (AKA ufilter, sfilter) Specifies the filter for the X direction.
        The filters are the same as with filter.

    yfilter
        (AKA vfilter, tfilter) Specifies the filter for the Y direction.
        The filters are the same as with filter.

    width
        Filter width in both X and Y directions.

    xwidth
        (AKA uwidth, swidth) Filter width in the X direction.

    ywidth
        (AKA vwidth, twidth) Filter width in the Y direction.

    zwidth
        Filter width in the Z direction (for shadow maps). This is
        measured in world space units, unlike the other width arguments.

    extrapolate
        whether to use derivative extrapolation when computing anti-
        aliasing information. Extrapolation of derivatives is on by
        default. The argument should be either 0 or 1.

    lerp
        Specifies whether RAT files should interpolate between different
        MIP levels. By default, this is turned off. Turning
        interpolation on will help remove discontinuities when different
        MIP levels of a .rat file are accessed. However, the results of
        texture evaluation will be slightly softer (i.e. blurrier) and
        will take more time.

        There are three possible values for this argument.


        0
            Disable MIP map interpolation (fastest).

        1
            Approximate MIP map interpolation (fast).

        2
            High Quality MIP map interpolation (slower but highest
            quality).

    depthinterp
        Specifies the depth interpolation mode for deep shadow maps, to
        control the opacity value that will be returned when the map is
        sampled between two z-records.

        The argument must be a string.


        discrete
            (default) Return the first z-record before the sample point.

        linear
            Linearly interpolate the opacities of the z-records before
            and after the sample point.

        See deep shadow maps for more on the difference between the two
        modes.

    beerlambert
        When evaluating volumetric deep shadow maps, this will enable
        Beer-Lambert interpolation of opacity. Beer-Lambert is more a
        accurate but more expensive form of interpolation.

        The argument should be either 0 or 1.

    srccolorspace
        Specifies the color space in which the texture is stored. When
        texture values are accessed, they will be translated from this
        space into linear space for rendering if needed.


        auto
            (default) Determine the source color space based on the
            file. Currently, this will assume sRGB color space for 8-bit
            textures and linear for all other textures.

        linear
            Transform to linear space. This currently only affects 8-bit
            textures, since all others are assumed to be already in
            linear space. Use this option to force linear interpretation
            of textures used for bump or displacement maps.

    face
        When using a Ptex texture map, the face argument is used to
        specify the face for ptexture lookup.

    ptexorient
        When using Ptex textures, the implicit texture coordinates on
        polygons are used as the interpolants for texture lookup
        (combined with the face). However, different software may have
        different beliefs about winding and orientation. This keyword
        argument allows you to control the interpretation of orientation
        for Houdini polygons. The ptexorient expects an integer argument
        which is composed of a bit-field

        For example, a value of 6 (0x4|0x2) is equivalent to calling
        texture(map, 1-t, s) instead of texture(map, s, t).

        The default ptexorient is 0, which works correctly with the
        examples found at .

EXAMPLES

  > f = filterstep(0.5, s+t, "filter", "gauss", "width", 2);
    The filterstep(float edge, x, ...) form is roughly equivalent to:

  > f = filterstep(edge, x, x + abs(Du(x) + Dv(x)));

RELATED

}

{
find

Finds an item in an array or string.

USAGES
  int find(string haystack; string needle)
  int find(string haystack; string needle; int start)
  int find(string haystack; string needle; int start; int end)
  Returns the position of the first occurrence of the needle string
  within the haystack string. You can limit the result to the first
  substring that starts at or after a start position, and at or before
  an end position.

  You can find each occurrence in a loop by setting start at each
  iteration to the end of the previous match.

  Returns a negative number if the substring is not found.

  int [] find(string haystack; string needle)
  int [] find(string haystack; string needle; int start)
  int [] find(string haystack; string needle; int start; int end)
  Returns a list of positions of occurrences of the needle string within
  the haystack string. You can limit the results to substrings that
  start at or after a start position, and before an end position.

  Returns an empty array if the substring is not found.

  int find(<type> array[]; <type> target)
  int find(<type> array[]; <type> target; int start)
  int find(<type> array[]; <type> target; int start; int end)
  Returns the position of the first occurrence of the target value
  within the array. You can limit the result to the first occurrence at
  or after a start position, and at or before an end position.

  You can find each occurrence in a loop by setting start at each
  iteration to the next position after the previous match.

  Returns a if the

  int [] find(<type> array[]; <type> target)
  int [] find(<type> array[]; <type> target; int start)
  int [] find(<type> array[]; <type> target; int start; int end)
  Returns a list of positions of occurrences of the target value within
  the array. You can limit the results to occurrences at or after a
  start position, and before an end position.

  * When you specify an end position, it means the matching substring
    must _start_ before the end.

  * The scalar versions return -len(haystack)-1 to indicate no matches.
    This value is intended to cause an error if you try to use it as an
    index into the string/array.

  * Searching for the empty string always fails. This differs from
    Python.

  * You cannot use negative indices for the start and end arguments.

RELATED

  * len

  * push

  * append

  * resize

  * Arrays

}

{
findattribval

Finds a primitive/point/vertex that has a certain attribute value.

USAGE
  int findattribval( <geometry>, string attribclass, string
  attribute_name, int|string value, int which=0)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

texttype
    One of "detail" (or "global"), "point", "prim", or "vertex".

    You can also use "primgroup", "pointgroup" or "vertexgroup" to read
    from groups.

texttype
    The name of the attribute (or intrinsic) to read.

value
    The value to look for in the attribute.

which
    If multiple elements have the given value in the attribute, the
    controls which match to return.

    If you're searching for multiple elements with the same attribute
    value, you can use findattribvalcount to get the total number of
    matches and then iterate through them by increasing the which
    argument to this function in a loop. See the examples below.

    The number of the first point/primitive/vertex where the named
    attribute matches the given value. Returns -1 if no element has the
    given attribute value.


TIP
    The most common use cases (finding an point/primitive by its name or
    id attribute) have easier-to-use dedicated wrapper functions:
    nametopoint, nametoprim, idtopoint, and idtoprim.

  * You can only search for integer or string values.

EXAMPLES


    Find the primitive with @id == 10
      > int prim_num = findattribval(0, "prim", "id", 10);
      > // Note: you can use idtoprim(0, 10) instead
    Find all points with @age == 10
      > int count = findattribvalcount(0, "point", "age", 10);
      > int point_num;
      > for (int i = 0; i < count; i++) {
      >     point_num = findattribval(0, "point", "age", 10, i);
      >     // ...do something with the point...
      > }

RELATED

  * nametopoint

  * nametoprim

  * idtopoint

  * idtoprim

  * findattribvalcount

}

{
findattribvalcount

Returns number of elements where an integer or string attribute has a
certain value.

USAGES
  int findattribvalcount( <geometry>, string class, string
  attribute_name, int value)
  int findattribvalcount( <geometry>, string class, string
  attribute_name, string value)

Returns the number of elements that has that integer or string value set
on the given attribute name.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

class
    What type of attribute: detail, primitive, point, or vertex.

attribute_name
    The name of the attribute, ie P or Cd.

value
    The value to match. Must be of the same type as the attribute.

RELATED

}

{
finput

Returns fully filtered pixel input.

USAGES
  vector finput(int u, int v, ...)
  vector4 finput(int u, int v, ...)
  vector finput(float u, float v, ...)
  vector4 finput(float u, float v, ...)
  float finput(int component, int u, int v, ...)
  float finput(int component, float u, float v, ...)
  vector finput(int opinput, int planeindex, int u, int v, ...)
  vector4 finput(int opinput, int planeindex, int u, int v, ...)
  vector finput(int opinput, int planeindex, float u, float v, ...)
  vector4 finput(int opinput, int planeindex, float u, float v, ...)
  float finput(int opinput, int planeindex, int component, int u, int v,
  ...)
  float finput(int opinput, int planeindex, int component, float u,
  float v, ...)
  vector finput(int opinput, int planeindex, int arrayindex, int u, int
  v, int frame, ...)
  vector4 finput(int opinput, int planeindex, int arrayindex, int u, int
  v, int frame, ...)
  vector finput(int opinput, int planeindex, int arrayindex, float u,
  float v, int frame, ...)
  vector4 finput(int opinput, int planeindex, int arrayindex, float u,
  float v, int frame, ...)
  float finput(int opinput, int planeindex, int arrayindex, int
  component, int u, int v, int frame, ...)
  float finput(int opinput, int planeindex, int arrayindex, int
  component, float u, float v, int frame, ...)

See COP pixel sampling functions for more information.

RELATED

  * COP pixel sampling functions

  * binput

  * cinput

  * ninput

}

{
fit

Takes the value in one range and shifts it to the corresponding value in
a new range.

USAGES
  float fit(float value, float omin, float omax, float nmin, float nmax)
  <vector> fit(<vector> value, <vector> omin, <vector> omax, <vector>
  nmin, <vector> nmax)
  Takes the value in the range (<omin>, <omax>) and shifts it to the
  corresponding value in the new range (<nmin>, <nmax>).

  The function clamps the given value the range (<omin>, <omax>) before
  fitting, so the resulting value will be guaranteed to be in the range
  (<nmin>, <nmax>). To avoid clamping use efit instead.

EXAMPLES

  > fit(.3, 0, 1, 10, 20) == 13

RELATED

  * clamp

  * fit01

  * fit10

  * fit11

  * efit

}

{
fit01

Takes the value in the range (0, 1) and shifts it to the corresponding
value in a new range.

USAGES
  float fit01(float value, float nmin, float nmax)
  <vector> fit01(<vector> value, <vector> nmin, <vector> nmax)
  Takes the value in the range (0, 1) and shifts it to the corresponding
  value in the new range (<nmin>, <nmax>). For vectors it does this per-
  component.

RELATED

  * clamp

  * fit

  * fit10

  * fit11

  * efit

}

{
fit10

Takes the value in the range (1, 0) and shifts it to the corresponding
value in a new range.

USAGES
  float fit10(float value, float nmin, float nmax)
  <vector> fit10(<vector> value, <vector> nmin, <vector> nmax)
  Takes the value in the range (1, 0) and shifts it to the corresponding
  value in the new range (<nmin>, <nmax>). For vectors it does this per-
  component.

RELATED

  * clamp

  * fit

  * fit01

  * fit11

  * efit

}

{
fit11

Takes the value in the range (-1, 1) and shifts it to the corresponding
value in a new range.

USAGES
  float fit11(float value, float nmin, float nmax)
  <vector> fit11(<vector> value, <vector> nmin, <vector> nmax)
  Takes the value in the range (-1, 1) and shifts it to the
  corresponding value in the new range (<nmin>, <nmax>). For vectors it
  does this per-component.

RELATED

  * clamp

  * fit

  * fit01

  * fit10

  * efit

}

{
floor

Returns the largest integer less than or equal to the argument.

USAGES
  int|float floor(float n)
  <vector> floor(<vector> v)
  Returns the largest integer less than or equal to the argument. For
  vectors, this is done per-component.

RELATED

}

{
flownoise

Generates 1D and 3D Perlin Flow Noise from 3D and 4D data.

USAGES
  float flownoise(vector xyz, float flow)
  vector flownoise(vector xyz, float flow)
  float flownoise(vector4 xyzt, float flow)
  vector flownoise(vector4 xyzt, float flow)
  float flownoise(float x, float y, float flow)
  vector flownoise(float x, float y, float flow)

This operator generates 1D and 3D Perlin Flow noise from 3D and 4D data.
There are two forms of Perlin flow noise: a non-periodic noise which
changes randomly throughout the N-dimensional space, and a periodic form
which repeats itself over a given range of the space. The periodic form
can be used to generate patterns which tile over N-dimensional space,
such as a noise-based texture map which repeats seamlessly.

The noise has a range of (0, 1) with a median value of 0.5. The
distribution of the noise depends on the dimension, with higher
dimensions approaching a Gaussian distribution of noise values.

Flow noise is very similar to Perlin noise, as in Periodic Noise, but
with an extra flow parameter. The flow parameter can be thought of as an
extra dimension, but a dimension whose period is always 1. Moving
through the flow dimension rotates the noise vectors rather than
adjusting slices through a noise space, which generates a more flowing
appearance to the animation.

RELATED

  * Noise and randomness

  * anoise

  * curlnoise

  * flownoise

  * noise

  * onoise

  * pnoise

  * snoise

  * vnoise

  * wnoise

  * xnoise

}

{
flowpnoise

There are two forms of Perlin-style noise: a non-periodic noise which
changes randomly throughout N-dimensional space, and a periodic form
which repeats over a given range of space.

USAGES
  float flowpnoise(vector xyz, vector p, float flow)
  vector flowpnoise(vector xyz, vector p, float flow)
  float flowpnoise(vector4 xyzt, vector4 p, float flow)
  vector flowpnoise(vector4 xyzt, vector4 p, float flow)
  float flowpnoise(float x, float y, int px, int py, float flow)
  vector flowpnoise(float x, float y, int px, int py, float flow)
  float flowpnoise(vector xyz, int px, int py, int pz, float flow)
  vector flowpnoise(vector xyz, int px, int py, int pz, float flow)
  float flowpnoise(vector4 xyzt, int px, int py, int pz, int pt, float
  flow)
  vector flowpnoise(vector4 xyzt, int px, int py, int pz, int pt, float
  flow)

This operator generates 1D and 3D Perlin Flow noise from 3D and 4D data.
There are two forms of Perlin flow noise: a non-periodic noise which
changes randomly throughout the N-dimensional space, and a periodic form
which repeats itself over a given range of the space. The periodic form
can be used to generate patterns which tile over N-dimensional space,
such as a noise-based texture map which repeats seamlessly.

The noise has a range of (0, 1) with a median value of 0.5. The
distribution of the noise depends on the dimension, with higher
dimensions approaching a Gaussian distribution of noise values.

Flow noise is very similar to Perlin noise, as in Periodic Noise, but
with an extra flow parameter. The flow parameter can be thought of as an
extra dimension, but a dimension whose period is always 1. Moving
through the flow dimension rotates the noise vectors rather than
adjusting slices through a noise space, which generates a more flowing
appearance to the animation.

See noise and randomness in the VEX language guide for more information.

RELATED

  * noise

}

foreach

Loops over the items in an array, with optional enumeration.

The length of the array is determined before the first iteration, so if
the array is changed during the foreach this will not be reflected in
the number of iterations.

SIMPLE FORM

  > foreach ([element_type] value; array) {
  > 
  > }
    This loops over the members of <array>. For each iteration, it
    *copies* the current member to <value> and then executes
    <statement>. For example:

  > int an_array[] = {1, 2}
  > foreach (int num; an_array) {
  >     printf("%d", num);
  > }

ENUMERATED FORM

    The second form lets you specify an enumeration variable:

  > foreach (index, value; array) statement;
  > foreach (int index; element_type value; array) statement;

    For each iteration, this form assigns the current _position_ in the
    array to <index>, *copies* the current member to <value>, and
    executes <statement>. For example:

  > string days[] = { "Mon", "Tue", "Wed", "Thu", "Fri" }
  > foreach (int i; string name; days) {
  >     printf("Day number %d is %s", i, name);
  > }

    This is similar to the common Python idiom for i, x in
    enumerate(xs):.

RELATED

  * Arrays

forpoints

In the image3d context, when geometry is specified (i.e. metaball
geometry or particles), you can iterate over the metaballs which affect
a point in space.

> forpoints ( position [, distance] ) {
> 
> }

...where the position is a vector representing a point in space. The
statement will be executed once for each metaball/particle at the
position passed in.

If you specify the distance, all metaballs/particles within the distance
of the point specified will be iterated through. The distance parameter
is optional and may result in slower execution of the shader.

Inside the loop, you can call the mdensity and mattrib functions to
query the contribution of the current point instead of getting a
"blended" value.

For example, the following code will take the point color of the
metaball which contributes the maximum weight to the point in space:

> float d = 0, max = 0;
> vector clr = 0;
> vector blended_color;
> 
> forpoints ( P ) {
>     d = mdensity(P);
>     if (d > max) {
>         clr = mattrib("Cd", P);
>         max = d;
>     }
>     blended_color = d * clr;
> }

Note that when you call mattrib inside a forpoints loop, the attribute
is not pre-blended by the density of the metaball.

{
frac

Returns the fractional component of the floating point number.

USAGES
  float frac(float n)
  <vector> frac(<vector> v)
  Returns the fractional component of the floating point number. For
  example, frac(1.5) would return 0.5. For vectors, this done per-
  component.

RELATED

}

{
fresnel

Computes the fresnel reflection/refraction contributions given an
incoming vector, surface normal (both normalized), and an index of
refraction (eta).

USAGES
  void fresnel(vector i, vector n, float eta, float &kr, float &kt)
  void fresnel(vector i, vector n, float eta, float &kr, float &kt,
  vector &R, vector &T)

Computes the fresnel reflection/refraction contributions given an
incoming vector, surface normal (both normalized), and an index of
refraction (eta). The amount of reflected light will be returned in
<kr>, and the amount of transmitted light will be returned in <kt>.
Optionally, the reflection and transmission vectors can be returned in
the <R> and <T> variables. The R and <type> variables will be normalized
vectors on exit.

<eta> is a relative index of refraction, the ratio between the interior
and exterior index of refraction, where the exterior is defined by the
direction of the normals (normals point away from the interior).

RELATED

  * refract

}

{
fromNDC

Transforms a position from normal device coordinates to the coordinates
in the appropriate space.

USAGES
  vector fromNDC(vector v)
  Transforms the vector from NDC space to the current space.

  vector fromNDC(string space, vector v)
  Transforms the vector from NDC space to the named space.


space
    The possible values for the space arguments are:

    An object path

    Use the object space of an object specified by a path string.


    TIP
        In some cases, such as point instancing, mantra may
        automatically mangle object paths. You can generate an .ifd file
        and look inside to try to find what mantra is calling the object
        you want.

    "space:object"

    Object space of the _current_ object.

    "space:light"

    Object space of the _current_ light when executing a shadow or light
    shader.

    "space:world"

    Houdini world space.

    "space:camera"

    mantra camera space.

    "space:ndc"

    Normal Device Coordinate space.

    "space:lightndc"

    Normal Device Coordinate space for the _current_ light when
    executing a shadow or light shader.

    "space:current"

    The current space the vector is in.

    "space:world"

    Houdini world space.


WARNING
    NDC space is only well-defined for the Displacement, Surface, and
    Light contexts.

RELATED

}

{
frontface

If dot(I, Nref) is less than zero, N will be negated.

USAGE
  vector frontface(vector N, vector I)

This form (which doesn't take a reference vector) is only available in
the shading contexts, where the <Ng> variable is used.

USAGE
  vector frontface(vector N, vector I, vector Nref)

If dot(I, Nref) is less than zero, N will be negated.

RELATED

}

{
fuzzify

USAGE
  float fuzzify(string ramp_basis[]; float ramp_values[]; float
  ramp_positions[]; float crisp_value; float min_value; float max_value)

Converts a crisp value to a fuzzy value based on an input membership
function.

RELATED

}

{
fuzzy_and

USAGES
  int fuzzy_and(int a, int b, ...)
  float fuzzy_and(float a, float b, ...)
  Returns the fuzzy "AND" (Zadeh AND) of the input fuzzy values.

RELATED

  * fuzzy_nand

  * fuzzy_not

  * fuzzy_or

  * fuzzy_nor

  * fuzzy_xor

  * fuzzy_nxor

}

{
fuzzy_defuzz_centroid

USAGE
  float fuzzy_defuzz_centroid(const float aggregated_membership[]; const
  float min_value; const float max_value)

Returns a crisp value given a range for the crisp value, and an
aggregated membership function for the output variable.

RELATED

}

{
fuzzy_nand

USAGES
  int fuzzy_nand(int a, int b, ...)
  float fuzzy_nand(float a, float b, ...)
  Returns the fuzzy "NAND" (Zadeh NAND) of the input fuzzy values.

RELATED

  * fuzzy_and

  * fuzzy_not

  * fuzzy_or

  * fuzzy_nor

  * fuzzy_xor

  * fuzzy_nxor

}

{
fuzzy_nor

USAGES
  int fuzzy_nor(int a, int b, ...)
  float fuzzy_nor(float a, float b, ...)
  Returns the fuzzy "NOR" (Zadeh NOR) of the input fuzzy values.

RELATED

  * fuzzy_and

  * fuzzy_nand

  * fuzzy_not

  * fuzzy_or

  * fuzzy_xor

  * fuzzy_nxor

}

{
fuzzy_not

USAGES
  int fuzzy_not(int n)
  float fuzzy_not(float n)
  Returns the fuzzy "NOT" (Zadeh NOT) of the input fuzzy value.

RELATED

  * fuzzy_and

  * fuzzy_nand

  * fuzzy_or

  * fuzzy_nor

  * fuzzy_xor

  * fuzzy_nxor

}

{
fuzzy_nxor

USAGES
  int fuzzy_nxor(int a, int b, ...)
  float fuzzy_nxor(float a, float b, ...)
  Returns the fuzzy "NXOR" (Zadeh NXOR) of the input fuzzy values.

RELATED

  * fuzzy_and

  * fuzzy_nand

  * fuzzy_not

  * fuzzy_or

  * fuzzy_nor

  * fuzzy_xor

}

{
fuzzy_or

USAGES
  int fuzzy_or(int a, int b, ...)
  float fuzzy_or(float a, float b, ...)
  Returns the fuzzy "OR" (Zadeh OR) of the input fuzzy values.

RELATED

  * fuzzy_and

  * fuzzy_nand

  * fuzzy_not

  * fuzzy_nor

  * fuzzy_xor

  * fuzzy_nxor

}

{
fuzzy_xor

USAGES
  int fuzzy_xor(int a, int b, ...)
  float fuzzy_xor(float a, float b, ...)
  Returns the fuzzy "XOR" (Zadeh XOR) of the input fuzzy values.

RELATED

  * fuzzy_and

  * fuzzy_nand

  * fuzzy_not

  * fuzzy_or

  * fuzzy_nor

  * fuzzy_nxor

}

gather

Sends rays into the scene and returns information from the shaders of
surfaces hit by the rays.

You can use VEX's gather loop statement to send rays into the scene and
gather the resulting information.

> gather(vector origin, vector direction, ...)
> {
>     // Statements for rays that hit other surfaces
> } else {
>     // Statements for rays which didn't hit any surface
> }

After the <origin> and <direction> arguments, any additional arguments
are interpreted as keyword/value pairs.

> gather(origin, dir, "samples", 100) {
>     ...
> }

NOTE
    If you specify 0 samples, it will still take at least 1 sample.

LIGHT INCLUSION/EXCLUSION OPTIONS


    categories
        Specifies lights to include/exclude by their "category" tags.
        This is the preferred include/exclude lights rather than pattern
        matching light names with the "lightmask" keyword argument.

        For example:

      > diff = diffuse(nml, "lightmask", "hero | fill");

        See light categories for more information.

    lightmask
        When evaluating light and shadow shaders, objects have pre-
        defined light masks. This mask is usually specified in the
        geometry object and specifies a list of lights which are used to
        illuminate a surface or fog shader. It is possible to override
        the default light mask by specifying a "lightmask" argument.

        For example:

      > diff = diffuse(nml, "lightmask", "light*,^light2");

        ...will cause all lights whose names begin with "light" except
        for a light named "light2" to be considered for diffuse
        illumination.

        All Houdini scoping patterns, excepting group expansion, are
        supported:

      * * - wild-card match

      * ? - single character match

      * ^ - exclusion operator

      * [list] - character list match

RAY OPTIONS


    TIP
        When you specify a texture, such as with the "environment"
        keyword, you can also use the image filtering keyword arguments.
        See environment for a listing of the image filter keyword
        arguments.


    scope
        A list of objects which can be hit by the rays. When specified,
        scope overrides the default scope that would have been selected
        for the given raystyle. The "scope:default" value will cause the
        scope argument to use the default scope for the current context
        - as if the argument were not specified.

        Allows an override of the scope for ray-intersections. A special
        scope argument, scope:self, will match the currently shading
        object.

    maxdist
        The maximum distance to search for objects. This can be used to
        limit the search of objects to nearby objects only. If the
        maxdist given is negative, then it will act as if there is no
        maximum distance.

        Allows an override of the maximum distance the ray can travel
        when testing for intersections. Some functions (such as
        fastshadow) have the maximum distance implicitly defined (by the
        length of the ray) and should probably avoid using this option.
        However, this option can be used effectively when computing
        reflections, global illumination, refraction etc.

    variancevar
        The name of a VEX export variable to use for variance anti-
        aliasing. The renderer compares the value with adjacent
        micropolygons in micropolygon rendering to decide what shading
        points need additional samples (using vm_variance property as a
        threshold). If more samples are required, the algorithm takes
        samples up to the specified maximum ray samples.

        This variable must be imported from the hit surface, so it must
        be in the list of imported names (see "importing information
        back from the ray" below). If the named variable is not
        imported, this option will be ignored.

        Variance antialiasing puts more samples in areas of the image
        with high variance, for example a sharp shadow edge. It is only
        used when vm_dorayvariance is enabled. Otherwise, only the min
        ray samples (or an explicitly supplied "samples" value) are used
        for antialiasing of the gather loop.

        Overrides the global variance control (mantra's -v option) which
        is used to determine anti-aliasing quality of ray tracing. For
        more information please refer to the documentation on mantra.

    angle
        The distribution angle (specified in radians). For gather(),
        rays will be distributed over this angle. For trace(), the angle
        is used to indicate the rate at which the filter width should
        increase with increasing intersection distance. Larger angles
        will cause farther hit surfaces to use larger derivatives,
        leading to improved texturing and displacement performance.

        To be effective, the samples parameter should also be specified.

    samples
        How many samples should be sent out to filter rays. For the
        irradiance and occlusion functions, specifying a samples
        parameter will override the default irradiance sampling.

    environment
        If the ray sent out to the scene misses everything, then it's
        possible to specify an environment map to evaluate.

        Using the ray's direction, the environment map specified will be
        evaluated and the resulting color will be returned. Most likely,
        it will be necessary to specify a transform space for the
        environment map evaluations.

        In the case of refractlight and trace the Of and Af variables
        will be set to 0 regardless of the background color specified.
        the resulting color.

        When an environment map is specified, the filtering options from
        texture() are also supported.

        See how to create an environment/reflection map.

    envobject
        If an environment map is used, the orientation of the
        environment map can be specified by transforming the ray into
        the space of another object, light or fog object in the scene.
        In Houdini, null objects can be used to specify the orientation.
        For example:

      > Cf = R*reflectlight(bias, max(R), "environment", "map.rat", "envobject", "null_object_name");

    envlight
        If an environment map is used, the orientation of the
        environment map can be specified by transforming the ray into
        the space of a light in the scene.

    envtint
        If an environment map is used, tint it with this color.

    background
        If a ray misses all objects, use this as the background color of
        the scene. In the case of refractlight and trace the Of and Af
        variables will be set to 0 regardless of the background color
        specified.

    distribution
        *Functions*: irradiance, occlusion

        Distribution for computing irradiance. The default is to use a
        cosine distribution (diffuse illumination). The possible values
        for the style are "nonweighted" for uniform sampling or "cosine"
        for cosine weighted sampling.

RAY SENDING OPTIONS


    width
        Specifies the filter width at the source of the ray. If angle is
        also specified, the filter width will become larger with
        increasing distance along the ray. By default, the filter width
        will be initialized from the current shading context, so it's
        normally not necessary to specify width directly. Negative
        values are ignored and will also cause the filter width to be
        initialized from the current shading context.

    distribution
        Determines the sampling distribution.

        For gather:

      * cosine -- Rays are distributed by the cosine (diffuse) function
        over the hemisphere.

      * uniform -- Rays are distributed uniformly over the hemisphere

        For sample_geometry:

      * area -- Samples are distributed by primitive area

      * parametric -- Samples are distributed by primitive ID,
        subdivision ID, and parametric surface coordinates (s, t).

      * solidangle -- Samples are distributed either by primitive area
        or by primitive area and solid angle subtended by the primitive.

    biasdir
        Overrides the bias direction when Bias Along Normal is enabled.
        When no biasdir is specified, the geometric normal Ng is used.
        When bias along normal is disabled, this option has no effect.

    SID
        Sample identifier to be passed to the called shader. If the
        calling shader has used SID to generate samples, it can be
        useful to pass the modified sample identifier to the called
        shader so that it can begin sampling at the specified offset.
        This value will be used to initialize the SID global in the hit
        surface.

    rayweight
        A hint to mantra to indicate the relative contribution of this
        ray to the final shading. This value is used by the ray clip
        threshold to limit sending of rays (similar to ray bounce).

    raystyle
        The type of rays you are sending. Mantra will use raystyle to
        determine both the default raytracing mask and bounce limit used
        for ray termination.

      * reflect -- Sending reflection rays. Mantra will use the
        reflection mask and reflection limit to terminate raytracing.

      * refract -- (default) Sending refraction rays. Mantra will use
        the refraction mask and refraction limit to terminate
        raytracing.

      * diffuse -- Sending diffuse rays. Mantra will use the diffuse
        limit for diffuse rays.

      * shadow -- Sending shadow rays. Mantra will not modify the
        raytracing level and will trace against shadowmask if inside a
        shadow or light shader.

      * primary -- Sending primary rays. This style can be used when a
        shader needs to change the direction of a primary ray without
        affecting the behavior of render settings that apply only to
        directly visible objects (such as matte and phantom). Mantra
        will still increment the raytracing level when sending primary
        rays.

      * nolimit -- Sending reflection rays with no limit on the number
        of raytracing bounces. Mantra will still increment the
        raytracing level when sending nolimit rays.

    categories
        A category expression used to select the objects which can be
        hit by rays. When specified, this overrides the existing
        reflectcategories and refractcategories parameters.

        For example, ^hidden will hit all objects which do not have the
        hidden category, and shiny|happy will hit all objects with
        either the shiny or happy category.

        The intersection of the scope and categories parameters are used
        to choose the objects which can be hit by rays.

    samplebase
        Typically, rays are distributed over the surface of the micro-
        polygon being shaded. This argument can be used to control the
        area. A value of 0 will force all rays to be sent from the same
        point. A value of 1 will cover the entire micro-polygon. (Gather
        only)

    transparentsamples
        The number of transparent samples to take for stochastic
        transparency with array outputs. Normally this value should be
        set to 1 unless you have requested exports in array variables -
        in which case the ray tracer will insert an entry in the array
        for each sample along the ray.


        NOTE
            transparentsamples must be 1 when importing F or
            ray:material using screendoor samplefilter.

SENDING INFORMATION TO THE SURFACE'S SHADER

    Using a keyword in the form "send:<name>", value, you can pass data
    from the originating surface to surfaces which are intersected by
    the ray. These arguments pass any values you want.

  > gather(P, dir, "send:N", normalize(N)) { ... }

    You can extract this passed data on the receiving end (that is, in
    the surface being hit by the ray) with the rayimport function. The
    first argument is the name (without the send: prefix) and the second
    argument is a variable in which to store the imported value.

    int rayimport(string name, <type> &value)

    rayimport returns 1 if the value was imported successfully.

IMPORTING INFORMATION FROM THE RAY

    You can specify names of global or exported variables to import from
    the hit shader in the form "<varname>", &var, typically including Cf
    (color vector of surface hit) and Of (opacity vector of surface
    hit).

  > vector  hitcf;
  > gather(P, dir, "bias", 0.01, "Cf", hitcf) {...}

    In addition, you can import the following special keywords to get
    information about the ray itself:


    ray:origin
        The origin of the ray (defined in else clause also).

    ray:direction
        The direction of the ray (defined in else clause also).

    ray:length
        The distance to the first surface which was hit by the ray.

    ray:area
        The total surface area of all the geometry in the raytracing
        scope.

    ray:solidangle
        The estimated solid angle subtended by all geometry in the
        raytracing scope. For large objects close to or enclosing the
        ray origin, this may be a very poor estimate while for
        individual primitives the estimate can be very good.

    You can retrieve information about more than one hit along the ray
    by requesting data in an array variable. When an imported value is
    of an array type, the trace function will automatically append an
    entry in the array for each individual hit point that was composited
    during ray tracing. For the opacity sample filter (see below), an
    entry will be created in the array for each semi-transparent sample
    encountered until full opacity is reached. When using array outputs,
    it may also be useful to use the all sample filter, which will cause
    all hits along the ray to be inserted regardless of whether the
    opacity limit was exceeded.

  > // Find the position and normal for all hit points along the ray,
  > // regardless of visibility.
  > vector a_pos[];
  > vector a_nml[];
  > trace(P, dir, Time,
  >         "samplefilter", "all",
  >             "P", a_pos,
  >             "N", a_nml);

SAMPLE FILTERING OPTIONS

    By default, Houdini composites the global variables using opacity
    blending. In some cases, it's more useful to get the value from the
    closest surface (regardless of whether it's transparent). You can
    use the special samplefilter keyword with a string value of either
    closest or opacity to control whether the value of a global is from
    the closest surface or opacity blended.


    samplefilter
        When the samplefilter keyword is encountered in the argument
        list, _all following_ import variables will use the specified
        filtering mode. You can specify multiple samplefilter arguments
        in a single gather statement to filter different variables in
        different ways.

        The current types of allowed for samplefilter are


        minimum
            Take the minimum value of all the samples. Note that with
            tuple values, the minimum value of each component will be
            used.

        maximum
            Take the maximum value of all the samples. Note that with
            tuple values, the maximum value of each component will be
            used.

        opacity
            Composite samples using the over operation.

        closest
            This is the default behavior, returning only the closest
            surface.

        screendoor
            Use stochastic compositing of the samples.

        sum
            Return the sum of the values for all samples.

        sum_square
            Return the sum of the squares of the values of all samples.

        sum_reciprocal
            Return the sum of the reciprocals of each sample.


    NOTE
        When using sample_geometry, the default samplefilter is set to
        closest by default, since opacity blending only works when
        compositing data along a ray.

  > gather(P, dir,
  >         "samplefilter", "opacity",
  >             "Cf", hitCf,
  >             "Of", hitOf,
  >         "samplefilter", "closest",
  >             "P", hitP,
  >             "N", hitN)
  > {
  >     trace(pos, dir, time,
  >             // Composite the bsdf of the hit surfaces using stochastic transparency
  >             "samplefilter", "screendoor",
  >             "F", hitF,
  >             // But find the closest sample's position
  >             "samplefilter", "closest",
  >             "P", hitP);
  > }

PIPELINE OPTIONS


    pipeline
        As you specify variables, you can intersperse pipeline keyword
        options to control where in the pipeline to fill out read/write
        variables. The value can be one of surface, atmosphere, or
        displacement. You can specify the pipeline option multiple
        times. Each use of the option affects any variables specified
        after it (up to the next usage of pipeline if any).

      > gather(p, d, "pipeline", "surface", "Cf", surfCf,
      >              "pipeline", "atmosphere" "Cf", fogCf, "P", hitP)

EXAMPLES

    Here are two shaders which communicate through gather.

    This shader sends rays into the scene. It sends 1.234 in a message
    labeled exportvalue. Since the surface hit by the rays may not have
    an exported parameter called amp, it's important to initialize this
    variable before the gather loop.

  > surface
  > sendray(vector background=0; int nsamples=16)
  > {
  >     float   amp;
  > 
  >     amp = 0;
  >     Cf = 0;
  > 
  >     gather(P, N,
  >         "bias", 0.01,
  >         "angle", radians(15),
  >         "samples", nsamples,
  >         "samplebase", 1,
  >         "distribution", "cosine",
  >         "send:exportvalue", 0.8,
  >         "amp", amp)
  >     {
  >         Cf += amp;
  >         amp = 0;
  >     }
  >     else
  >     {
  >         Cf += background;
  >     }
  > 
  >     Cf *= 1.0 / nsamples;
  >     Of = 1;
  > }

    The following shader imports values which were sent to it by the
    gather loop. The exported parameter can be imported by the gather
    loop.

  > surface
  > hitsurf(export float amp=1)
  > {
  >     float   sendvalue = 0;
  > 
  >     if (!rayimport("exportvalue", sendvalue))
  >         printf("Error importing the send:exportvalue\n");
  > 
  >     amp = sendvalue;
  > 
  >     Cf = 1;
  >     Of = 1;
  > }

RELATED

  * rayimport

  * illuminance

  * reflectlight

  * refractlight

  * trace

  * irradiance

{
geoself

Returns a handle to the current geometry.

USAGE
  int geoself()

Returns a handle to the current geometry, suitable for the geometry
creation operations.

RELATED

}

{
geounwrap

Returns an oppath: string to unwrap the geometry in-place.

USAGE
  string geounwrap( <geometry>, string unwrap_attribute)

Returns an oppath string that will cause the file or geometry to be
unwrapped inplace based on a vector attribute. This function adds an
"unwrap:attrname" prefix followed by the <unwrap_attribute> to the
<path>. <path> can be a filename, an oppath with the "op:" prefix or an
opinput. An <input> index can be supplied instead of a string.

Adding an "unwrap:attrname" prefix to an oppath will create a copy of
the geometry and overwrite the point positions based on the unwrap
attribute. The topology can change, if the attribute is a vertex
attribute.

This then enables all the vex functions working on the point positions
to work in a custom space such as UV space or Color space.

RELATED

  * intersect

  * uvdist

  * uvintersect

  * uvsample

  * xyzdist

}

{
getattrib

Reads an attribute value from geometry, with validity check.

USAGES
  <type> getattrib(<geometry>, string attribclass, string
  attribute_name, int elemnum, int &success)
  <type>[] getattrib(<geometry>, string attribclass, string
  attribute_name, int elemnum, int &success)
  This general form lets you specify the attribute "class" at run-time.
  This can be useful for writing general code that can work on different
  classes. If you know the class of attribute you want to read ahead of
  time, using detailattrib, primattrib, pointattrib, or vertexattrib may
  be faster.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

texttype
    One of "detail" (or "global"), "point", "prim", or "vertex".

    You can also use "primgroup", "pointgroup" or "vertexgroup" to read
    from groups.

texttype
    The name of the attribute (or intrinsic) to read.

texttype
    The point/primitive/vertex number to read the attribute value from.
    For detail attributes, use 0 here (the argument is ignored for
    detail attributes).

    To get the linear vertex number given a primitive number and the
    vertex number on the primitive, use the primvertex function.

success
    If the given attribute exists and can be read, the function sets
    this variable to 1. Otherwise, it sets this variable to 0.

    The value of the attribute.

RELATED

}

{
getattribute

Copies the value of a geometry attribute into a variable and returns a
success flag.

USAGES
  int getattribute(string geometry, <type> &value, string attribclass,
  string attribute_name, int element_number, int vertex_number)
  int getattribute(string geometry, <type> &value[], string attribclass,
  string attribute_name, int element_number, int vertex_number)


WARNING
    This function does not allow reading from inputs in a node context,
    and is harder to use than the other attribute functions. You
    probably want to use one of the other attribute functions instead,
    such as getattrib.

Returns 0 if the attribute does not exist or cannot be read, 1 on
success. If the function returns 0 (failed), the given variable may
remain uninitialized.


value
    The variable to overwrite with the attribute value.

texttype
    One of "detail" (or "global"), "point", "prim", or "vertex".

    You can also use "primgroup", "pointgroup" or "vertexgroup" to read
    from groups.

texttype
    The name of the attribute (or intrinsic) to read.

element_number
    The point or primitive number. If you are reading a detail
    attribute, use 0 here.

vertex_number
  * When reading a vertex attribute, you can specify the primitive
    number in the element_number argument and the primitive's vertex
    number here.

  * To use a linear vertex index, use -1 as the element_number and the
    vertex index here.

  * If you are not reading a vertex attribute, this argument is ignored.

EXAMPLES

  > 
  > vector pos, uv, clr;
  > // Get the position of point 3 in "defgeo.bgeo"
  > getattribute("defgeo.bgeo", pos, "point", "P", 3, 0);
  > 
  > // Get the value of the "uv" attribute for vertex 2 of primitive
  > // number 3 in the file defgeo.bgeo
  > getattribute("defgeo.bgeo", uv, "vertex", "uv", 3, 2);
  > 
  > // Get the value of the "Cd" attribute for primitive 7
  > // in the SOP specified by the path "/obj/geo1/color1" (Houdini
  > // only)
  > getattribute("op:/obj/geo1/color1", clr, "primitive", "Cd", 7);

RELATED

  * getattrib

  * detailattrib

  * primattrib

  * pointattrib

  * vertexattrib

}

{
getbbox

Sets two vectors to the minimum and maximum corners of the bounding box
for the geometry.

USAGES
  void getbbox(<geometry>, vector &min, vector &max)
  Sets the vectors to the minimum and maximum corners of the bounding
  box for the geometry. This outputs the primitive bounding box, which
  includes the extents of spheres and volumes.

  void getbbox(<geometry>, string primgroup, vector &min, vector &max)
  Outputs the bounding box of the primitive in the given group. An empty
  <primgroup> string will include all primitives. The string supports
  Ad-hoc patterns like 0-10 and @Cd.x>0.

  void getbbox(vector &min, vector &max)

  WARNING
      This form of getbbox is deprecated and may be removed in the
      future. Use the other forms as needed.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

RELATED

  * getbbox_center

  * getbbox_max

  * getbbox_min

  * getbbox_size

  * getpointbbox

}

{
getbbox_center

Returns the center of the bounding box for the geometry.

USAGES
  vector getbbox_center(<geometry>)
  Computes the center of the bounding box for the geometry.

  vector getbbox_center(<geometry>, string primgroup)
  Computes the center of the bounding box of the primitives in the given
  group.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

RELATED

  * getbbox

  * getbbox_center

  * getbbox_size

  * getbbox_min

  * getbbox_max

  * getpointbbox

}

{
getbbox_max

Returns the maximum of the bounding box for the geometry.

USAGES
  vector getbbox_max(<geometry>)
  Computes the maximum of the bounding box for the geometry.

  vector getbbox_max(<geometry>, string primgroup)
  Computes the maximum of the bounding box of the primitives in the
  given group.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

RELATED

  * getbbox

  * getbbox_center

  * getbbox_size

  * getbbox_min

  * getbbox_max

  * getpointbbox

}

{
getbbox_min

Returns the minimum of the bounding box for the geometry.

USAGES
  vector getbbox_min(<geometry>)
  Computes the minimum of the bounding box for the geometry.

  vector getbbox_min(<geometry>, string primgroup)
  Computes the minimum of the bounding box of the primitives in the
  given group.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

RELATED

  * getbbox

  * getbbox_center

  * getbbox_size

  * getbbox_min

  * getbbox_max

  * getpointbbox

}

{
getbbox_size

Returns the size of the bounding box for the geometry.

USAGES
  vector getbbox_size(<geometry>)
  Computes the size of the bounding box for the geometry.

  vector getbbox_size(<geometry>, string primgroup)
  Computes the size of the bounding box of the primitives in the given
  group.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

RELATED

  * getbbox

  * getbbox_center

  * getbbox_size

  * getbbox_min

  * getbbox_max

  * getpointbbox

}

{
getblurP

Returns the blurred point position (P) vector at a fractional time
within the motion blur exposure.

USAGE
  vector getblurP(float <delta>)

Returns the position (P) of the current shading point at fractional time
<delta> within the motion blur exposure. When motion blur is disabled,
getblurP() will always return the shading position P. When motion blur
is enabled, getblurP(0) and getblurP(1) will return the positions at the
extent of the shading position's motion path, with fractional values
between 0 and 1 generating other intermediate shading positions. For
example, getblurP(0.5) returns the point's blurred position half-way
through the current exposure.

When shading micropolygons, P will always store the initial position of
the point (at time = 0). For raytracing, P will store the final position
after motion transformation for the sample being shaded - at the time
given by the Time global variable in the VEX shading context. If you
want to determine the shading position at other times it is necessary to
use getblurP.

When using point clouds that were generated at time = 0, you should use
getblurP(0) to find the position at the start of the frame's exposure
and then use this position to look up in the point cloud.

For example:

> vector p0 = getblurP(0);
> int handle = pcopen("pcloud.pc", p0, ...);

RELATED

}

{
getbounces

USAGE
  int getbounces(bsdf b)

Returns the bounce mask for the specified bsdf.

See bouncemask for information on component label bitmasks.

RELATED

  * nbouncetypes

}

{
getbounds

Returns the bounding box of the geometry specified by the filename.

USAGES
  int getbounds(string filename, vector &min, vector &max)
  int getbounds(string filename, string group, vector &min, vector &max)

Returns the bounding box of the geometry specified by the filename. The
point corresponding to the minimum corner of the bounding box will be
returned in <min>, while the maximum will be in <max>. Always returns 1.

If a group is specified, only primitives in that group will be used. The
group field's behavior matches that in SOPs. An empty string will
include all primitives. Ad-hoc patterns like 0-10 and @Cd.x>0 are also
valid.

The getbbox() function should likely be used instead.

RELATED

}

{
getcomp

Extracts a single component of a vector type, matrix type, or array.

USAGES
  float getcomp(<vector> v; int index)
  Returns the vector component at the given index. This is the same as
  v[index].

  float getcomp(<matrix> m; int row, int column)
  Returns the matrix component at the given location.

  <type> getcomp(<type> array[]; int index)
  Returns the array item at the given index. This is the same as
  array[index].

  string getcomp(string value, int index)
  Returns the _character_ at the given index. This is the same as
  value[index].

RELATED

  * Arrays

  * setcomp

}

{
getcomponents

USAGE
  string[] getcomponents()

Returns an array of strings containing the components specified by the
rendering property.

RELATED


}

{
getderiv

Evaluates surface derivatives of an attribute.

USAGES
  void getderiv(float attr, string attrName, int isVertexAttr, float s,
  float t, float &du, float &dv, ...)
  void getderiv(<vector> attr, string attrName, int isVertexAttr, float
  s, float t, <vector> &du, <vector> &dv, ...)


NOTE
    If derivatives are queried for a polygonal mesh it is interally
    sampled as a Subdivision Surface.


attr
    Attribute value.

attrName
    Name of attribute to evaluate.

isVertexAttr
    Set to 1 to indicate the attribute is a vertex type.

s
    Parametric S shading value. This should be passed from the s global
    variable.

t
    Parametric <type> shading value. This should be passed from the t
    global variable.

du
    Derivative of attribute in U direction.

dv
    Derivative of attribute in V direction.

DERIVATIVES OPTIONS

    Functions which compute derivatives take additional arguments to
    allow tuning of the derivative computation.


    extrapolate
        Whether derivatives are "smooth" across patch boundaries. In
        most cases this is true and if extrapolation is turned on,
        derivative computation should be exact for C2 surfaces. However,
        when the VEX variables are changing with a high frequency (for
        example, a high frequency displacement map causing high
        frequency changes to the P variable), extrapolation of
        derivative computation may cause exaggeration of discontinuities
        between patch boundaries.

    smooth
        Adjust the magnitude of the differentials non-uniformly over
        patches. This will usually reduce patch discontinuities in
        displacement/textured shaders. However, in some odd cases you
        may want to turn this feature off.

  > N = computenormal(P, "extrapolate", 1, "smooth", 0);

EXAMPLES

  > // Get derivatives of point attribute 'N'
  > vector dNdu, dNdv;
  > getderiv(N, "N", 0, s, t, dNdu, dNdv);

RELATED

  * Du

  * Dv

}

{
getfogname

Returns the name of the current object whose shader is being run.

USAGE
  string getfogname()

Returns the name of the current fog object whose shader is being run, or
the empty string if there is no current fog object.

RELATED

}

{
getglobalraylevel

Returns the depth of the ray tree for computing global illumination.

USAGE
  int getglobalraylevel()

Returns the depth of the ray tree for computing global illumination. If
this function returns a non-zero value, the shader is being called for
the purpose of evaluating global illumination.

RELATED

}

{
getgroupid

Returns group id containing current primitive.

USAGE
  int getgroupid()

Returns the id of a primitive group containing the current face being
shaded. The id is the index of the group in the detail. If the primitive
belongs to several groups, their indices are added up to calculate the
returned id.

RELATED

}

{
getlight

Returns a light struct for the specified light identifier.

USAGE
  light getlight(int lid)

Given a integer light identifier (lid), you can get a reference to a
light object representing the light (see details on the mantra specific
type)

> int[] lights = getlights();
> int nlights = len(lights);
> for (int i = 0; i < nlights; i++)
> {
> light lp = getlight(i);
> lp->illuminate(...);
> }

RELATED

  * getlights

  * getlightname

  * lightid

  * lightbounces

}

{
getlightid

Returns the light id for a named light (or -1 for an invalid name).

USAGE
  int getlightid(string lightname)

Returns the integer light identifier of the light referred to by the
given name.

RELATED

  * getlights

  * getlightname

}

{
getlightname

Returns the name of the current light when called from within an
illuminance loop, or converts an integer light ID into the light's name.

USAGE
  string getlightname()

Returns the name of the current light when called from within an
illuminance loop or when a current light has been set using
setcurrentlight.

USAGE
  string getlightname(int lightid)

Returns the name of the light referred to by the given integer light ID.
Integer light IDs are used by some low-level VEX functions instead of
strings for efficiency.

RELATED

  * illuminance

  * getlights

  * getphotonlight

  * intersect_lights

}

{
getlights

Returns an array of light identifiers for the currently shaded surface.

USAGES
  int[] getlights(...)
  int[] getlights(vector P, ...)

  categories
      Specifies lights to include/exclude by their "category" tags. This
      is the preferred include/exclude lights rather than pattern
      matching light names with the "lightmask" keyword argument.

      For example:

    > diff = diffuse(nml, "lightmask", "hero | fill");

      See light categories for more information.

  lightmask
      When evaluating light and shadow shaders, objects have pre-defined
      light masks. This mask is usually specified in the geometry object
      and specifies a list of lights which are used to illuminate a
      surface or fog shader. It is possible to override the default
      light mask by specifying a "lightmask" argument.

      For example:

    > diff = diffuse(nml, "lightmask", "light*,^light2");

      ...will cause all lights whose names begin with "light" except for
      a light named "light2" to be considered for diffuse illumination.

      All Houdini scoping patterns, excepting group expansion, are
      supported:

    * * - wild-card match

    * ? - single character match

    * ^ - exclusion operator

    * [list] - character list match

  int[] getlights(material mat; vector P; ...)
  With this signature, the light mask is determined solely by the
  material (the lightmask and categories keyword parameters are
  ignored).

  This version also accepts PBR keyword arguments to limit lights based
  on their Light Contribution parameter.


  label
      A specific label. This keyword argument may be specified multiple
      times.

  direct
      0 = limit lights to indirect contributions, 1 = limit lights to
      direct contributions.

EXAMPLES

  > getlights("lightmask", "light*,^light2");
  > getlights("categories", "shadow|occlusion");
  > getlights(material(), P, "direct", 0);

RELATED

  * getphotonlight

  * importance_light()

  * sample_light

  * intersect_lights

  * getlightname

  * haslight

}

{
getlightscope

Returns a selection of lights that illuminate a given material.

USAGE
  void getlightscope(material mat, string &scope, string &categories)

Given a material handle, determine the lights illuminating the surface.
The light selection is given by the scope/categories returned.

RELATED

  * getmaterial

  * getscope

  * trace

}

{
getlocalcurvature

Evaluates local curvature of primitive grid, using the same curvature
evaluation method as Measure SOPs.

USAGE
  vector getlocalcurvature(float s, float t)

Returns 0 vector if the object does not have subdivision enabled, or has
no displacement shader assigned. Otherwise, the measured convexity and
concavity will be returned in x and y components respectively.


s
    Parametric S shading value. This should be passed from the s global
    variable.

t
    Parametric <type> shading value. This should be passed from the t
    global variable.

RELATED

}

{
getmaterial

Returns a material struct for the current surface.

USAGE
  material getmaterial()

The material handle returned is opaque, but can be used by other
functions to query information about the material (see details on the
mantra specific type).

RELATED

  * getlights

  * getlightscope

  * getscope

  * haslight

  * renderstate

}

{
getmaterialid

Returns material id of shaded primitive.

USAGE
  int getmaterialid()

Returns the material id of the primitive being shaded. The id
corresponds to the material being evaluated and accounts for overrides
from style sheets and detail assignments.

RELATED

}

{
getobjectid

Returns the object id for the current shading context.

USAGE
  int getobjectid()

Returns the object id.

RELATED

}

{
getobjectname

Returns the name of the current object whose shader is being run.

USAGE
  string getobjectname()

Returns the name of the current object whose shader is being run, or the
empty string if there is no current object.

RELATED

}

{
getphotonlight

Returns the integer ID of the light being used for photon shading.

USAGE
  int getphotonlight()

Returns -1 if the shader is not generating photons from a light.

The return value is an integer identifying a light. You can get convert
this integer ID to the light name with getlightname

RELATED

  * getlights

  * getlightname

}

{
getpointbbox

Sets two vectors to the minimum and maximum corners of the bounding box
for the geometry.

USAGES
  void getpointbbox(<geometry>, vector &min, vector &max)
  void getpointbbox(<geometry>, string pointgroup, vector &min, vector
  &max)
  This is the same as getbbox except it only computes the bounding box
  of the _points_. So if a primitive has extents that don't have points
  (for example, the boundary of a primitive sphere), they will not be
  included in the box.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

RELATED

}

{
getpointbbox_center

Returns the center of the bounding box for the geometry.

USAGES
  vector getpointbbox_center(<geometry>)
  vector getpointbbox_center(<geometry>, string pointgroup)
  This is the same as getbbox_center except it only computes the
  bounding box of the _points_. So if a primitive has extents that don't
  have points (for example, the boundary of a primitive sphere), they
  will not be included in the box.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

RELATED

}

{
getpointbbox_max

Returns the maximum of the bounding box for the geometry.

USAGES
  vector getpointbbox_max(<geometry>)
  vector getpointbbox_max(<geometry>, string pointgroup)
  This is the same as getbbox_max except it only computes the bounding
  box of the _points_. So if a primitive has extents that don't have
  points (for example, the boundary of a primitive sphere), they will
  not be included in the box.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

RELATED

}

{
getpointbbox_min

Returns the minimum of the bounding box for the geometry.

USAGES
  vector getpointbbox_min(<geometry>)
  vector getpointbbox_min(<geometry>, string pointgroup)
  This is the same as getbbox_min except it only computes the bounding
  box of the _points_. So if a primitive has extents that don't have
  points (for example, the boundary of a primitive sphere), they will
  not be included in the box.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

RELATED

}

{
getpointbbox_size

Returns the size of the bounding box for the geometry.

USAGES
  vector getpointbbox_size(<geometry>)
  vector getpointbbox_size(<geometry>, string pointgroup)
  This is the same as getbbox_size except it only computes the bounding
  box of the _points_. So if a primitive has extents that don't have
  points (for example, the boundary of a primitive sphere), they will
  not be included in the box.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

RELATED

}

{
getprimid

Returns the number of the current primitive.

USAGE
  int getprimid()

Returns the primitive number for the current geometric primitive being
shaded.

RELATED

}

{
getptextureid

Returns the ptexture face id for the current primitive.

USAGE
  int getptextureid()

Returns the ptexture id for the current face being shaded. This will
typically be the same as getprimid() except in the case of subdivision
surfaces. For subdivision surfaces, mantra splits non-quadrilateral
faces into multiple patches. Each of these split faces is assigned a
unique ptexture id.

RELATED

}

{
getraylevel

Returns the depth of the ray tree for the current shading.

USAGE
  int getraylevel()

Returns the depth of the ray tree for the current shading. If the
returned value is 0, this represents a ray from the camera to the scene.
If the ray level is 1, the ray represents either a reflection/refraction
ray. If the level is 2, then this represents a reflection/refraction
which appears in a previous reflection/refraction etc.

RELATED

}

{
getrayweight

Returns an approximation to the contribution of the ray to the final
pixel color.

USAGE
  float getrayweight()

Returns an approximation to the contribution of the ray to the final
pixel color. Often, this is a better metric for judging contribution to
the final pixel color than getraylevel. However, this relies on prior
shaders giving good estimates on the contribution to their shading (see
reflectlight).

RELATED

}

{
getsamplestore

Looks up sample data in a channel, referenced by a point.

USAGES
  int getsamplestore(string channel, vector P, int &value)
  int getsamplestore(string channel, vector P, float &value)
  int getsamplestore(string channel, vector P, vector &value)
  int getsamplestore(string channel, vector P, vector4 &value)

Looks up a value in a named channel at a specified point. Returns a non-
zero value and sets <value> on success, or returns 0 if the data could
not be set.

The sample store can be thought of as an in-memory point cloud, storing
shading data at points. This allows data to be accessed across shader
boundaries, unlike the internal export/import system. For example, a
lens shader could store data to be passed to the surface shader, an
operation that is not supported using export variables due to the layout
of the shading pipeline.

Please note that the stored samples can only be accessed within the same
render tile.

EXAMPLE

  > cvex displacedlens(
  >     // Inputs
  >     float x = 0;
  >     float y = 0;
  >     float Time = 0;
  >     float dofx = 0;
  >     float dofy = 0;
  >     float aspect = 1;
  > 
  >     float displaceScale = 1.0;
  >     float displaceGain = 0.1;
  > 
  >     // Outputs
  >     export vector P = 0;
  >     export vector I = 0;
  > )
  > {
  >     P = {x, y, 0};
  >     I = {1, 0, 0};
  > 
  >     vector displace = noise(P * displaceScale) * displaceGain;
  >     I += displace;
  > 
  >     // Store the displacement at the eye point, 'P'
  >     int status = setsamplestore("displacedlens_d", P, displace);
  > }
  > 
  > surface mysurface()
  > {
  >     // Get the displacement at the eye point, 'Eye'
  >     vector displace = 0;
  >     int status = getsamplestore("displacedlens_d", Eye, displace);
  > 
  >     //...
  > }

RELATED

  * setsamplestore

}

{
getscope

Returns a selection of objects visible to rays for a given material.

USAGE
  void getscope(material mat, string raystyle, string &scope, string
  &categories)

Given a material handle, determine the objects which are visible for a
given raystyle ("diffuse", "reflect", or "refract"). The object
selection is given by the scope/categories returned.

RELATED

  * getmaterial

  * getlightscope

  * trace

}

{
getsmoothP

Returns modified surface position based on a smoothing function.

Returns a modified surface position based on a smoothing function.

USAGES
  int getsmoothP(vector &smoothP, vector ray_origin, ...)
  Overwrites the smoothP variable with the modified surface position.
  This function is only meaningful for some primitive types (such as
  polygons).

  vector getsmoothP(...)
  Uses the global variables Eye and I to fill in the ray origin and
  direction.

VARIADIC ARGUMENTS


    style

        none
            No smoothing.

        shadow
            Apply a smoothing function appropriate to elimination of the
            shadow terminator issue for polygons.

EXAMPLES

  > shadow
  > fastshadow()
  > {
  >     vector        surfP;
  >     if (!getsmoothP(surfP, Eye, I))
  >         surfP = Ps;                // Set to the Ps (surface P) variable
  >     vector shad = trace(surfP, normalize(L), Time, "raystyle", "shadow");
  >     Cl *= ({1,1,1} - shad);
  > }

RELATED

}

{
getspace

Returns a transform from one space to another.

USAGE
  matrix getspace(string fromspace, string tospace)

See ptransform for a list of possible space names.

RELATED

  * vtransform

  * ntransform

  * ptransform

}

{
getuvtangents

Evaluates UV tangents at a point on an arbitrary object.

USAGE
  void getuvtangents(string objName, vector P, vector dir, vector &Tu,
  vector &Tv)

This variant additionally sets Tn to the evaluation point's surface
normal:

USAGE
  void getuvtangents(string objName, vector P, vector dir, vector &Tu,
  vector &Tv, vector &Tn)


NOTE
    The object must have a vector attribute named "uv".


TIP
    Passing "" as the objName parameter will cause the function to use
    the current shaded object.


objName
    Name of object to evaluate UV tangents for.

P
    Point at which to evaluate UV tangents.

dir
    The direction to use for searching the object's surface.

    The surface of the object is searched for by casting rays from P in
    this direction as well as the opposite direction.

    When available, it makes sense to use the normal at the point being
    evaluated.

Tu
    UV tangent in U direction.

Tv
    UV tangent in V direction.

Tn
    The surface normal at the point where tangents are evaluated.

> // Get UV tangent at 'P', searching the surface in the direction of 'N'
> vector Tu, Tv;
> getuvtangents("/obj/geo1", P, N, Tu, Tv);
> // Find a surface location using an arbitrary ray.
> // In this case the surface normal isn't known beforehand and can be fetched via 'Tn'.
> vector Tu, Tv, Tn;
> getuvtangents("/obj/geo1", ray_orig, ray_dir, Tu, Tv, Tn);

RELATED

  * Du

  * Dv

  * getderiv

}

{
gradient

Returns the gradient of a field.

USAGES
  vector gradient(float val, ...)
  vector gradient(vector P, float val, ...)

This method computes the derivative of a volume field using the partial
derivatives with respect to a given position (Du, Dv, and Dw). If no
position is provided, P is assumed in shading contexts. If only Du and
Dv are defined, the derivative will be tangent to the surface being
rendered.

DERIVATIVES OPTIONS

    Functions which compute derivatives take additional arguments to
    allow tuning of the derivative computation.


    extrapolate
        Whether derivatives are "smooth" across patch boundaries. In
        most cases this is true and if extrapolation is turned on,
        derivative computation should be exact for C2 surfaces. However,
        when the VEX variables are changing with a high frequency (for
        example, a high frequency displacement map causing high
        frequency changes to the P variable), extrapolation of
        derivative computation may cause exaggeration of discontinuities
        between patch boundaries.

    smooth
        Adjust the magnitude of the differentials non-uniformly over
        patches. This will usually reduce patch discontinuities in
        displacement/textured shaders. However, in some odd cases you
        may want to turn this feature off.

  > N = computenormal(P, "extrapolate", 1, "smooth", 0);

EXAMPLES

    Return the gradient of the density field:

  > surface test_grad(float density = 0)
  > {
  > Cf = gradient(density);
  > }

RELATED

  * volume

  * Du

  * Dv

  * Dw

}

{
hair

Returns a BSDF for shading hair.

USAGES
  bsdf hair(vector N; vector tip; float lobe_shift; float
  lobe_width_lon, ...)
  bsdf hair(vector N; vector tip; float lobe_shift; float
  lobe_width_lon, float lobe_with_azi, ...)
  bsdf hair(vector N; vector tip; float lobe_shift; float
  lobe_width_lon, float lobe_with_azi, float glint_shift; float
  glint_intensity, ...)
  Details of the hair BSDF can be found in the source file
  (hair_eval.vfl).

  Any variadic arguments to the functions are passed through to the CVEX
  evaluation function.

EXAMPLES

    These different signatures are equivalent to the following code:

  > bsdf hair(vector N; vector tip; float lobe_shift; float lobe_width_lon, ...)
  > {
  >     cvex_bsdf("hair_eval", "hair_sample",
  >         "label", "diffuse",
  >         "tip", tip,
  >         "lobe_shift", lobe_shift,
  >         "lobe_width_lon", lobe_width_lon,
  >     ...);
  > }
  > 
  > bsdf hair(vector N; vector tip; float lobe_shift; float lobe_width_lon, float lobe_with_azi, ...)
  > {
  >     cvex_bsdf("hair_eval", "hair_sample",
  >         "label", "refract",
  >         "tip", tip,
  >         "lobe_shift", lobe_shift,
  >         "lobe_width_lon", lobe_width_lon,
  >         "lobe_width_azi", lobe_width_azi,
  >     ...);
  > }
  > 
  > bsdf hair(vector N; vector tip; float lobe_shift; float lobe_width_lon, float glint_shift; float glint_intensity, ...)
  > {
  >     cvex_bsdf("hair_eval", "hair_sample",
  >         "label", "reflect",
  >         "tip", tip,
  >         "lobe_shift", lobe_shift,
  >         "lobe_width_lon", lobe_width_lon,
  >         "glint_shift", glint_shift,
  >         "glint_intensity", glint_intensity,
  >     ...);
  > }

RELATED

  * phong

  * phonglobe

  * Writing a PBR shader

}

{
hasattrib

Checks whether a geometry attribute exists.

If you know the attribute class ahead of time, using hasdetailattrib,
hasprimattrib, haspointattrib, or hasvertexattrib may be faster.

USAGE
  int hasattrib(<geometry>, string attribclass, string attribute_name)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

texttype
    One of "detail" (or "global"), "point", "prim", or "vertex".

    You can also use "primgroup", "pointgroup" or "vertexgroup" to read
    from groups.

Returns 1 if the attribute exists, or 0 otherwise.

EXAMPLES

  > // Check whether the point group "pointstouse" exists.
  > if (hasattrib("defgeo.bgeo", "pointgroup", "pointstouse")) {
  >     // Do something with the point group
  > }

RELATED

  * hasdetailattrib

  * hasprimattrib

  * haspointattrib

  * hasvertexattrib

}

{
hasdetailattrib

Returns if a geometry detail attribute exists.

USAGE
  int hasdetailattrib(<geometry>, string attribute_name)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

Returns 1 if the given attribute exists or 0 otherwise.

EXAMPLES

  > 
  > int        exists;
  > // Determine if the P attribute exists.
  > exists = hasdetailattrib("defgeo.bgeo", "P");

RELATED

  * hasattrib

  * hasprimattrib

  * haspointattrib

  * hasvertexattrib

}

{
haslight

Returns whether a light illuminates the given material.

USAGE
  int haslight(material mat; vector P; int light; ...)

Returns 1 if the given light is used to illuminate the material at the
point specified.

This function accepts PBR keyword arguments to specify sampling types.
These options may exclude lights which don't match the desired sampling
paths.

The PBR sampling keywords include:


label
    A string specifying a specific label. This keyword argument may be
    specified multiple times.

direct
    Expects an 0 or 1 integer value which will limit lights based on
    indirect or direct contribution categories.

EXAMPLES

  > haslight(material(), P, light_num, "direct", 0);

RELATED

  * getlights

}

{
hasmetadata

Queries if metadata exists on a composite operator.

USAGE
  int hasmetadata(int opinput, string name)

This function checks if metadata named name exists on the COP attached
to the VEX COP's input opinput. If it exists then 1 is returned,
otherwise 0.


texttype
    The input number to read from, starting from 0. For example, the
    first input is 0, the second input is 1, and so on.

name
    The name of the metadata to check.

:

  * metadata

}

{
hasplane

Returns 1 if the plane specified by the parameter exists in this COP.

USAGE
  int hasplane(string planename)

Returns 1 if the plane specified by the parameter exists in this COP.

RELATED

}

{
haspointattrib

Returns if a geometry point attribute exists.

USAGE
  int haspointattrib(<geometry>, string attribute_name)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

    1 if the attribute exists, or 0 otherwise.

EXAMPLES

  > // Determine if the P attribute exists.
  > int exists = haspointattrib("defgeo.bgeo", "P");

RELATED

}

{
hasprimattrib

Returns if a geometry prim attribute exists.

USAGE
  int hasprimattrib(<geometry>, string attribute_name)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

Returns 1 if the attribute exists, or 0 otherwise.

EXAMPLES

  > // Determine if the P attribute exists.
  > int exists = hasprimattrib("defgeo.bgeo", "P");

RELATED

}

{
hasvertexattrib

Returns if a geometry vertex attribute exists.

USAGE
  int hasvertexattrib(<geometry>, string attribute_name)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

Returns 1 if the attribute exists, or 0 otherwise.

EXAMPLES

  > // Determine if the P attribute exists.
  > int exists = hasvertexattrib("defgeo.bgeo", "P");

RELATED

}

{
hedge_dstpoint

Returns the destination point of a half-edge.

USAGE
  int hedge_dstpoint(<geometry>, int hedge)

Returns -1 if the half-edge hedge is invalid. Otherwise, returns the
point number of the destination point of the half-edge hedge.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

hedge
    Input half-edge.

EXAMPLES

  > 
  > int dstpt;
  > 
  > // Get vertex number of half-edge number 3.
  > dstpt = hedge_dstpoint("defgeo.bgeo", 3);

RELATED

}

{
hedge_dstvertex

Returns the destination vertex of a half-edge.

USAGE
  int hedge_dstvertex(<geometry>, int hedge)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

hedge
    Input half-edge.

    The vertex number of the half-edge's destination vertex, or -1 if
    the half-edge is not valid.

EXAMPLES

  > 
  > int dstvtx;
  > 
  > // Get the destination vertex half-edge number 3.
  > dstvtx = hedge_dstvertex("defgeo.bgeo", 3);

RELATED

}

{
hedge_equivcount

Returns the number of half-edges equivalent to a given half-edge.

USAGE
  int hedge_equivcount(<geometry>, int hedge)


NOTE
    Equivalent half-edges may be oppositely oriented, i.e. the source of
    one can be the destination of the other and vice versa.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

hedge
    Input half-edge.

    The number of half-edges that have the same endpoint as hedge
    (including hedge), or -1 if the half-edge is not valid.

EXAMPLES

  > 
  > int is_boundary = 0;
  > int is_interior = 0;
  > int is_nonmanifold = 0;
  > 
  > // Determine the type of edge represnted by half-edge number 3:
  > int numeq;
  > numeq = hedge_equivcount("defgeo.bgeo", 3);
  > if (numeq == 1)
  > is_boundary = 1;
  > else if (numeq >= 3)
  > is_nonmanifold = 1;
  > else
  > is_interior = 1;

RELATED

}

{
hedge_isequiv

Determines whether a two half-edges are equivalent (represent the same
edge).

USAGE
  int hedge_isequiv(<geometry>, int hedge1, int hedge2)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

hedge1
    The integer representing the first half-edge.

hedge2
    The integer representing the second half-edge.

    1 if hedge1 and hedge2 are equivalent, i.e. represent the same edge
    in the geometry. This is the case when either source and destination
    points of hedge1 and hedge2 are respectively the same, or source of
    each of hedge1 and hedge2 is the same as the destination of the
    other.

EXAMPLES

  > 
  > int opposite = 0;
  > 
  > // test if hedges 2 and 3 are oppositely oriented equivalent half-edges
  > if (hedge_isequiv("defgeo.bgeo", 2, 3))
  > {
  > if (hedge_srcpoint("defgeo.bgeo", 2) == hedge_dstpoint("defgeo.bgeo", 3))
  > opposite = 1;
  > }

RELATED

}

{
hedge_isprimary

Determines whether a half-edge number corresponds to a primary half-
edge.

USAGES
  int hedge_isprimary(string geometry, int hedge)
  int hedge_isprimary(int opinput, int hendge)


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

hedge
    The integer representing a half-edge.

    1 if hedge represents a primary half-edge in the referenced
    geometry, or 0 otherwise.

EXAMPLES

  > 
  > int numedges;
  > 
  > // Count the number of edges
  > 
  > if (hedge_isprimary("defgeo.bgeo", 3))
  > numedges++;

RELATED

}

{
hedge_isvalid

Determines whether a half-edge number corresponds to a valid half-edge.

USAGE
  int hedge_isvalid(<geometry>, int hedge)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

hedge
    The integer representing a half-edge.

    1 if hedge represents a valid half-edge in the referenced geometry,
    or 0 otherwise.

EXAMPLES

  > 
  > int srcpt;
  > 
  > // find the source point of a half-edge number 3 if it is valid
  > if (hedge_isvalid("defgeo.bgeo", 3))
  > srcpt = hedge_srcpoint("defgeo.bgeo", 3);

RELATED

}

{
hedge_next

Returns the half-edge that follows a given half-edge in its polygon.

USAGE
  int hedge_next(<geometry>, int hedge)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

hedge
    Input half-edge.

    The number of the half-edges that follow (its source is the
    destination of) hedge in the polygon that contains it. Returns -1 if
    the half-edge is not valid.

EXAMPLES

  > 
  > int nexthedge;
  > 
  > // Get the next half-edge of half-edge number 3.
  > nexthedge = hedge_next("defgeo.bgeo", 3);

RELATED

}

{
hedge_nextequiv

Returns the next half-edges equivalent to a given half-edge.

USAGE
  int hedge_nextequiv(<geometry>, int hedge)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

hedge
    Input half-edge.

    The next half-edge equivalent to hedge, or hedge if there are no
    other half-edges equivalent to it. Successive calls to
    hedge_nextequiv() cycle through all the equivalent half-edges.
    Returns -1 if the half-edge is not valid.

EXAMPLES

  > 
  > // Determine the number of half-edges equivalent to half-edge number 3 (including itself)
  > int num_equiv = 0;
  > int h = 3;
  > do
  > {
  > h = hedge_nextequiv("defgeo.bgeo", h);
  > num_equiv++;
  > } while (h != 3);

RELATED

}

{
hedge_postdstpoint

Returns the point into which the vertex following the destination vertex
of a half-edge in its primitive is wired.

USAGE
  int hedge_postdstpoint(<geometry>, int hedge)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

hedge
    Input half-edge.

    The point number of the point into which the vertex that comes after
    the destination vertex of the half-edge hedge in the primitive that
    contains hedge is wired. Returns -1 if the half-edge is not valid.

EXAMPLES

  > 
  > int postdstpt;
  > 
  > // Get the destination vertex half-edge number 3.
  > postdstpt = hedge_postdstpoint("defgeo.bgeo", 3);

RELATED

}

{
hedge_postdstvertex

Returns the vertex following the destination vertex of a half-edge in
its primitive.

USAGE
  int hedge_postdstvertex(<geometry>, int hedge)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

hedge
    Input half-edge.

    The vertex number of the vertex that comes after the destination
    vertex of the half-edge hedge in the primitive that contains hedge.
    Returns -1 if the half-edge is not valid.

EXAMPLES

  > 
  > int postdstvtx;
  > 
  > // Get the destination vertex half-edge number 3.
  > postdstvtx = hedge_postdstvertex("defgeo.bgeo", 3);

RELATED

}

{
hedge_presrcpoint

Returns the point into which the vertex that precedes the source vertex
of a half-edge in its primitive is wired.

USAGE
  int hedge_presrcpoint(<geometry>, int hedge)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

hedge
    Input half-edge.

    The point of the point into which the vertex that comes before the
    source vertex of the hedge in the primitive that contains hedge is
    wired. Returns -1 if the half-edge is not valid.

EXAMPLES

  > 
  > int presrcpt;
  > 
  > // Get the pre-source point of half-edge number 3.
  > presrcpt = hedge_presrcpoint("defgeo.bgeo", 3);

RELATED

}

{
hedge_presrcvertex

Returns the vertex that precedes the source vertex of a half-edge in its
primitive.

USAGE
  int hedge_presrcvertex(<geometry>, int hedge)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

hedge
    Input half-edge.

    The vertex number of the vertex that comes before the source vertex
    of the hedge in the primitive that contains hedge. Returns -1 if the
    half-edge is not valid.

EXAMPLES

  > 
  > int presrcvtx;
  > 
  > // Get the pre-source vertex of half-edge number 3.
  > presrcvtx = hedge_presrcvertex("defgeo.bgeo", 3);

RELATED

}

{
hedge_prev

Returns the half-edge that precedes a given half-edge in its polygon.

USAGE
  int hedge_prev(<geometry>, int hedge)

Returns -1 if hedge is invalid. Otherwise, returns the number of the
half-edge that precedes (its destination is the source of) hedge in the
polygon that contains it.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

hedge
    Input half-edge.

    The number of the half-edge that precedes (its destination is the
    source of) hedge in the polygon that contains it. Returns -1 if the
    half-edge is not valid.

EXAMPLES

  > 
  > int prev;
  > 
  > // Get the previous half-edge of half-edge number 3.
  > prevhedge = hedge_prev("defgeo.bgeo", 3);

RELATED

}

{
hedge_prim

Returns the primitive that contains a half-edge.

USAGE
  int hedge_prim(<geometry>, int hedge)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

hedge
    Input half-edge.

    The primitive number of primitive that contains (the source and
    destination vertices of) hedge. Returns -1 if the half-edge is not
    valid.

EXAMPLES

  > 
  > int prim;
  > 
  > // Get the primitive number of half-edge number 3.
  > prim = hedge_prim("defgeo.bgeo", 3);

RELATED

}

{
hedge_primary

Returns the primary half-edge equivalent to a given half-edge.

USAGE
  int hedge_primary(<geometry>, int hedge)

Each class of equivalent half-edges has precisely one primary half-edge.
In particular, a half-edge which is equivalent to no other half-edges is
always primary. Primary half-edges are useful for accounting for each
edge exactly once as each edge may be realized by any number of
equivalent half-edges.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

hedge
    Input half-edge.

    The primary half-edge hedge that shares the source and destination
    of hedge (possibly in reverse order). Returns -1 if the half-edge is
    not valid.

EXAMPLES

  > 
  > int primhedge;
  > 
  > // Get the primary half-edge equivalent  to half-edge number 3.
  > primhedge = hedge_primary("defgeo.bgeo", 3);

RELATED

}

{
hedge_srcpoint

Returns the source point of a half-edge.

USAGE
  int hedge_srcpoint(<geometry>, int hedge)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

hedge
    Input half-edge.

    The point number of the source point of the hedge. Returns -1 if the
    half-edge is not valid.

EXAMPLES

  > 
  > int linearvtx;
  > 
  > // Get the linear vertex value of vertex 2 of primitive 3.
  > linearvtx = hedge_srcpoint("defgeo.bgeo", 3, 2);

RELATED

}

{
hedge_srcvertex

Returns the source vertex of a half-edge.

USAGE
  int hedge_srcvertex(<geometry>, int hedge)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

hedge
    Input half-edge.

    The vertex number of the source vertex of the hedge. Returns -1 if
    the half-edge is not valid.

EXAMPLES

  > 
  > int srcvtx;
  > 
  > // Get the source vertex of half-edge number 3.
  > srcvtx = hedge_srcvertex("defgeo.bgeo", 3);

RELATED

}

{
henyeygreenstein

Returns an anisotropic volumetric BSDF, which can scatter light forward
or backward.

USAGE
  bsdf henyeygreenstein(float anisotropic_bias, ...)
  The Henyey-Greenstein function scatters light either forward or in
  reverse depending on the anisotropic_bias provided to the function
  which must be a floating point value between -1 and 1. A value of 0
  will cause isotropic scattering (identical to the isotropic() bsdf)
  while positive values produce forward scattering and negative values
  produce reverse scattering. The extrema of -1 and 1 cause all light to
  be scattered in a single direction, back toward the light for -1 and
  without any directional change for 1.


NOTE
    No normal vector is required to construct a Henyey-Greenstein BSDF
    since it has no directionality. The default albedo for the BSDF is
    1, which means it scatters 100% of the incoming light.

RELATED

  * isotropic

  * specular

  * phong

  * Writing a PBR shader

}

{
hscript_noise

Generates noise matching the output of the Hscript noise() expression
function.

USAGE
  float hscript_noise(vector pos)

Matches the output of noise. This function can be useful if you convert
a workflow to VEX, or have VEX work in tandem with Hscript expressions,
and need the noise to look the same as in an expression.


pos
    Position at which to sample the noise.

RELATED

  * hscript_snoise

  * hscript_rand

  * hscript_turb

  * hscript_sturb

}

{
hscript_rand

Produces the exact same results as the Houdini expression function of
the same name.

USAGE
  float|vector|vector4 hscript_rand(float seed)

Produces the exact same results as the Houdini expression function of
the same name. This function will generate different random values for
every floating point seed. This is different that the random function
which converts the floating point argument to an integer seed. The
hscript_rand() function may produce different results on different
hardware or operating systems.

RELATED

}

{
hscript_snoise

USAGE
  float hscript_snoise(vector pos)

RELATED

  * hscript_noise

}

{
hscript_sturb

USAGE
  float hscript_sturb(vector pos, int turbulence)

RELATED

  * hscript_noise

}

{
hscript_turb

Generates turbulence matching the output of the HScript turb()
expression function.

USAGE
  float hscript_turb(vector pos, int depth)

Matches the output of turb. This function can be useful if you convert a
workflow to VEX, or have VEX work in tandem with Hscript expressions,
and need the turbulence to look the same as in an expression.


pos
    Position at which to sample the turbulent noise.

depth
    Number of fractal iterations of noise.

    The range is usually within -1 to 1, but can exceed it depending on
    the depth. The maximum range is -2 to 2 for high depths.

RELATED

  * hscript_sturb

  * hscript_noise

  * hscript_snoise

  * hscript_rand

}

{
hsvtorgb

Convert HSV color space into RGB color space.

USAGES
  vector hsvtorgb(vector hsv)
  vector hsvtorgb(float hue, float sat, float val)

Convert HSV color space into RGB color space. A vector representing the
RGB triple is returned. The hue should be in the range 0 to 1.

RELATED

}

{
iaspect

Returns the aspect ratio of the specified input.

USAGE
  float iaspect(int opinput)

Returns the aspect ratio of the specified input.


texttype
    The input number to read from, starting from 0. For example, the
    first input is 0, the second input is 1, and so on.

RELATED

}

{
ichname

Returns the channel name of the indexed plane of the given input.

USAGE
  string ichname(int inputnum, int plane_index, int component_index)

Returns the component name (for example, "r" or "x") of a component of a
plane.

RELATED

}

{
ident

Returns an identity matrix.

USAGE
  <matrix> ident()
  Returns the identity matrix for the given matrix type.

RELATED

}

{
idtopoint

Finds a point by its id attribute.

USAGE
  int idtopoint(<geometry>, int id)

Returns the number of the point with the given value in the id
attribute. Returns -1 if no point has the given ID.

If the geometry doesn't have an id attribute, point numbers are used as
ids. In this case, the function will return the given id value, unless
it is greater than the number of points in the source geometry, in which
case the function will return -1.

To look up a point by its name attribute value, use nametopoint. To look
up a point by an arbitrary string or int attribute value, use
findattribval.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

RELATED

  * nametopoint

  * idtoprim

  * findattribval

}

{
idtoprim

Finds a primitive by its id attribute.

USAGE
  int idtoprim(<geometry>, int id)

Returns the number of the primitive with the given value in the id
attribute. Returns -1 if no primitive has the given ID.

If the geometry doesn't have an id attribute, primitive numbers are used
as ids. In this case, the function will return the given id value,
unless it is greater than the number of points in the source geometry,
in which case the function will return -1.

To look up a primitive by its name attribute value, use nametoprim. To
look up a primitive by an arbitrary string or int attribute value, use
findattribval.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

RELATED

  * nametoprim

  * idtopoint

  * findattribval

}

{
iend

Returns the last frame of the specified input.

USAGE
  int iend(int opinput)

Returns the last frame of the specified input.


texttype
    The input number to read from, starting from 0. For example, the
    first input is 0, the second input is 1, and so on.

RELATED

}

{
iendtime

Returns the end time of the specified input.

USAGE
  float iendtime(int opinput)

Returns the end time of the specified input.


texttype
    The input number to read from, starting from 0. For example, the
    first input is 0, the second input is 1, and so on.

RELATED

}

{
ihasplane

Returns 1 if the specified input has a plane named planename.

USAGE
  int ihasplane(int opinput, string planename)

Returns 1 if the specified input has a plane named planename. Input
numbers start at 0.


texttype
    The input number to read from, starting from 0. For example, the
    first input is 0, the second input is 1, and so on.

RELATED

}

illuminance

Loops through all light sources in the scene, calling the light shader
for each light source to set the Cl and L global variables.

OVERVIEW

    // Need to indent this so the include below doesn't go under this
    heading

  > illuminance(position, [axis], [angle], [light_typemask], [lightmask])
  > {
  >     // Here, Cl and L will be set to the value/direction for the
  >     // current light source.
  >     // To force the shadow shader to be called, use:
  >     // shadow(Cl);
  > }

    The shadow shader is not called unless you explicitly call it.
    However, once the shadow shader has been called, the value of Cl
    will be changed for the duration of the surface shader. The shadow
    shader is automatically called when using any of the built-in
    lighting calls (e.g. diffuse, specular, ambient).

    The default value for the axis is the surface normal. The default
    value for the angle is PI/2. The default value for the light mask is
    LIGHT_DIFFUSE|LIGHT_SPECULAR (please see shading.h for the light
    definitions).

    The illuminance statement loops through all light sources for which
    dot(L, axis) > cos(angle).

LIGHT INCLUSION/EXCLUSION OPTIONS


    categories
        Specifies lights to include/exclude by their "category" tags.
        This is the preferred include/exclude lights rather than pattern
        matching light names with the "lightmask" keyword argument.

        For example:

      > diff = diffuse(nml, "lightmask", "hero | fill");

        See light categories for more information.

    lightmask
        When evaluating light and shadow shaders, objects have pre-
        defined light masks. This mask is usually specified in the
        geometry object and specifies a list of lights which are used to
        illuminate a surface or fog shader. It is possible to override
        the default light mask by specifying a "lightmask" argument.

        For example:

      > diff = diffuse(nml, "lightmask", "light*,^light2");

        ...will cause all lights whose names begin with "light" except
        for a light named "light2" to be considered for diffuse
        illumination.

        All Houdini scoping patterns, excepting group expansion, are
        supported:

      * * - wild-card match

      * ? - single character match

      * ^ - exclusion operator

      * [list] - character list match

SENDING INFORMATION TO THE LIGHT'S SHADER

    You can give additional pairs of string/value arguments to
    illuminance to pass named values to each light's shader. For
    example, to pass the value of the N variable as orgN:

  > illuminance (P, nf, M_PI/2, "orgN", N) {
  > ...
  > }

    In the light's shader, you can receive the value from the
    illuminance loop with the simport function.

  > vector orgN;
  > simport("orgN", orgN);

    The simport function returns 1 if the import succeeds and 0
    otherwise, so you can use it as the condition in an if statement.

    Here's a full example:

  > surface
  > exporter()
  > {
  > vector nf = frontface(normalize(N), I);
  > Cf = 0;
  > illuminance(P, nf, M_PI/2, "orgN", N)
  > {
  > Cf += Cl;
  > }
  > 
  > light
  > importer()
  > {
  > vector orgN;
  > if (!simport("orgN", orgN))
  > orgN = N;
  > // Use original N
  > Cl = orgN;
  > }

MESSAGE PASSING

    Within the illuminance loop, you can retrieve values from the light
    shader with the the limport function.

    The light shader can retrieve any "keyword" arguments passed to the
    illuminance statement with the simport function.

    For example, to send down the vector variable uv to the light
    shader...

  > vector      uv = set(s, t, 0);
  > illuminance(P, dir, "uv", uv) { ... }

    The light shader would be able to read this using...

  > vector      uv;
  > if (simport("uv", uv))
  > printf("Imported: %g from surface\n", uv);

LIGHTEXPORT KEYWORD ARGUMENT

    You can supply the extra string argument "lightexport" followed by a
    string argument containing the name(s) of the exported variables to
    assign within the loop.

    In some shaders, multiple illuminance loops are used to define
    different light contributions. The lightexport argument is useful in
    these cases to specify which variables should be exported from the
    different loops.

    The lightexport value can be a space-separated list of wildcard
    patterns. For example, illuminance(pos, dir, "lightexport",
    "Front*") exports variables whose names start with Front.

  > 
  > surface
  > light_export_test(export vector diff=0;
  > export vector spec=0)
  > {
  > vector     nn = normalize(frontface(N, I));
  > vector     vv = -normalize(I);
  > vector     clr;
  > 
  > Cf = 0;
  > // This illuminace loop only exports to the "diff" variable
  > illuminance(P, nn, "lightexport", "diff")
  > {
  > clr = Cl * diffuseBRDF(normalize(L), nn);
  > Cf += clr;
  > diff = clr;
  > }
  > // This illuminace loop only exports to the "spec" variable
  > illuminance(P, nn, "lightexport", "spec")
  > {
  > clr = Cl * specularBRDF(normalize(L), nn, vv, 0.1);
  > Cf += clr;
  > spec = clr;
  > }

RELATED

  * simport

  * limport

  * gather

{
import

Reads attribute data.


WARNING
    This function has been deprecated. Use getattrib instead.

}

VEX Functions

See VEX contexts to learn about the different contexts (such as surface
shaders or displacement shaders) in which the various functions and
statements are available.

FUNCTIONS


{
inedgegroup

Returns 1 if the edge specified by the point pair is in the group
specified by the string.

USAGES
  int inedgegroup(string filename, string groupname, int pointnum0, int
  pointnum1)
  int inedgegroup(int input, string groupname, int pointnum0, int
  pointnum1)

Returns 1 if the edge specified by the point pair is in the group
specified by the string. This function returns 0 if the group does not
exist or if the edge is not contained in the group.

RELATED

}

{
ingroup

WARNING
    This function has been deprecated. Use inpointgroup instead.

RELATED

}

{
inpointgroup

Returns 1 if the point specified by the point number is in the group
specified by the string.

USAGE
  int inpointgroup(<geometry>, string groupname, int pointnum)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

    1 if the group exists and the point is in the group, or 0 otherwise.

RELATED

}

{
inprimgroup

Returns 1 if the primitive specified by the primitive number is in the
group specified by the string.

USAGE
  int inprimgroup(<geometry>, string groupname, int primnum)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

    1 if the groups exists and the primitive is in the group, or 0
    otherwise.

RELATED

}

{
insert

Inserts an item, array, or string into an array or string.

USAGES
  void insert(string &str; int index; string value)
  Inserts the value into the string str at the given index.

  If index is greater than the length of the string, the value will
  simply be appended to the existing str.

  void insert(<type> &array[]; int index; <type> value)
  void insert(<type> &array[]; int index; <type> values[])
  Inserts the items or items into the array starting at the given index.

  If index is greater than the length current length of the array, the
  function will fill the gaps with uninitialized values (for example, 0
  or the empty string).

  * If the index is negative, it counts from the _end_ of the string or
    array you're inserting into. (If the negative number is greater than
    the string/array length, it is clamped to 0.)

    For example, to insert the number 100 as the second-to-last item in
    an array:

  > insert(numbers; -1; 100)

RELATED

  * Arrays

  * len

  * push

  * append

  * resize

}

{
instance

Creates an instance transform matrix.

USAGES
  matrix instance(vector P, vector N)
  matrix instance(vector P, vector N, vector scale)
  matrix instance(vector P, vector N, vector scale, vector pivot)
  matrix instance(vector P, vector N, vector scale, vector4 rotate,
  vector up)
  matrix instance(vector P, vector N, vector scale, vector4 rotate,
  vector up, vector pivot)
  matrix instance(vector P, vector N, vector scale, vector4 rotate,
  vector4 orient)
  matrix instance(vector P, vector N, vector scale, vector4 rotate,
  vector4 orient, vector pivot)

Creates a transform matrix from the given arguments, using the same
method that the Copy SOP uses to transform its output instances. The
instance is placed at point P, oriented along the normal direction N,
and, optionally, scaled by scale. An optional pivot parameter can be
supplied as the local transformation point for the instance.

The function supports two methods for setting rotation. The fist method
requires an explicit up vector, which should be tangent to N. This up
vector, along with N, is used to construct an orthonormal frame in which
the rotation takes place. The second method uses an explicit orientation
relative to the XYZ axis to construct the frame.

RELATED

  * scale

  * rotate

  * translate

}

{
interpolate

Interpolates a value across the currently shaded micropolygon.

USAGES
  float interpolate(float val, float sx, float sy)
  vector interpolate(vector val, float sx, float sy)
  vector4 interpolate(vector4 val, float sx, float sy)
  bsdf interpolate(bsdf val, float sx, float sy)

These operations can be used to generate antialiasing positions within
the micropolygon rendering engine.

sx and sy are random values, such as generated by nextsample. Different
values of sx and sy translate into different random positions on the
micropolygon.

The returned value is undefined in the raytracing engine.

> vector hitP = interpolate(P, sx, sy);

RELATED

  * nextsample

  * sample_light

}

{
intersect

This function computes the first intersection of a ray with geometry.

To get a list of _all_ intersections along a ray, use intersect_all.

USAGES
  int intersect(<geometry>, vector orig, vector dir, vector &p, float
  &u, float &v)
  int intersect(<geometry>, vector orig, vector dir, vector &p, float
  &u, float &v, ...)
  Computes the first intersection of the specified ray with the
  geometry. To get _all_ intersections along a vector, use intersect_all
  instead. The variadic argument "farthest" can be used to indicate
  whether to return the last intersection instead of the first.

  int intersect(<geometry>, vector orig, vector dir, vector &p, vector
  &uvw)
  Computes the first intersection of the specified ray with the
  geometry. To get _all_ intersections along a vector, use intersect_all
  instead.

  int intersect(<geometry>, string group, vector orig, vector dir,
  vector &p, vector &uvw)
  Computes the intersection of the specified ray with primitives in the
  given group.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

group
    If given, only intersect primitives in this group.

orig
    The ray origin point.

dir
    The ray direction _and maximum distance_. This function does not
    expect a normalized direction vector. Instead, it uses the length of
    the vector as the maximum distance to search.

&p
    If the ray intersects a primitive, this variable is overwritten with
    the intersection position in world space.

&u, &v, &uvw
    If the ray intersects a primitive, this/these variable(s) is/are
    overwritten with the parametric intersection position on the
    primitive.

    The intersected primitive number, or -1 if there was an error or the
    ray didn't intersect anything.


NOTE
    When intersections are performed against metaball geometry, it is
    impossible to determine the primitive number of the metaball which
    was hit. In this case, the function returns the number of primitives
    in the intersection geometry.

RELATED

  * intersect_all

}

{
intersect_all

Computes all intersections of the specified ray with geometry.

To get only the _first_ intersection, use intersect.

USAGE
  int intersect_all( <geometry>; string group; vector orig; vector dir;
  vector &pos[]; int &prim[]; vector &uvw[], float tol=0.01, float
  ttol=0.01 )


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

texttype
    If given, only intersect primitives in this group.

texttype
    The ray origin point.

texttype
    The ray direction _and maximum distance_. This function does not
    expect a normalized direction vector. Instead, it uses the length of
    the vector as the maximum distance to search.

&pos
    The function overwrites this array with the world space positions of
    each hit.

&prim
    The function overwrites this array with the primitive numbers of the
    primitives hit by the ray.

&uvw
    The function overwrites this array with the parametric UVW
    coordinates of where each intersection occurred on the primitive.

tol, ttol
    tol is the 3D tolerance. ttol is the ray tolerance. Collision points
    within the parametric ray tolerance, ttol will be merged together,
    often useful to avoid getting extra intersects when hitting the
    edges of geometry.

    To get _all_ intersections without merging, set ttol to -1.

    The number of intersections, or 0 if the ray didn't hit anything.


NOTE
    When intersections are performed against metaball geometry, it is
    impossible to determine the primitive number of the metaball which
    was hit. In this case, the function returns the number of primitives
    in the intersection geometry.

RELATED

  * intersect

}

{
intersect_lights

Finds the nearest intersection of a ray with any of a list of (area)
lights and runs the light shader at the intersection point.


NOTE
    This function only works with area lights.

USAGE
  int intersect_lights(int lightids[], vector pos, vector dir, float
  time, int &idx, float &dist, vector &clr, float &scale, ...)


lightids
    An array of light IDs, as returned by getlights.

pos
    The origin of the ray (such as the global variable P).

dir
    Direction vector from the origin. The length of this vector does not
    affect the distance the ray will travel.

time
    Time to send the ray at.

The function modifies the values of the following arguments:


idx
    The light index for the light that was hit by the ray, or -1 if no
    intersection was found.

dist
    The distance to the nearest intersected light.

clr
    The light color set by the light shader.

scale
    The light average hemispherical intensity (for area lights).

    A component bitmask indicating what types of component bounces the
    light affects, or 0 if the ray did not hit a light.

RELATED

  * getlights

  * getlightname

  * sample_light

}

{
inumplanes

Returns the number of planes in the given input.

USAGE
  int inumplanes(int opinput)


texttype
    The input number to read from, starting from 0. For example, the
    first input is 0, the second input is 1, and so on.

    The number of planes in the given input.

RELATED

}

{
invert

Inverts a matrix.

USAGE
  <matrix> invert(<matrix> m)


m
    The matrix to invert.

    The inverted matrix, or the original matrix if the matrix is
    singular.

RELATED

}

{
invertexgroup

Returns 1 if the vertex specified by the vertex number is in the group
specified by the string.

USAGES
  int invertexgroup(string filename, string groupname, int vertexnum)
  int invertexgroup(int opinput, string groupname, int vertexnum)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

vertexnum
    The linear vertex number of the vertex to test.

    To convert a primitive number and vertex number within that
    primitive to a linear vertex number for the vertexnum parameter, use
    the vertexindex function.

    1 if the group exists and the vertex is in the group, or 0
    otherwise.

RELATED

}

{
iplaneindex

Returns the index of the plane named 'planename' in the specified input.

USAGE
  int iplaneindex(int opinput, string planename)


texttype
    The input number to read from, starting from 0. For example, the
    first input is 0, the second input is 1, and so on.

    The index of the plane named 'planename' in the specified input.

RELATED

}

{
iplanename

Returns the name of the plane specified by the planeindex of the given
input

USAGE
  string iplanename(int opinput, int planeindex)


texttype
    The input number to read from, starting from 0. For example, the
    first input is 0, the second input is 1, and so on.

    The name of the plane specified by the planeindex of the given input
    (e.g. "C", "A").

RELATED

}

{
iplanesize

Returns the number of components in the plane named planename in the
specified input.

USAGE
  int iplanesize(int opinput, int planeindex)


texttype
    The input number to read from, starting from 0. For example, the
    first input is 0, the second input is 1, and so on.

    The number of components in the plane named planename in the
    specified input.

RELATED

}

{
irate

Returns the frame rate of the specified input.

USAGE
  float irate(int opinput)


texttype
    The input number to read from, starting from 0. For example, the
    first input is 0, the second input is 1, and so on.

    The frame rate of the specified input.

RELATED

}

{
irradiance

Computes irradiance (global illumination) at the point P with the normal
N.

USAGE
  vector irradiance(vector P, vector N, ...)

Computes irradiance (global illumination) at the point P with the normal
N.

SAMPLE ADAPTATION OPTIONS


    adaptive
        1 or 0. Turns on an automatic optimization that will reduce the
        number of samples when there is little variation in occlusion
        above the sample point. This can improve performance at the
        expense of some possible flickering or additional noise.


RAY OPTIONS


    TIP
        When you specify a texture, such as with the "environment"
        keyword, you can also use the image filtering keyword arguments.
        See environment for a listing of the image filter keyword
        arguments.


    scope
        A list of objects which can be hit by the rays. When specified,
        scope overrides the default scope that would have been selected
        for the given raystyle. The "scope:default" value will cause the
        scope argument to use the default scope for the current context
        - as if the argument were not specified.

        Allows an override of the scope for ray-intersections. A special
        scope argument, scope:self, will match the currently shading
        object.

    maxdist
        The maximum distance to search for objects. This can be used to
        limit the search of objects to nearby objects only. If the
        maxdist given is negative, then it will act as if there is no
        maximum distance.

        Allows an override of the maximum distance the ray can travel
        when testing for intersections. Some functions (such as
        fastshadow) have the maximum distance implicitly defined (by the
        length of the ray) and should probably avoid using this option.
        However, this option can be used effectively when computing
        reflections, global illumination, refraction etc.

    variancevar
        The name of a VEX export variable to use for variance anti-
        aliasing. The renderer compares the value with adjacent
        micropolygons in micropolygon rendering to decide what shading
        points need additional samples (using vm_variance property as a
        threshold). If more samples are required, the algorithm takes
        samples up to the specified maximum ray samples.

        This variable must be imported from the hit surface, so it must
        be in the list of imported names (see "importing information
        back from the ray" below). If the named variable is not
        imported, this option will be ignored.

        Variance antialiasing puts more samples in areas of the image
        with high variance, for example a sharp shadow edge. It is only
        used when vm_dorayvariance is enabled. Otherwise, only the min
        ray samples (or an explicitly supplied "samples" value) are used
        for antialiasing of the gather loop.

        Overrides the global variance control (mantra's -v option) which
        is used to determine anti-aliasing quality of ray tracing. For
        more information please refer to the documentation on mantra.

    angle
        The distribution angle (specified in radians). For gather(),
        rays will be distributed over this angle. For trace(), the angle
        is used to indicate the rate at which the filter width should
        increase with increasing intersection distance. Larger angles
        will cause farther hit surfaces to use larger derivatives,
        leading to improved texturing and displacement performance.

        To be effective, the samples parameter should also be specified.

    samples
        How many samples should be sent out to filter rays. For the
        irradiance and occlusion functions, specifying a samples
        parameter will override the default irradiance sampling.

    environment
        If the ray sent out to the scene misses everything, then it's
        possible to specify an environment map to evaluate.

        Using the ray's direction, the environment map specified will be
        evaluated and the resulting color will be returned. Most likely,
        it will be necessary to specify a transform space for the
        environment map evaluations.

        In the case of refractlight and trace the Of and Af variables
        will be set to 0 regardless of the background color specified.
        the resulting color.

        When an environment map is specified, the filtering options from
        texture() are also supported.

        See how to create an environment/reflection map.

    envobject
        If an environment map is used, the orientation of the
        environment map can be specified by transforming the ray into
        the space of another object, light or fog object in the scene.
        In Houdini, null objects can be used to specify the orientation.
        For example:

      > Cf = R*reflectlight(bias, max(R), "environment", "map.rat", "envobject", "null_object_name");

    envlight
        If an environment map is used, the orientation of the
        environment map can be specified by transforming the ray into
        the space of a light in the scene.

    envtint
        If an environment map is used, tint it with this color.

    background
        If a ray misses all objects, use this as the background color of
        the scene. In the case of refractlight and trace the Of and Af
        variables will be set to 0 regardless of the background color
        specified.

    distribution
        *Functions*: irradiance, occlusion

        Distribution for computing irradiance. The default is to use a
        cosine distribution (diffuse illumination). The possible values
        for the style are "nonweighted" for uniform sampling or "cosine"
        for cosine weighted sampling.

RELATED

  * occlusion

  * pathtrace

  * reflectlight

  * gather

  * trace

  * irradiance

}

{
isalpha

Returns 1 if all the characters in the string are alphabetic

USAGE
  int isalpha(const string str)

Returns 1 if all the characters in the string are alphabetic. No
numerals, punctuation or other special characters. If any are present
then returns 0.

RELATED

  * isdigit

}

{
isbound

Parameters in VEX can be overridden by geometry attributes (if the
attributes exist on the surface being rendered).

USAGE
  int isbound(string variable_name)

Parameters in VEX can be overridden by geometry attributes (if the
attributes exist on the surface being rendered). If the geometry
overrides the default attribute, this function will return 1. Otherwise
it will return 0.


NOTE
    Though this function is defined for all contexts, it is only useful
    in the Displacement, Surface, and SOP contexts. No other contexts

can currently bind geometry attributes to VEX variables.

Example, in a SOP function:

> sop
> mycolor(vector uv=0; string map="")
> {
> if (isbound("uv") && map != "")
> {
>     // User has texture coordinates here, so create
>     // velocity based on a texture map.
>     v = colormap(map, uv);
> }
> else
> {
>     // No texture coordinates, so use a random value
>     v = random(id);
> }

NOTE
    isbound does not tell you if the attribute exists. It tells you if
    the attribute is bound. If you added an @a to a wrangle to bind the
    a, then isbound will work as you expect in CVEX. Without an @a,
    there is no parameter in your CVEX function to bind the attribute
    to, so it will be unbound.

RELATED

}

{
isconnected

Returns 1 if input_number is connected, or 0 if the input is not
connected.

USAGE
  int isconnected(int opinput)


texttype
    The input number to read from, starting from 0. For example, the
    first input is 0, the second input is 1, and so on.

    1 if <input_number> is connected, or 0 if the input is not
    connected.

RELATED

}

{
isdigit

Returns 1 if all the characters in the string are numeric

USAGE
  int isdigit(const string str)

Returns 1 if all the characters in the string are numeric (0-9). No
alphabetic characters, punctuation or other special characters. If any
are present then returns 0.

If passed the string "543.34", this function will return 0 because "."
is not a digit.

RELATED

  * isalpha

}

{
isfinite

Checks whether a value is a normal finite number.

USAGE
  int isfinite(float x)

Returns 1 if the given value is a normal, finite, number.

Returns 0 if it is a NAN or infinite. Note that VEX generally will not
produce these: 3/0 is defined as 0, for example.

RELATED

}

{
isfogray

Returns 1 if the shader is being called to evaluate illumination for fog
objects, or 0 if the light or shadow shader is being called to evaluate
surface illumination.

USAGE
  int isfogray()

Returns 1 if the shader is being called to evaluate illumination for fog
objects, or 0 if the light or shadow shader is being called to evaluate
surface illumination.

Use this function to simplify light shaders when evaluating for fog.

RELATED

}

{
isframes

Returns 1 if the Vex CHOP's Unit Menu is currently set to 'frames', 0
otherwise.

USAGE
  int isframes()

Returns 1 if the Vex CHOP's Unit Menu is currently set to 'frames', 0
otherwise.

RELATED

}

{
isnan

Checks whether a value is not a number.

USAGE
  int isnan(float x)

Returns 1 if the given value is not a number.

Returns 0 if it is a normal number or infinite.

NAN, or Not A Number, is a special value floating point numbers can be
set to to signal something has gone wrong in the computation. They are
carried forward by all further operations (adding or multiplying with
them produces more NANs) and tend to cause problems with downstream
operations.

In traditional programming, these are generated by 0/0 or sqrt(-1), but
in VEX most such operations are guarded so normally VEX will not produce
NANs.

RELATED

}

{
isotropic

Returns an isotropic BSDF, which scatters light equally in all
directions.

USAGE
  bsdf isotropic(...)
  The isotropic function scatters light equally in all directions and is
  suitable for use in rendering dense volumetric materials such as
  smoke. Note that no normal vector is required to construct an
  isotropic bsdf since it has no directionality. The default albedo for
  an isotropic bsdf is 1, which means the isotropic() function scatters
  100% of the incoming light.

RELATED

  * henyeygreenstein

  * specular

  * phong

  * Writing a PBR shader

}

{
israytracing

Indicates whether a shader is being executed for ray tracing.

USAGE
  int israytracing()

Returns true when the current shader is shading ray hits. For
micropolygon rendering, the return value will be false. This function
can be used to disambiguate shading styles for renders that use the
vm_rayshade property - where only some objects are ray traced.

RELATED

}

{
issamples

Returns 1 if the Vex CHOP's Unit Menu is currently set to 'samples', 0
otherwise.

USAGE
  int issamples()

Returns 1 if the Vex CHOP's Unit Menu is currently set to 'samples', 0
otherwise.

RELATED

}

{
isseconds

Returns 1 if the Vex CHOP's Unit Menu is currently set to 'seconds', 0
otherwise.

USAGE
  int isseconds()

Returns 1 if the Vex CHOP's Unit Menu is currently set to 'seconds', 0
otherwise.

RELATED

}

{
isshadowray

Returns 1 if the shader is being called to evaluate opacity for shadow
rays, or 0 if the shader is being called to evaluate for surface color.

USAGE
  int isshadowray()

Returns 1 if the shader is being called to evaluate opacity for shadow
rays, or 0 if the shader is being called to evaluate for surface color.

Use this function to compute different opacity if the surface is
shadowing another surface.

RELATED

}

{
istart

Returns the starting frame of the specified input.

USAGE
  int istart(int opinput)


texttype
    The input number to read from, starting from 0. For example, the
    first input is 0, the second input is 1, and so on.

    The starting frame of the specified input.

RELATED

}

{
istarttime

Returns the start time of the specified input.

USAGE
  float istarttime(int opinput)


texttype
    The input number to read from, starting from 0. For example, the
    first input is 0, the second input is 1, and so on.

    The start time of the specified input.

RELATED

}

{
isuvrendering

Indicats whether the shader is being evaulated while doing UV rendering
(e.g. texture unwrapping)

USAGE
  int isuvrendering()

Returns 1 if the shader is being called while evaluating uv rendering
(texture unwrapping), and 0 for normal rendering.

Use this function to evaluate shaders differently when baking
illumination.

RELATED

}

{
isvalidindex

Checks if the index given is valid for the array or string given.

USAGES
  int isvalidindex(<type> &array[], int index)
  int isvalidindex(string str, int index)
  Returns 1 if index is within range for the given string/array, or 0
  otherwise.

  This is equivalent to index < len(array) && index >= -len(array).

RELATED

  * Arrays

  * len

}

{
isvarying

Check whether a VEX variable is varying or uniform.

USAGES
  int isvarying(<type> x)
  int isvarying(<type> x[])

Returns 1 when the given variable is varying, or 0 when it is uniform. A
variable is varying when it may have a different value for each
processor in the VEX SIMD array. If a value is varying, shader execution
will generally be slower - so this function can be useful when debugging
shader performance. Any variable type can be passed to the isvarying()
function.

}

{
itoa

Converts an integer to a string.

USAGE
  string itoa(int number)

Converts an integer to a string.

RELATED

}

{
ixres

Returns the X resolution of the specified input.

USAGE
  int ixres(int opinput)


texttype
    The input number to read from, starting from 0. For example, the
    first input is 0, the second input is 1, and so on.

    The X resolution of the specified input.

RELATED

}

{
iyres

Returns the Y resolution of the specified input.

USAGE
  int iyres(int opinput)


texttype
    The input number to read from, starting from 0. For example, the
    first input is 0, the second input is 1, and so on.

    The Y resolution of the specified input.

RELATED

}

{
join

Concatenate all the strings of an array inserting a common spacer.

USAGE
  string join(const string s[]; const string spacer)

Concatenate all the strings in the array to form a single string. The
spacer will be placed between each pair of strings.

RELATED

}

{
kspline

Returns an interpolated value along a curve defined by a basis and
key/position pairs.

USAGES
  float kspline(string basis; float sample_pos; float value1, float
  key_pos1, ...)
  Samples a curve defined by a series of value/position pairs. This is
  useful for specifying a 1D data ramp.

  vector kspline(string basis; float sample_pos; vector value1, float
  key_pos1, ...)
  vector4 kspline(string basis; float sample_pos; vector4 value1, float
  key_pos1, ...)
  Samples a curve defined by a series of vector value/position pairs.
  This is useful for specifying a color ramp.

If you just want linearly spaced keys, or if you need to vary the basis,
use spline instead.


basis, bases
    These are the same interpolations supported by ramp parameters.


    "constant"
        Maintains each key value until the next key, creating a "stair
        step" curve.

    "linear"
        Connects the key points with a polyline.

        For example, if you specified four values:

      > spline("linear", t, v0, v1, v2, v3)


        ...the function returns the height of the orange dot at position
        <sample_pos>.

    "cubic" (or "catmullrom", "cspline")
        Connect the point values with a Catmull-Rom spline.

        Note that the first and last values are outside the sample area
        to provide the slope of the curve at the second point (at the
        start of the sample range) and the second-to-last point (at the
        end of the sample range).

        For example, if you specified six values:

      > spline("catrom", t, v0, v1, v2, v3, v4, v5)


        ...the function returns the height of the orange dot at position
        <t>.

        (This image is for illustration only, it does not show the
        correct curve for the shown points.)

    "linearsolve" (or "solvelinear")
        Maps between a set of non-uniform positions and a set of values.
        The kspline function does this mapping implicitly.

      > tk = spline("linearsolve", t, k0, k1, k2, k3, ...);
      > v = spline(basis, tk, v1, v2, v3, ...);

        (Technically, linearsolve interprets the values as key values,
        solves the intersection of the spline, and returns the intercept
        point.)

    "monotonecubic"

texttype
    The position along the curve at which to sample the value.

value<n>, key_pos<n>
    To define the shape of the curve, you pass a number of
    value/position pairs specifying the key points through which the
    curve passes.

    You must specify key positions in ascending order or the results
    will be unpredictable.


TIP
    The spline function is a more flexible superset of this function.

This function is the equivalent of:

> type kspline(basis, t, v0, k0, v1, k1, v2, k2...)
> {
>     float tk = spline("linearsolve", t, k0, k1, k2, ...);
>     return spline(basis, tk, v0, v1, v2, ...);
> }

RELATED

  * spline

}

{
len

Returns the length of an array.

USAGES
  int len(<vector> v)
  int len(<matrix> m)
  int len(<type> array[])
  int len(string s)
  Returns the number of items/components in the given object. For an
  array, this is the number of items in the array. For a matrix or
  vector, this is the number of components.

  For a string, this returns the number of _characters_ (not bytes).

  Don't confuse this function with length, which returns the magnitude
  of a vector.

EXAMPLES

  > len("hello") == 5;
  > len({ {1,0,0}, {0,1,0}, {0,0,1} }) == 9;
  > len({0, 10, 20, 30}) == 4;

RELATED

  * Arrays

  * resize

}

{
length

Returns the magnitude of a vector.

To get the length of a string, or number of items in an array, use len.

USAGES
  float length(float f)
  Simply returns the given number.

  float length(vector2 v)
  float length(vector v)
  float length(vector4 v)
  Returns the distance of the vector or vector4.

  If you want the squared length, using length2 is faster than squaring
  the result of this function.

EXAMPLES

  > length({1.0, 0, 0}) == 1.0;
  > length({1.0, 1.0, 0}) == 1.41421;

RELATED

  * length2

}

{
length2

Returns the squared distance of the vector or vector4.

USAGES
  float length2(vector2 v)
  float length2(vector v)
  float length2(vector4 v)
  Returns the squared distance of the vector.

EXAMPLES

  > length2({0.5, 0.75, 0}) == 0.8125;

RELATED

  * length

}

{
lerp

Performs bilinear interpolation between the values.

USAGES
  float lerp(float value1, float value2, float amount)
  Performs bilinear interpolation between the values.

  <vector> lerp(<vector> value1, <vector> value2, float amount)
  Performs bilinear interpolation between corresponding components.

  <vector> lerp(<vector> value1, <vector> value2, <vector> amount)
  Performs bilinear interpolation between corresponding components by
  specific amounts for each component pair.

  bsdf lerp( bsdf bsdf1; bsdf bsdf2; float amount)
  Returns a BSDF that linearly interpolates between the output of the
  two given BSDFS.


amount
    If the amount is outside the range 0 to 1, the values will be
    extrapolated linearly.

    If amount is 0, the first value is returned. If it is 1, the second
    value is returned.

RELATED

  * slerp

}

{
lightbounces

Returns the bounce mask for a light struct.

USAGE
  int lightbounces(light lp)

Returns the bounce mask for the light struct passed in. The bounce mask
is based on the light object's Lighting contribution parameter.

RELATED

  * getlight

}

{
lightid

Returns the light id for a light struct.

USAGE
  int lightid(light lp)

Returns the integer light identifier of the light struct passed in. The
function returns -1 if the argument is invalid.

RELATED

  * getlight

  * getlights

  * getlightname

}

{
limit_sample_space

Limits a unit value in a way that maintains uniformity and in-range
consistency.

USAGES
  float limit_sample_space(float minu, float maxu, float u)
  float limit_sample_space(float maxu, float u)


minu
    Minimum desired value of u. minu will be clamped to between 0 and 1.
    If not specified, minu is 0.

maxu
    Maximum desired value of u. maxu will be clamped to between 0 and 1.

u
    Number between 0 and 1.

If u is outside of [minu,maxu], u is wrapped in the space in such a way
that uniform random u in [0,1) will yield uniform random samples in
[minu,maxu] and returned. This avoids the extra samples at the bounds of
the range that clamping to the range would introduce. It also avoids the
changing of samples inside the range that fitting to the range would
introduce, i.e. if u is already in the range, the return value is
exactly u.

However, this is much slower than fitting or clamping, so only use it
when both uniformity and consistency are needed. For example, it can be
useful in avoiding outliers in probability distributions without
affecting samples that are not outliers. It also introduces the issue
that results will no longer be monotone increasing with respect to u.
Fitting will often suffice for avoiding outliers too, at the expense of
slightly affecting samples that are not outliers.

To find minu and maxu given a minvalue and maxvalue of some probability
distribution, minu = CDF(minvalue) and maxu = CDF(maxvalue), where CDF
is the cumulative distribution function (not inverse) of the probability
distribution. The versions of sample_exponential, sample_cauchy,
sample_normal, sample_lognormal, and sample_lognormal_by_median that
take a minvalue or maxvalue use fitting instead of this limiting,
because it maintains monotonicity, but this function can be applied to u
before sampling, in order to have better consistency for samples in the
range.

RELATED

  * sample_exponential

  * sample_cauchy

  * sample_normal

  * sample_lognormal

  * sample_lognormal_by_median

}

{
limport

Imports a variable from the light shader for the surface.


NOTE
    This function is only valid inside an illuminance loop.

USAGE
  int limport(const string name; <type> &value)


name
    The name of the shader variable to read.

&value
    If the named variable is defined and exported, the function
    overwrites this variable with the variable's value.

    Returns 1 if the shader variable is defined and exported, or 0
    otherwise.

RELATED

}

{
lkspline

Samples a polyline between the key points.

USAGES
  float lkspline( float sample_pos; float value1; float key_pos1; ... )
  Samples a polyline defined by a series of value/position pairs. This
  is useful for specifying a 1D data ramp.

  vector lkspline( float sample_pos; vector value1; float key_pos1; ...
  )
  vector4 lkspline( float sample_pos; vector4 value1; float key_pos1;
  ... )
  Samples a polyline defined by a series of vector value/position pairs.
  This is useful for specifying a color ramp.

If you just want linearly spaced keys, use lspline instead.


sample_pos
    The position along the curve at which to sample.

value<n>, key_pos<n>
    To define the shape of the curve, you pass a number of
    value/position pairs specifying the key points through which the
    curve passes.

    You must specify key positions in ascending order or the results
    will be unpredictable.

    The value of the curve at the sampled position.


TIP
    The spline function is a more flexible superset of this function.

RELATED

  * spline

  * kspline

}

{
log

Returns the natural logarithm of the argument.

USAGES
  float log(float n)
  <vector> log(<vector> v)
  Returns the natural logarithm of n. For vectors, this is done per-
  component.

RELATED

  * log10

}

{
log10

Returns the logarithm (base 10) of the argument.

USAGES
  float log10(float n)
  <vector> log10(<vector> n)
  Returns the base 10 logarithm of n. For vectors, this is done per-
  component.

RELATED

  * log

}

{
lookat

Computes a rotation matrix or angles to orient the z-axis along the
vector (to-from) under the transformation.

USAGES
  matrix3 lookat(vector from, vector to)
  matrix3 lookat(vector from, vector to, float roll)
  matrix3 lookat(vector from, vector to, vector up)
  vector lookat(vector from, vector to, float roll, int xyz)
  vector lookat(vector from, vector to, vector up, int xyz)

Computes a rotation matrix or angles to orient the z-axis along the
vector (to-from) under the transformation. If an up vector is specified,
this will determine the roll. xyz is a rotation order defined in
$HFS/houdini/support/vex/include/math.h.

RELATED

}

{
lspline

Samples a polyline defined by linearly spaced values.

USAGES
  float lspline(float sample_pos, float value1, ...)
  Samples a polyline defined by a series of (linearly spaced) values.
  This is useful for specifying a 1D data ramp.

  vector lspline(float sample_pos, vector value1, ...)
  vector4 lspline(float sample_pos, vector4 value1, ...)
  Samples a polyline defined by a series of (linearly spaced) vector
  values. This is useful for specifying a color ramp.

If you need variably-spaced keys, use lkspline instead.


texttype
    The position along the curve at which to sample the value.

value<n>
    To define the shape of the curve, you pass a number of values
    specifying the key points through which the curve passes. The
    function automatically spaces the keys evenly.


TIP
    The spline function is a more flexible superset of this function.

RELATED

  * spline

}

{
lstrip

Strips leading whitespace from a string.

USAGES
  string lstrip(string value)
  string lstrip(string value, string whitespace)

Returns a string with the leading whitespace removed. If whitespace is
provided, it is a string of characters that will be stripped.

RELATED

  * rstrip

  * strip

}

{
luminance

Compute the luminance of the RGB color specified by the parameters.

USAGES
  float luminance(const vector rgb)
  float luminance(const vector4 rgb)
  float luminance(const float r, float g, float b)

RELATED

}

{
lumname

Returns the default name of the luminence plane (as it appears in the
compositor preferences).

USAGE
  string lumname()

Returns the default name of the luminence plane (as it appears in the
compositor preferences). Using this instead of hardcoding the default
makes your code more portable. Default is "L".

RELATED

}

{
makebasis

Creates an orthonormal basis given a z-axis vector.

USAGES
  void makebasis(vector &xaxis, vector &yaxis, vector zaxis)
  void makebasis(vector &xaxis, vector &yaxis, vector zaxis, vector u)

Completes an orthonormal basis for the given zaxis vector consisting of
the xaxis and yaxis basis vectors. When only the zaxis vector is given,
the basis will have an arbitrary orientation. When a second vector u is
provided, the yaxis vector will be constrained so that it is aligned
with that vector.

}

{
maketransform

Builds a 3x3 or 4x4 transform matrix.

USAGES
  matrix3 maketransform(vector zaxis, vector yaxis)
  matrix maketransform(vector zaxis, vector yaxis, vector translate)
  matrix maketransform(int trs, int xyz; const vector t, vector r,
  vector s)
  matrix maketransform(int trs, int xyz; const vector t, vector r,
  vector s, vector p)
  matrix maketransform(int trs, int xyz; const vector t, vector r,
  vector s, vector p, vector pr)
  matrix maketransform(int trs, int xyz; const vector t, vector r,
  vector s, vector p, vector pr, vector shears)

Builds a 3x3 or 4x4 transform matrix.

maketransform(int trs, ...) builds a general 4x4 transform matrix given
an order of transformations (<trs>), an order for rotations (<xyz>), a
vector representing the translation (<t>), rotation (<r>), scale (<s>)
(and optionally a pivot (<p>), pivot rotatation (<pr>), and shears
(<shears>)). The specifications for the <trs> and <xyz> parameters can
be found in $HFS/houdini/vex/include/math.h

maketransform(vector zaxis, yaxis, ...) builds either a 3x3 transform
matrix or a 4x4 transform matrix. The matrix will be constructed so that
the z-axis will be transformed to the z-axis specified with the given up
vector (yaxis). Thus, maketransform({0,0,1}, {0,1,0}) will result in an
identity matrix. The version which returns a 4x4 transform will apply
the translation to the 4x4 matrix. This function is very similar to the
lookat function. The vectors passed in are _not_ normalized meaning that
scales should be preserved in construction of the transform.


NOTE
    Unlike most VEX function, this function expects rotations in
    _degrees_, not radians.

RELATED

}

{
mask_bsdf

Returns new BSDF that only includes the components specified by the
mask.

USAGE
  bsdf mask_bsdf(bsdf b, int mask)


b
    BSDF to mask.

mask
    A bitmask indicating which types of shading component bounces to
    evaluate.

    See bouncemask for information on component label bitmasks.

EXAMPLES

  > // outF will have every component from inF except refraction
  > bsdf outF = mask_bsdf(inF, PBR_ALL_MASK & ~PBR_REFRACT_MASK);

RELATED

  * albedo

  * eval_bsdf

  * sample_bsdf

}

{
maskname

Returns the default name of the mask plane (as it appears in the
compositor preferences).

USAGE
  string maskname()

Returns the default name of the mask plane (as it appears in the
compositor preferences). Using this instead of hardcoding the default
makes your code more portable. Default is "M".

RELATED

}

{
match

This function returns 1 if the subject matches the pattern specified, or
0 if the subject doesn't match.

USAGE
  int match(string pattern, string subject)

This function returns 1 if the subject matches the pattern specified, or
0 if the subject doesn't match. The standard Houdini pattern matching is
used. Multiple patterns may be separated by spaces or commas. The
special characters for matching are:

  * ? Match any character

  * * Match any substring

  * [list] Match any of the characters specified in the list.

  * If a pattern is prefixed by a caret (^), then subjects which match
    this pattern will be excluded from the match.

Examples:

  * a* - Match any string beginning with a.

  * a*,^aardvark - Match any string beginning with a except for
    aardvark.

  * [abc]*z - Match any string beginning with a, b or c and ending with
    z.

  * g*,^geo* - Match any string beginning with g, but not any string
    beginning with geo.

RELATED

}

{
matchvex_blinn

Returns a BSDF that matches the output of the traditional VEX blinn
function.

USAGES
  bsdf matchvex_blinn(float exponent, ...)
  bsdf matchvex_blinn(vector nml, float exponent, ...)


The BSDF produced by blinn is not the same as the traditional VEX
blinn() output. Use this function to produce a closer approximate match
to the traditional VEX blinn().

RELATED

  * blinn

  * Writing a PBR shader

}

{
matchvex_specular

Returns a BSDF that matches the output of the traditional VEX specular
function.

USAGES
  bsdf matchvex_specular(float exponent, ...)
  bsdf matchvex_specular(vector nml, float exponent, ...)


The BSDF produced by specular is not the same as the traditional VEX
specular() output. Use this function to produce a closer approximate
match to the traditional VEX specular().

RELATED

  * specular

  * Writing a PBR shader

}

{
mattrib

Returns the value of the point attribute for the metaballs if metaball
geometry is specified to i3dgen.

USAGE
  <type> mattrib(string name, vector P)


NOTE
    The image3d context is deprecated. Use volumes instead.

RELATED

}

{
max

USAGES
  int max(int value1, int value2, ...)
  float max(float value1, float value2, ...)
  Returns the maximum value of the arguments.

  <vector> max(<vector> value1, <vector> value2, ...)
  Returns a vector where each component is the maximum of the
  corresponding components in the arguments.

  <type> max(<type> values[])
  Returns the maximum value in the array.

  float max(<vector> values)
  Returns the maximum of the vector's components.

  <type> max(<type> value)
  Returns the argument.

RELATED

  * min

}

{
mdensity

Returns the density of the metaball field if metaball geometry is
specified to i3dgen.

USAGE
  float mdensity(vector P)

Returns the density of the metaball field if metaball geometry is
specified to i3dgen.

RELATED

}

{
metadata

Returns a metadata value from a composite operator.

USAGES
  <type> metadata(int opinput, string name)
  float|int metadata(int opinput, string name, int index)

Returns the metadata value associated with metadata name, or zero if the
metadata doesn't exist, the input isn't connected, or the index is out
of range (identity matrices for the matrix versions).


texttype
    The input number to read from, starting from 0. For example, the
    first input is 0, the second input is 1, and so on.

name
    The name of the metadata to fetch.

index
    For compound data types, this indicates the component of the
    vector/matrix, or which item of the array, to fetch.

:

  * hasmetadata

  * cinput

  * binput

  * finput

  * ninput

}

{
metaimport

Once you get a handle to a metaball using metastart and metanext, you
can query attributes of the metaball with metaimport.

USAGES
  int metaimport(int handle, string attrib, vector P, <type> &value)
  <type>[] metaimport(string file, string attribute; vector P)
  Rather than iterating over all the values, this form imports the
  values from all metaballs simultaneously. As with the scalar form, you
  can use the keywords...

  * meta:density

  * meta:prim

  * meta:transform

  ...to import non-attribute information from the metaballs.

Once you get a handle to a metaball using metastart and metanext, you
can query attributes of the metaball with metaimport.

There are three "special" attributes you can query:

float meta:density : The density of the current metaball

float meta:prim : The primitive number of the current metaball

matrix meta:transform : The transform associated with the current
metaball. Applying the inverse of this transform will transform a point
into the "space" of the metaball.

For example, the metaweight function can be expressed in the following
way:

> float
> metaweight(string file; vector P)
> {
> int        handle;
> float    density, tmp;
> 
> density = 0;
> handle = metastart(file, P);
> while (metanext(handle))
> {
> if (metaimport(handle, "meta:density", P, tmp))
> density += tmp;
> }
> return density;
> }

The attributes evaluated are un-premultiplied by the weight of the
metaball at the position and must be multiped for blending. For example,
to evaluate a vector attribute (say color) on metaballs, the following
function could be used:

> vector
> meta_attribute(string file, attrib_name; vector P)
> {
> int        handle;
> vector    result, tmp;
> float    density;
> 
> handle = metastart(file, P);
> result = 0;
> while (metanext(handle))
> {
> if (metaimport(handle, "meta:density", P, density))
> {
> if (metaimport(handle, attrib_name, P, tmp))
> result += density * tmp;
> }
> return result;
> }

In the i3d context, there is a default metaball geometry (specified by
the -g option on the command line to the i3dgen program). If the
filename is an empty string, the default geometry will be used.

RELATED

}

{
metamarch

Takes the ray defined by p0 and p1 and partitions it into zero or more
sub-intervals where each interval intersects a cluster of metaballs from
filename.

USAGE
  int metamarch(int &index, string filename, vector &p0, vector &p1,
  float displace_bound)

Takes the ray defined by <p0> and <p1> and partitions it into zero or
more sub-intervals where each interval intersects a cluster of metaballs
from <filename>. The interval may not actually intersect any metaballs,
but will provide fairly tight bounds on the cluster.

This allows a ray-marching algorithm to "skip" uninteresting areas and
only focus on marching through areas where metaballs might be found.

The first time you call the function, use <index>=-1 and set <p0> and
<p1> to the endpoints of the ray. If the function finds an interval, it
returns 1 and sets <p0> and <p1> to the endpoints of the interval and
increments <index>. Otherwise it returns 0 and doesn't alter the
arguments.

So, you can repeatedly call the function with variables for the <index>,
<index>, and <index> arguments to ray-march through areas of interest,
skipping the dead space:

> int    index;
> vector    p0, p1;
> // Initialize input values
> index = -1;
> p0 = Eye; p1 = P;
> result = 0;
> while (metamarch(index, metaball_file, p0, p1, displace_bound))
> {
> result += ray_march(metaball_file, p0, p1);
> }

RELATED

}

{
metanext

Iterate to the next metaball in the list of metaballs returned by the
metastart() function.

USAGE
  int metanext(int handle)

This iterates through the list of metaballs returned by metastart(). The
function returns 0 if there are no further metaballs in selected by
metastart().

RELATED

  * metastart

  * metadata

  * metaimport

  * metamarch

  * metaweight

}

{
metastart

Open a geometry file and return a "handle" for the metaballs of
interest, at the position p.

USAGE
  int metastart(string filename, vector p)

Open a geometry file and return a "handle" for the metaballs of
interest, at the position <p>. You can then use metanext to move the
handle to the next metaball for evaluation, and metaimport to query
attributes of the metaball.

RELATED

}

{
metaweight

Returns the metaweight of the geometry at position p.

USAGE
  float metaweight(string filename, vector p)

Returns the metaweight of the geometry at position <p>.

RELATED

}

{
min

USAGES
  int min(int value1, int value2, ...)
  float min(float value1, float value2, ...)
  Returns the minimum of the arguments.

  <vector> min(<vector> value1, <vector> value2, ...)
  Returns a vector where each component is the minimum of the
  corresponding components in the arguments.

  <type> min(<type> values[])
  Returns the minimum value in the array.

  float min(<vector> v)
  Returns the minimum of the vector's components.

  <type> min(<type> value)
  Returns the argument.

RELATED

  * max

}

{
minpos

Finds the closest position on the surface of a geometry.

USAGES
  vector minpos(<geometry>, vector point)
  Returns the position of the closest point in the given geometry to the
  point.

  vector minpos(<geometry>, vector point, float maxdist)
  Returns the position of the closest point in the given geometry to the
  point, within the <maxdist> radius.

  vector minpos(<geometry>, string primgroup, vector point)
  Returns the position of the closest point in the given geometry to the
  point, limiting the search to primitives in the named group.

  vector minpos(<geometry>, string primgroup, vector point, float
  maxdist)
  Returns the position of the closest point in the given geometry to the
  point, limiting the search to primitives in the named group and to the
  <maxdist> radius.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

primgroup
    If specified, only report points on You can also use group
    specification syntax like @Cd.x>0, but note that the @ may need to
    be escaped with a backslash in a Wrangle snippet. An empty string
    matches all primitives.

point
    The point in world space to start looking for the closest point on
    the geometry.

maxdist
    The maximum distance to search. Specifying this can speed up the
    function since it may allow quitting the search early.

    The position of the nearest point on the geometry, or <point> if no
    nearest point was found.

RELATED

}

{
mspace

Transforms the position specified into the "local" space of the
metaball.

USAGE
  vector mspace(vector P)

Transforms the position specified into the "local" space of the
metaball. This function is only valid inside the forpoints loop
construct.

An example use of this function would be to compute noise based on a
"rest" position... For example:

> forpoints(P) {
> vector npos = mspace(P) - mattrib("rest", P);
> nval += noise(npos);
> }

RELATED

}

{
mwnoise

Generates Worley (cellular) noise using a Manhattan distance metric.

USAGES
  void mwnoise( float position; int &seed; float &f1; float &f2 )
  void mwnoise( float position; int &seed; float &f1; float &f2; float
  &f3; float &f4 )
  Generates 1D noise.

  void mwnoise( float position; int &seed; float &f1; float &f2; int
  peiod)
  void mwnoise( float position; int &seed; float &f1; float &f2; float
  &f4; float &f4; int period)
  Generates periodic 1D noise.

  void mwnoise( float posx; float posy; int &seed; float &f1; float &f2
  )
  void mwnoise( float posx; float posy; int &seed; float &f1; float &f2;
  float &f3; float &f4 )
  Generates 2D noise. This is similar to the other forms but uses pairs
  of floats instead of a vector.

  void mwnoise( float posx; float posy; int &seed; float &f1; float &f2;
  int periodx; int periody )
  void mwnoise( float posx; float posy; int &seed; float &f1; float &f2;
  float &f3; float &f4; int periodx; int periody)
  Generates periodic 2D noise.

  void mwnoise( vector2 position; int &seed; float &f1; float &f2 )
  void mwnoise( vector2 position; int &seed; float &f1; float &f2; float
  &f3; float &f4 )
  Generates 2D noise.

  void mwnoise( vector2 position; int &seed; float &f1; float &f2; int
  periodx; int periody )
  void mwnoise( vector2 position; int &seed; float &f1; float &f2; float
  &f3; float &f4; int periodx; int periody)
  Generates periodic 2D noise.

  void mwnoise( vector position; int &seed; float &f1; float &f2 )
  void mwnoise( vector position; int &seed; float &f1; float &f2; float
  &f3; float &f4 )
  Generates 3D noise.

  void mwnoise( vector position; int &seed; float &f1; float &f2; int
  periodx; int periody; int periodx )
  void mwnoise( vector position; int &seed; float &f1; float &f2; float
  &f3; float &f4; int periodx; int periody; int periodz )
  Generates periodic 3D noise.

  void mwnoise( vector4 position; int &seed; float &f1; float &f2 )
  void mwnoise( vector4 position; int &seed; float &f1; float &f2; float
  &f3; float &f4 )
  Generates 4D noise.

  void mwnoise( vector4 position; int &seed; float &f1; float &f2; int
  periodx; int periody; int periodz; int periodw )
  void mwnoise( vector4 position; int &seed; float &f1; float &f2; float
  &f3; float &f4; int periodx; int periody; int periodz; int periodw )
  Generates periodic 4D noise.


position
    The position at which to sample the noise.

seed
    Outputs an integer value associated with the nearest seed point.
    This seed is pretty much guaranteed to be unique for every point
    (meaning that it's unlikely that two points close by have the same
    seed associated with them).

f1, f2, f3, f4
    These variables are overwritten with the distances to the nearest
    seed points, in order of closeness.

    You can combine these distances to generate noise patterns. The
    noise generated tends to be very "cellular" in nature. In fact, one
    of the nice things is that you can determine "cell" boundaries by
    using the expression: if (f2 - f1) which will be true if the point
    in space is crossing the boundary between two cells.

period, periodx, periody, periodz, periodw
    If you include the period argument(s), the function generates
    repeating (periodic) noise.

Worley noise scatters seed points randomly through space (according to a
nice Poisson distribution). The functions outputs the distances to the 2
(or 4) seed points nearest to the sample position.

RELATED

  * Noise and randomness

  * anoise

  * curlnoise

  * flownoise

  * noise

  * onoise

  * pnoise

  * snoise

  * vnoise

  * wnoise

  * xnoise

}

{
nametopoint

Finds a point by its name attribute.

USAGE
  int nametopoint(<geometry>, string name)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

    The number of the point with the given value in the name attribute.
    Returns -1 if no primitive has the given ID, or if the geometry has
    no name attribute.

To look up a primitive by its id attribute value, use idtoprim. To look
up a point by an arbitrary string or int attribute value, use
findattribval.

RELATED

  * idtoprim

  * nametopoint

  * findattribval

}

{
nametoprim

Finds a primitive by its name attribute.

USAGE
  int nametoprim(<geometry>, string name)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

    The number of the point with the given value in the name attribute.
    Returns -1 if no point has the given ID, or if the geometry has no
    name attribute.

To look up a point by its id attribute value, use idtopoint. To look up
a point by an arbitrary string or int attribute value, use
findattribval.

RELATED

  * idtopoint

  * nametoprim

  * findattribval

}

{
nbouncetypes

USAGE
  int nbouncetypes()

Return the number of different bounce types supported by the renderer.

See bouncemask for information on component label bitmasks.

RELATED

  * bouncemask

  * getbounces

}

{
nearpoint

Finds the closest point in a geometry.

USAGES
  int nearpoint(<geometry>, vector pt)
  int nearpoint(<geometry>, vector pt, float maxdist)
  int nearpoint(<geometry>, string ptgroup, vector pt)
  int nearpoint(<geometry>, string ptgroup, vector pt, float maxdist)

Returns the number of the closest point on the geometry. This will only
search against points, not the surface locations of the geometry. Use
xyzdist to find the closest point on surfaces or curves.

-1 is returned if no point is found in the search distance.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

ptgroup
    A point group pattern to limit the search to. Can be a SOP-style
    group pattern such as 0-10 or @Cd.x>0.5. An empty string will match
    all points.

pt
    The position in space to find the closest point on the geometry to.

maxdist
    The maximum distance to search. The operation can be sped up if it
    is allowed to quit early.

RELATED

  * nearpoints

  * pcfind

  * pcfind_radius

  * pgfind

}

{
nearpoints

Finds the all the closest point in a geometry.

USAGES
  int[] nearpoints(<geometry>, vector pt, float maxdist)
  int[] nearpoints(<geometry>, vector pt, float maxdist, int maxpts)
  int[] nearpoints(<geometry>, string ptgroup, vector pt, float maxdist)
  int[] nearpoints(<geometry>, string ptgroup, vector pt, float maxdist,
  int maxpts)


opinput
    The number of the input to the current node, starting with 0 being
    the first input.

geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be "op:full_path_to_sop" to reference a SOP.

ptgroup
    A point group pattern to limit the search to. Can be a SOP-style
    group pattern such as 0-10 or @Cd.x>0.5. An empty string will match
    all points.

pt
    The position in space to find the closest point on the geometry to.

maxdist
    The maximum distance to search.

maxpts
    The maximum number of points to find.

    An array of point numbers This will only search against points, not
    the surface locations of the geometry. Use xyzdist to find the
    closest point on surfaces or curves.

RELATED

  * nearpoint

  * pcfind

  * pcfind_radius

  * pgfind

}

{
nedgesgroup

Returns the number of edges in the group.

USAGES
  int nedgesgroup(string filename, string groupname)
  int nedgesgroup(int input, string groupname)

Returns the number of edges in the specified group in the input or
geometry file.

This must refer to an exact group name, not an adhoc group pattern.

RELATED

  * expandedgegroup

  * inedgegroup

}

{
neighbour

Returns the point number of the next point connected to a given point.

This function lets you walk the points connected to a point (for
example, in the same polygon). Note that "closest" below refers to
connectivity, not physical distance. To get a list of all connected
points at once, use neighbours.

USAGE
  int neighbour(<geometry>, int point_num, int neighbour_num)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

point_num
    The number of the point whose neighbours you want to find.

neighbour_num
    Which neighbour to find. 0 is the closest connected point, 1 is the
    next-closest neighbour, and so on. Use neighbourcoount() to get the
    total number of connected points.

    The point index of the neighbour of the point. The order is
    undefined, but will be consistent for consistent geometry. Returns
    -1 if the neighbournum is out of range for that point, or the point
    is out of range for that input, or the input doesn't exist.

RELATED

  * neighbourcount

  * neighbours

}

{
neighbourcount

Returns the number of points that are connected to the specified point.

USAGE
  int neighbourcount(<geometry>, int point_num)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

point_num
    The number of the point whose neighbours you want to count.

    The number of points that are connected to the specified point. A
    point is connected if it is adjacent in some polygon, or is one of
    the four surrounding points in a grid or NURBs surface. Returns 0 if
    there is no input, or if the point number is out of range.

RELATED

}

{
neighbours

Returns an array of the point numbers of the neighbours of a point.

USAGE
  int[] neighbours(<geometry>, int ptnum)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

This is a simpler, array-based replacement for the combination of
neighbourcount and neighbour.

EXAMPLES

    This is roughly equivalent to the following code:

  > int []
  > neighbours(int opinput, int ptnum)
  > {
  >     int     i, n;
  >     int     result[];
  >     n = neighbourcount(input, ptnum);
  >     resize(result, n);
  >     for (i = 0; i < n; i++)
  >         result[i] = neighbour(input, ptnum, i);
  > }

RELATED

  * neighbourcount

  * neighbour

}

{
newgroup

WARNING
    This function has been deprecated. Use addattrib instead.

}

{
newsampler

Initializes a sampling sequence for the nextsample function.

USAGES
  int newsampler(...)
  int newsampler(int seed, ...)
  Returns an initialized sampler sequence for use as the first argument
  to the nextsample function.


seed
    You can specify a seed value for the sequence. Using the same seed
    will generate the same sequence. This can be useful when random
    sampling into a point cloud, for consistent results.

RELATED

  * nextsample

}

{
nextsample

USAGES
  void nextsample(int &sid, float &sx, float &sy, ...)
  void nextsample(int &sid, vector &svec, ...)

newsampler and this function expose the high-quality deterministic
sampling patterns used by mantra for pixel anti-aliasing. When rendering
in raytracing mode, it's possible to generate deterministic 2D samples
with nextsample routine by initializing the sampling sequence with the
SID global variable.

This method can generate either 2D or 3D sampling patterns. To generate
2D samples, use the signature with 2 float write-only arguments. To
generate 3D samples, use the signature with a vector write-only
argument.

You can add an extra argument, "mode", followed by one of the following:


"qstrat"
    Advances to the next sample in the pattern. You should use this mode
    when using newsampler.

"nextpixel"
    Advances to a new pixel sampling pattern. You should use this mode
    when using SID with raytracing to generate good-quality sampling
    patterns within a pixel. This mode takes into account other samples
    within the current pixel and will appropriately stratify itself. If
    rendering with micropolygon rendering, "nextpixel" will behave the
    same as "qstrat".

"decorrelate"
    Advances to a new decorrelated sample. You should use this mode to
    deterministically generate a new sampling sequence that is unrelated
    to an existing sequence. Similarly to "nextpixel", this mode
    preserves high-quality pixel sampling when used with SID and
    raytracing.

> int nsamples = 10;
> int sid = israytrace ? SID : newsampler();
> 
> for (i = 0; i < nsamples; i++)
> {
> if (israytrace)
> nextsample(sid, sx, sy, "mode", "nextpixel");
> else
> nextsample(sid, sx, sy, "mode", "qstrat");
> // Sample something using sx/sy...
> }

RELATED

  * newsampler

}

{
ninput

Reads a component from a pixel and its eight neighbors.

USAGES
  matrix3 ninput(int opinput, int plane, int component, int array_index,
  int u, int v, int frame, ...)
  matrix3 ninput(int opinput, int plane, int component, int array_index;
  float u, float v; int frame, ...)

Reads the given component from the targeted pixel and its eight
neighbors and returns them in a 3x3 matrix. Note that this function only
reads one component (for example, red, green, or blue) at a time. To
sample full color, you need to call the function three times with
component set to 0, 1, and 2.


texttype
    The input number to read from, starting from 0. For example, the
    first input is 0, the second input is 1, and so on.

plane
    The index of the plane to read from.

component
    The index of the component to read from. For example, 0 is red, 1 is
    green, 2 is blue in an RGB plane.

texttype
    For use if the plane has array values. Generally, just pass 0 here.

u, v
    If you give floating point UVs, the values are interpreted as unit
    (0-1) values. For example, 0.5, 0.5 would be the center of the
    image. If you give integer UVs, the values are in pixels, ranging
    from 0,0 to XRES-1, YRES-1.

RELATED

  * binput

  * cinput

  * finput

}

{
ninputs

Returns the number of inputs.

USAGE
  int ninputs()

Returns the number of inputs on the current node.

RELATED

}

{
noise

There are two forms of Perlin-style noise: a non-periodic noise which
changes randomly throughout N-dimensional space, and a periodic form
which repeats over a given range of space.

USAGES
  float noise(float pos)
  vector noise(float pos)
  Sample one or three numbers at the given position from 1D noise.

  float noise(float posx, float posy)
  vector noise(float posx, float posy)
  Sample one or three numbers at the given position from 2D noise.

  float noise(vector pos)
  vector noise(vector pos)
  Sample one or three numbers at the given position from 3D noise.

  float noise(vector4 pos)
  vector noise(vector4 pos)
  Sample one or three numbers at the given position from 4D noise.

There are two forms of Perlin-style noise: a non-periodic noise which
changes randomly throughout N-dimensional space, and a periodic form
which repeats over a given range of space.


NOTE
    This function generates non-periodic noise. Use the pnoise function
    to generate periodic Perlin noise.

The various functions return the noise value at a 4D (vector4 argument),
3D (vector argument), 2D (two float arguments) or 1D (float argument)
position. You can get a random float value or a vector of three random
values.

The noise is in the range 0-1 with a median of 0.5. The distribution of
the noise depends on the dimension, with higher dimensions approaching a
Gaussian distribution of noise values.

RELATED

  * Noise and randomness

  * anoise

  * curlnoise

  * flownoise

  * noise

  * onoise

  * pnoise

  * snoise

  * vnoise

  * wnoise

  * xnoise

}

{
noised

Derivatives of Perlin Noise.

USAGES
  void noised(float x, float &v, float &dvdx)
  void noised(float x, vector &v, vector &dvdx)
  void noised(float x, float y, float &v, float &dvdx, float &dvdy)
  void noised(float x, float y, vector &v, vector &dvdx, vector &dvdy)
  void noised(vector xyz, float &v, float &dvdx, float &dvdy, float
  &dvdz)
  void noised(vector xyz, vector &v, vector &dvdx, vector &dvdy, vector
  &dvdz)
  void noised(vector4 xyzw, float &v, float &dvdx, float &dvdy, float
  &dvdz, float &dvdw)
  void noised(vector4 xyzw, vector &v, vector &dvdx, vector &dvdy,
  vector &dvdz, vector &dvdw)

This computes both the perlin noise value, and the derivatives of the
noise along each axis. This can be performed quite efficiently as there
are analytic derivatives available.

See noise and randomness in the VEX language guide for more information.

RELATED

  * noise

}

{
normal_bsdf

Returns the normal for the diffuse component of a BSDF.

USAGE
  vector normal_bsdf(bsdf b)

RELATED

  * albedo

  * eval_bsdf

  * sample_bsdf

}

{
normalize

Returns a normalized vector.

USAGE
  <vector> normalize(<vector> v)

Returns the normalized version of v.

RELATED

}

{
normalname

Returns the default name of the normal plane (as it appears in the
compositor preferences).

USAGE
  string normalname()

Returns the default name of the normal plane (as it appears in the
compositor preferences). Using this instead of hardcoding the default
makes your code more portable. Default is "N".

RELATED

}

{
npoints

Returns the number of points in the input or geometry file.

USAGE
  int npoints(<geometry>)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

RELATED

}

{
npointsgroup

Returns the number of points in the group.

USAGE
  int npointsgroup(<geometry>, string groupname)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

groupname
    This must refer to an exact group name, not an adhoc group pattern.

RELATED

  * expandpointgroup

  * inpointgroup

  * hasattrib

}

{
nprimitives

Returns the number of primitives in the input or geometry file.

USAGE
  int nprimitives(<geometry>)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

RELATED

}

{
nprimitivesgroup

Returns the number of primitives in the group.

USAGE
  int nprimitivesgroup(<geometry>, string groupname)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

groupname
    This must refer to an exact group name, not an adhoc group pattern.

RELATED

  * expandprimgroup

  * inprimgroup

  * hasattrib

}

{
nrandom

Non-deterministic random number generation function.

USAGES
  float nrandom(...)
  vector nrandom(...)
  vector4 nrandom(...)
  Returns a random number between 0 and 1, or a random unit vector.

  void nrandom(float &x, float &y, ...)
  Overwrites the given variables with random numbers between 0 and 1.

These random generators will generate the same sequence of random
numbers if called in precisely the same order. However, there is no seed
involved so it is not possible to reproduce the same random number or
sequence multiple times.


...
    You can optionally specify a string argument to choose the random
    number generation method. The string may be one of:

  * default: Efficient random number generation. This method is backward
    compatible with previous releases of Houdini.

  * mersenne or twister: Uses the Mersenne Twister which has some very
    nice properties. This code is based of the work of: Copyright (C)
    1997

  * 2002, Makoto Matsumoto and Takuji Nishimura, All rights reserved.

  * qstrat: Uses a quasi-stratified random number generator. This tends
    to distribute the random numbers evenly, reducing clumping and
    spacing.

RELATED

}

{
ntransform

Transforms a normal vector.

USAGES
  vector ntransform(vector v, matrix transform)
  vector ntransform(string tospace, vector v)
  vector ntransform(string fromspace, string tospace, vector v)

Transforms a vector representing a normal. See ptransform for more
information.

RELATED

  * vtransform

  * ptransform

  * getspace

}

{
nuniqueval

Returns the number of unique values from an integer or string attribute.

USAGE
  int nuniqueval( <geometry>, string attribclass, string attribute_name)

Returns the number of _unique_ values across all values of an attribute.
You can use uniqueval to iterate though the set of unique values.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

texttype
    One of "detail" (or "global"), "point", "prim", or "vertex".

    You can also use "primgroup", "pointgroup" or "vertexgroup" to read
    from groups.

EXAMPLES


    Test if all values of the point attribute foo are unique
      > int test = nuniqueval(0, "point", "foo") == npoints(0)

RELATED

  * uniqueval

}

{
nvertices

Returns the number of vertices in the input or geometry file.

USAGE
  int nvertices(<geometry>)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

RELATED

}

{
nverticesgroup

Returns the number of vertices in the group.

USAGE
  int nverticesgroup(<geometry>, string groupname)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

groupname
    This must refer to an exact group name, not an adhoc group pattern.

RELATED

}

{
occlusion

Computes ambient occlusion.

USAGES
  vector occlusion(vector P, vector N, ...)
  Computes ambient occlusion at the point P with the normal N. Just as
  in the irradiance function, the hemisphere is sampled. However, unlike
  irradiance, surfaces intersected during the hemisphere sampling are
  not shaded. For this function to work properly, either a constant
  background color or an environment map must be specified in the
  optional scope parameters.

  void occlusion(float &coverage, vector &missed_direction, vector P,
  vector N, ...)
  Instead of computing color information from ambient occlusion, this
  form computes the coverage (the percentage of occlusion) and the
  average direction of empty space. The average direction can be used to
  look up the color in a pre-blurred environment map.

SAMPLE ADAPTATION OPTIONS


    adaptive
        1 or 0. Turns on an automatic optimization that will reduce the
        number of samples when there is little variation in occlusion
        above the sample point. This can improve performance at the
        expense of some possible flickering or additional noise.


RAY OPTIONS


    TIP
        When you specify a texture, such as with the "environment"
        keyword, you can also use the image filtering keyword arguments.
        See environment for a listing of the image filter keyword
        arguments.


    scope
        A list of objects which can be hit by the rays. When specified,
        scope overrides the default scope that would have been selected
        for the given raystyle. The "scope:default" value will cause the
        scope argument to use the default scope for the current context
        - as if the argument were not specified.

        Allows an override of the scope for ray-intersections. A special
        scope argument, scope:self, will match the currently shading
        object.

    maxdist
        The maximum distance to search for objects. This can be used to
        limit the search of objects to nearby objects only. If the
        maxdist given is negative, then it will act as if there is no
        maximum distance.

        Allows an override of the maximum distance the ray can travel
        when testing for intersections. Some functions (such as
        fastshadow) have the maximum distance implicitly defined (by the
        length of the ray) and should probably avoid using this option.
        However, this option can be used effectively when computing
        reflections, global illumination, refraction etc.

    variancevar
        The name of a VEX export variable to use for variance anti-
        aliasing. The renderer compares the value with adjacent
        micropolygons in micropolygon rendering to decide what shading
        points need additional samples (using vm_variance property as a
        threshold). If more samples are required, the algorithm takes
        samples up to the specified maximum ray samples.

        This variable must be imported from the hit surface, so it must
        be in the list of imported names (see "importing information
        back from the ray" below). If the named variable is not
        imported, this option will be ignored.

        Variance antialiasing puts more samples in areas of the image
        with high variance, for example a sharp shadow edge. It is only
        used when vm_dorayvariance is enabled. Otherwise, only the min
        ray samples (or an explicitly supplied "samples" value) are used
        for antialiasing of the gather loop.

        Overrides the global variance control (mantra's -v option) which
        is used to determine anti-aliasing quality of ray tracing. For
        more information please refer to the documentation on mantra.

    angle
        The distribution angle (specified in radians). For gather(),
        rays will be distributed over this angle. For trace(), the angle
        is used to indicate the rate at which the filter width should
        increase with increasing intersection distance. Larger angles
        will cause farther hit surfaces to use larger derivatives,
        leading to improved texturing and displacement performance.

        To be effective, the samples parameter should also be specified.

    samples
        How many samples should be sent out to filter rays. For the
        irradiance and occlusion functions, specifying a samples
        parameter will override the default irradiance sampling.

    environment
        If the ray sent out to the scene misses everything, then it's
        possible to specify an environment map to evaluate.

        Using the ray's direction, the environment map specified will be
        evaluated and the resulting color will be returned. Most likely,
        it will be necessary to specify a transform space for the
        environment map evaluations.

        In the case of refractlight and trace the Of and Af variables
        will be set to 0 regardless of the background color specified.
        the resulting color.

        When an environment map is specified, the filtering options from
        texture() are also supported.

        See how to create an environment/reflection map.

    envobject
        If an environment map is used, the orientation of the
        environment map can be specified by transforming the ray into
        the space of another object, light or fog object in the scene.
        In Houdini, null objects can be used to specify the orientation.
        For example:

      > Cf = R*reflectlight(bias, max(R), "environment", "map.rat", "envobject", "null_object_name");

    envlight
        If an environment map is used, the orientation of the
        environment map can be specified by transforming the ray into
        the space of a light in the scene.

    envtint
        If an environment map is used, tint it with this color.

    background
        If a ray misses all objects, use this as the background color of
        the scene. In the case of refractlight and trace the Of and Af
        variables will be set to 0 regardless of the background color
        specified.

    distribution
        *Functions*: irradiance, occlusion

        Distribution for computing irradiance. The default is to use a
        cosine distribution (diffuse illumination). The possible values
        for the style are "nonweighted" for uniform sampling or "cosine"
        for cosine weighted sampling.

RELATED

  * irradiance

  * pathtrace

}

{
ocean_sample

Evaluates an ocean spectrum and samples the result at a given time and
location.

USAGE
  vector ocean_sample(string geometry, int phase, int frequency, int
  amplitude, float hscale, float time, int mode, int downsample, vector
  pos)

Evaluates the input ocean spectrum at the given time and position and
returns the value specified by mode. The input is typically the output
of the Ocean Spectrum SOP.


geometry
    The name of the geometry file to reference. Inside Houdini, this may
    be op:full_path_to_sop to reference a SOP.

phase
    The primitive number of the volume representing wave phase.

frequency
    The primitive number of the volume representing wave frequency.

amplitude
    The primitive number of the volume representing wave amplitude.

hscale
    The amount to scale any horizontal motion in the ocean waves.

mode
    The type of value to sample from the ocean spectrum, where 0 means
    displacement, 1 means velocity, and 2 means horizontal spatial
    derivatives.

downsample
    The number of times to downsample the input spectrum before
    evaluation. Each downsample level halves the resolution of the
    input.

pos
    The position in object space at which to sample the evaluated ocean.

EXAMPLES

    Displace the point position by an ocean spectrum stored in a file.

  > @P += ocean_sample("spectrum.bgeo", 0, 1, 2, 0.7, @Time, 0, 0, @P);

RELATED

  * Ocean Spectrum

}

{
ocio_activedisplays

Returns the names of active displays supported in Open Color IO

USAGE
  string [] ocio_activedisplays()

Returns a list of names of the active displays supported by Open Color
IO in Houdini.

RELATED

}

{
ocio_activeviews

Returns the names of active views supported in Open Color IO

USAGE
  string [] ocio_activeviews()

Returns a list of names of the active views supported by Open Color IO
in Houdini.

RELATED

}

{
ocio_import

Imports attributes from OpenColorIO spaces.

USAGES
  int ocio_import(string space, string property; int &value)
  int ocio_import(string space, string property; vector &value)
  int ocio_import(string space, string property; string &value)

This function queries data associated with a color space.

If the function fails, the <value> variable will not be modified, and
may be left uninitialized.

QUERYABLE ATTRIBUTES

    There list of properties includes most of the properties defined in
    the OCIO configuration file:


    string name
        The name of the color space.

    string family
        The color space family.

    string equalitygroup
        The equality group for the color space.

    string description
        A description of the color space.

    int isdata
        True if the color space is suitable for non-color pixel data
        (such as normals, point positions, etc.)

    string bitdepth
        A string representing the color space bit depth.

    string allocation
        Either uniform or lg2 (log2).

    vector allocationvars
        The allocation variables (min, max, offset).

EXAMPLES

  > 
  > cvex test()
  > {
  >     string        token;
  >     string        sval;
  >     int                ival;
  >     vector        vval;
  > 
  >     // Color spaces may be specified by name or by role
  >     foreach(space; { "sRGB", "color_picker" })
  >     {
  >         foreach(token; { "name",
  >             "description",
  >             "isdata",
  >             "allocation",
  >             "allocationvars",
  >             "description",
  >         } )
  >         {
  >             printf("----------------- %s ---------------------\n", token);
  >             if (teximport(map, token, sval))
  >                 fprintf(stderr, "'%s' = %s\n", token, sval);
  >             if (teximport(map, token, ival))
  >                 fprintf(stderr, "'%s' = %d\n", token, ival);
  >             else if (teximport(map, token, vval))
  >                 fprintf(stderr, "'%s' = %g\n", token, vval);
  >         }
  >     }

RELATED

  * dsmpixel

}

{
ocio_roles

Returns the names of roles supported in Open Color IO

USAGE
  string [] ocio_roles()

Returns a list of names of the roles supported by Open Color IO in
Houdini.

RELATED

}

{
ocio_spaces

Returns the names of color spaces supported in Open Color IO.

USAGE
  string[] ocio_spaces()

RELATED

}

{
ocio_transform

Transform colors using Open Color IO

USAGES
  vector ocio_transform(string dest; vector clr)
  vector ocio_transform(string src, string dest; vector clr)
  vector ocio_transform(string src, string dest, string looks; vector
  clr)
  Transform a three-component color into a new color space.

  vector4 ocio_transform(string dest; vector4 clr)
  vector4 ocio_transform(string src, string dest; vector4 clr)
  vector4 ocio_transform(string src, string dest, string looks; vector4
  clr)
  Transform a four-component color into a new color space.


src
    The name of the color space to transform from. If this is not given,
    the function assumes the space assigned to "data".

dest
    The name of the color space to transform to.

looks
    A comma separated list of color gradings (also known as "looks").

clr
    The color to transform.

RELATED

  * ocio_spaces

}

{
onoise

These functions are similar to wnoise and vnoise.

USAGES
  float onoise(vector pos)
  vector onoise(vector pos)
  float onoise(vector pos, int turbulence, float rough, float atten)
  vector onoise(vector pos, int turbulence, float rough, float atten)

These functions are similar to wnoise and vnoise. However, they are
marginally less efficient in computation and don't have the same
characteristics. The bounds on the noise are roughly (-1, 1). Only 3D
noise is supported. However, this noise has the ability to compute
turbulence with roughness and attenuation on the noise.

RELATED

  * Noise and randomness

  * anoise

  * curlnoise

  * flownoise

  * noise

  * onoise

  * pnoise

  * snoise

  * vnoise

  * wnoise

  * xnoise

}

{
opdigits

Returns the integer value of the last sequence of digits of a string

USAGES
  int opdigits(const string str)
  int opdigits()

Returns the integer value of the last sequence of digits in the input
string.

If no argument is passed, the code is equivalent to

> string dir, name;
> splitpath(opfullpath("."), dir, name);
> return opdigits(name);

EXAMPLES

  * opdigits("/obj/geo34/box21") - returns 21

  * opdigits("/obj/geo34/box") - returns 34

  * opdigits("/obj/geo34/box2.1") - returns 1 ("." is not a digit)

RELATED

  * isdigit

  * atoi

}

{
opend

Ends a long operation.

USAGE
  void opend(int handle)

Informs mantra that a long operation begun with opstart has completed.
Pass in the value returned by opstart.

> int op_handle = opstart("Performing long operation");
> perform_long_operation();
> if (op_handle >= 0)
>     opend(op_handle);

RELATED

  * opstart

}

{
opfullpath

Returns the full path for the given relative path

USAGE
  string opfullpath(const string relative_path)

This function returns the absolute path for a given relative path to the
object being evaluated.

The function is currently only meaningful in Houdini.

EXAMPLES

  * opfullpath(".") - The full path of the current node being evaluated

  * opfullpath("..") - The full path of the current node's parent

RELATED

  * split

  * opdigits

  * splitpath

  * relativepath

}

{
opparentbonetransform

Returns the parent bone transform associated with an OP.

USAGES
  matrix opparentbonetransform(string path)
  matrix opparentbonetransform(string path, float time)

Returns the parent bone transform associated with an OP. If the
specified OP has no transform associated with it (such as a COP), then
an identity matrix is returned. It is possible to specify the time at
which to evaluate the transform (in seconds, not frames). Returns the
transform at the root of the parent bone or the parent transform
otherwise.


NOTE
    The op: syntax can be used to simulate this behavior using the
    standard transform functions.

RELATED

  * ntransform

  * ptransform

  * getspace

  * optransform

  * oppreconstrainttransform

  * opparmtransform

  * opparenttransform

}

{
opparenttransform

Returns the parent transform associated with an OP.

USAGES
  matrix opparenttransform(string path)
  matrix opparenttransform(string path, float time)

Returns the parent transform associated with an OP. If the specified OP
has no transform associated with it (such as a COP), then an identity
matrix is returned. It is possible to specify the time at which to
evaluate the transform (in seconds, not frames).


NOTE
    The op: syntax can be used to simulate this behavior using the
    standard transform functions.

RELATED

  * ntransform

  * ptransform

  * getspace

  * optransform

  * oppreconstrainttransform

  * opparmtransform

  * opparentbonetransform

}

{
opparmtransform

Returns the parm transform associated with an OP.

USAGES
  matrix opparmtransform(string path)
  matrix opparmtransform(string path, float time)

Returns the parm transform associated with an OP. If the specified OP
has no transform associated with it (such as a COP), then an identity
matrix is returned. It is possible to specify the time at which to
evaluate the transform (in seconds, not frames).


NOTE
    The op: syntax can be used to simulate this behavior using the
    standard transform functions.

RELATED

  * ntransform

  * ptransform

  * getspace

  * optransform

  * oppreconstrainttransform

  * opparenttransform

}

{
oppreconstrainttransform

Returns the preconstraint transform associated with an OP.

USAGES
  matrix oppreconstrainttransform(string path)
  matrix oppreconstrainttransform(string path, float time)

Returns the preconstraint transform associated with an OP. If the
specified OP has no transform associated with it (such as a COP), then
an identity matrix is returned. It is possible to specify the time at
which to evaluate the transform (in seconds, not frames).


NOTE
    The op: syntax can be used to simulate this behavior using the
    standard transform functions.

RELATED

  * ntransform

  * ptransform

  * getspace

  * optransform

  * opparmtransform

  * opparenttransform

}

{
oppretransform

Returns the pretransform associated with an OP.

USAGES
  matrix oppretransform(string path)
  matrix oppretransform(string path, float time)

Returns the transform associated with an OP. If the OP specified has no
transform associated with it (for example a COP), then an identity
matrix is returned. It is possible to specify the time to evaluate the
transform at (in seconds, not frames).


NOTE
    The op: syntax can be used to simulate this behavior using the
    standard transform functions.

RELATED

  * ntransform

}

{
opstart

Start a long operation.

USAGE
  int opstart(string message)

Inform mantra about the start of a long operation (operation start). The
string argument is passed to mantra and may be displayed in the IPR
viewer.

The function will return a non-negative integer when successfully
started.

The integer returned should be passed to opend() at the completion of
the long operation.

> int started = opstart("Performing long operation");
> perform_long_operation();
> if (started >= 0)
> opend(started);

RELATED

  * opend

}

{
optransform

Returns the transform associated with an OP.

USAGES
  matrix optransform(string path)
  matrix optransform(string path, float time)

Returns the transform associated with an OP. If the OP specified has no
transform associated with it (for example a COP), then an identity
matrix is returned. It is possible to specify the time to evaluate the
transform at (in seconds, not frames).

NOTE: The op: syntax can be used to simulate this behaviour using the
standard transform functions.

RELATED

  * ntransform

  * ptransform

  * getspace

  * opparmtransform

  * oppreconstrainttransform

  * opparmtransform

}

{
ord

Converts an UTF8 string into a codepoint.

USAGE
  int ord(string value)

Returns the code point of the first UTF8 character in the given string.

If the prefix of the string isn't a valid UTF8 encoding, or is empty, -1
is returned.

Overlong UTF8 encodings will return -1.

RELATED

  * chr

}

{
osd_facecount

USAGE
  int osd_facecount(<geometry>)

Returns the number of coarse faces in the subdivision hull. This is
different that the number of patches in the subdivision surface.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

RELATED

  * osd_facecount

  * osd_firstpatch

  * osd_limitsurface

  * osd_patchcount

}

{
osd_firstpatch

USAGE
  int osd_firstpatch(<geometry>, int face_id)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

For a given face in the coarse mesh, this returns the number of the
first patch associated with the face. Since each face in a hull may
generate multiple patches, this function will return the first of the
patches generated by the face. See also osd_patchcount to find out the
number of patches generated by the face.

RELATED

  * osd_facecount

  * osd_firstpatch

  * osd_limitsurface

  * osd_patchcount

}

{
osd_limitsurface

Evaluates an attribute at the subdivision limit surface using Open
Subdiv.

USAGES
  int osd_limitsurface(<geometry>, string attrib_name, int face_id,
  float u, float v, <type> &result)
  int osd_limitsurface(<geometry>, string attrib_name, int face_id,
  float u, float v, float &result[])


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

osd_limitsurface evaluates the point attribute in the geometry specified
as a subdivision surface an returns the result of the attribute on the
limit surface. For vertex attributes, use osd_limitsurfacevertex().

Possible reasons for failure are:

  * The geometry contains no polygons or the topology can't be converted
    using Open Subdiv

  * The attribute doesn't exist on the input geometry.

  * The attribute size/type doesn't match the VEX type.

EXAMPLES


    Generate a point cloud on the limit surface of a subdivision mesh.
      > int npatches = osd_patchcount(file);
      > for (int patch = 0; patch < npatches; patch++)
      > {
      >     for (int v = 0; v < 100; v++)
      >     {
      >         vector        P;
      >         if (osd_limitsurface(file, "P", patch, nrandom(), nrandom(), P))
      >         {
      >             int        ptid = addpoint(geohandle, P);
      >         }
      >     }
      > }

RELATED

  * osd_facecount

  * osd_firstpatch

  * osd_patchcount

}

{
osd_limitsurfacevertex

USAGES
  int osd_limitsurfacevertex(<geometry>, string attrib_name, int
  face_id, float u, float v, <type> &result)
  int osd_limitsurfacevertex(<geometry>, string attrib_name, int
  face_id, float u, float v, float &result[])


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

See osd_limitsurface.

RELATED

}

{
osd_lookupface

Outputs the Houdini face and UV coordinates corresponding to the given
coordinates on an OSD patch.

USAGES
  int osd_lookupface(<geometry>, int patch_id, float patch_u, float
  patch_v, int &face_id, float &face_u, float &face_v)
  If you don't specify a texture attribute, the function uses intrinsic
  polygon interpolants.

  int osd_lookupface(<geometry>, int patch_id, float patch_u, float
  patch_v, int &face_id, float &face_u, float &face_v, string attribute)
  If you specify a texture attribute, the function uses the UVs in that
  attribute to translate the patch coordinates onto the Houdini
  geometry.

Each polygon in a piece of geometry will generate one or more Catmull-
Clark subdivision patches. A quadrilateral will generate a single patch,
while a pentagon will generate five patches. This function helps map
between the subdivision patch id and the Houdini polygon (face). The
reverse function to map from face to patch is osd_lookuppatch.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

patch_id
    The ID number of the OSD patch.

patch_u, patch_v
    The coordinates in the subdivision patch to map onto a Houdini
    primitive. These values should be in the range 0 to 1.

&face_id
    The function overwrites this variable with the Houdini primitive
    number of the corresponding face.

&face_u, &face_v
    The function overwrites these variables with the corresponding U/V
    coordinates on the Houdini face. The output coordinates will have
    values in the range 0 to 1.

    1 on success or 0 on an error.

EXAMPLES

  > 
  > void
  > scatterOnLimitSurface(string file, texmap; int npts)
  > {
  >     int npatches = osd_patchcount(file);
  >     for (int i = 0; i < npts; ++i)
  >     {
  >         int patch_id = nrandom() * npatches;
  >         float patch_s = nrandom();
  >         float patch_t = nrandom();
  >         int face_id;
  >         float face_u, face_v;
  >         if (osd_lookupface(file, patch_id, patch_s, patch_t, face_id, face_u, face_v, "uv"))
  >         {
  >             vector clr = texture(texmap, face_u, face_v);
  >             vector P;
  >             osd_limitsurface(file, "P", patch_id, patch_s, patch_t, P);
  >             addpoint(P, clr, face_id);        // add a scattered point.
  >         }
  >     }
  > }

RELATED

  * osd_lookuppatch

  * osd_patchcount

  * osd_facecount

  * osd_firstpatch

  * osd_limitsurface

}

{
osd_lookuppatch

Outputs the OSD patch and UV coordinates corresponding to the given
coordinates on a Houdini polygon face.

USAGES
  int osd_lookuppatch(<geometry>, int face_id, float face_u, float
  face_v, int &patch_id, float &patch_u, float &patch_v)
  If you don't specify a texture attribute, the function uses intrinsic
  polygon interpolants.

  int osd_lookuppatch(<geometry>, int face_id, float face_u, float
  face_v, int &patch_id, float &patch_u, float &patch_v, string
  attribute)
  If you specify a texture attribute, the function uses the UVs in that
  attribute to translate the face coordinates onto the OSD patch.

Given the face_id and texture coordinates for a point inside the face
(face_u andface_v), this function will return the corresponding patch_id
(Catmull-Clark subdivision face) and the patch interpolants (patch_u and
patch_v). The reverse function to map from patch to face is
osd_lookupface.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

face_id
    The primitive number of the Houdini polygon face.

face_u, face_v
    The coordinates in the subdivision patch to map onto a Houdini
    primitive. These should have values in the range 0 to 1. Not all
    values are valid for triangles. The texture coordinates should be
    specified according to the attribute passed in. If you pass invalid
    coordinates, the function will fail and return 0.

&patch_id
    The function overwrites this variable with the corresponding OSD
    patch number. This is also the same integer value used to identify
    the face when performing PTex texture mapping.

&face_u, &face_v
    The function overwrites these variables with the corresponding U/V
    coordinates on the OSD patch.

    1 on success or 0 on an error.

EXAMPLES

  > 
  > // This function can be used to move points generated by a scatter SOP to the
  > // subdivision limit surface.  The scatter SOP needs to store the "sourceprim"
  > // (the Output Attributes tab).  Texture coordinates also need to be
  > // transferred from the source geometry.
  > void
  > movePointToLimitSurface(string file; vector P, uv; int sourceprim)
  > {
  >     int        patch_id = -1;
  >     float patch_u, patch_v;
  >     if (osd_lookuppatch(file, sourceprim, uv.x, uv.y,
  >             patch_id, patch_u, patch_v, "uv"))
  >     {
  >         vector        tmpP;
  >         if (osd_limitsurface(file, "P", patch_id, patch_u, patch_v, tmpP))
  >             P = tmpP;
  >     }
  > }

RELATED

  * osd_lookupface

  * osd_patchcount

  * osd_facecount

  * osd_firstpatch

  * osd_limitsurface

}

{
osd_patchcount

USAGES
  int osd_patchcount(<geometry>)
  Returns the number of base level patches in the subdivision hull
  specified by the geometry filename. This is different that the number
  of faces in the subdivision hull. For example, in a tetrahedron, each
  triangle face will generate three patches.

  int osd_patchcount(<geometry>, int face_id)
  For a given face in the coarse mesh, this returns the number of
  patches which are generated by that face. While a quadrilateral only
  generates 1 patch, all other faces will generate multiple patches
  based on their vertex count. For example, a triangle will generate 3
  patches, a pentagon will generate 5 patches.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

RELATED

  * osd_facecount

  * osd_firstpatch

  * osd_limitsurface

}

{
osd_patches

Returns a list of patch IDs for the patches in a subdivision hull.

USAGE
  int[] osd_patches(<geometry>, int face_id)
  Each face in a subdivision hull may create one or more patches. This
  function lists the patch ids for a corresponding face.

This is implemented using the following algorithm:

> int []
> osd_patches(const string file; const face_id)
> {
>     int        patches[] = {};
>     int        first = osd_firstpatch(file, face_id);
>     if (first >= 0)
>     {
>         int        npatches = osd_patchcount(file, face_id);
>         for (int i = 0; i < npatches; i++)
>             append(patches, first+i);
>     }
>     return patches;
> }

RELATED

  * osd_facecount

  * osd_firstpatch

  * osd_limitsurface

  * osd_limitsurfacevertex

  * osd_patchcount

}

{
outerproduct

Returns the outer product between the arguments.

USAGES
  matrix2 outerproduct(vector2 v, vector2 v)
  matrix3 outerproduct(vector v, vector v)
  matrix outerproduct(vector4 v, vector4 v)

Returns the outer product of the given vectors.

RELATED

}

{
ow_nspace

Transforms a normal vector from Object to World space.

USAGE
  vector ow_nspace(vector v)

Transforms a normal vector from _Object_ to _World_ space.

RELATED

}

{
ow_space

Transforms a position value from Object to World space.

USAGES
  matrix ow_space()
  vector ow_space(vector v)
  vector4 ow_space(vector4 v)

Transforms a position value from _Object_ to _World_ space.

RELATED

}

{
ow_vspace

Transforms a direction vector from Object to World space.

USAGE
  vector ow_vspace(vector v)

Transforms a direction vector from _Object_ to _World_ space.

RELATED

}

{
pack_inttosafefloat

Reversibly packs an integer into a finite, non-denormal float.

USAGE
  float pack_inttosafefloat(int i)

This is used to find the w component of a primitive uvw vector referring
to a polygon soup primitive, from the inner polygon number.

  * Integers in the range abs(i) <= (2^24) = 16,777,216 will be
    represented exactly by the floats of the same value.

  * Integers in the range 16,777,216 < abs(i) < (2^24) + 104*(2^23) =
    889,192,448 will be represented by larger, non-infinite floats.

  * Integers in the range 889,192,448 <= abs(i) < (2^24) + 230*(2^23) =
    1,946,157,056 will be represented by small, non-denormal floats.

  * Any other integers, abs(i) >= 1,946,157,056, will not be represented
    correctly.

RELATED

  * unpack_intfromsafefloat

  * primuv

}

{
pathtrace

Computes global illumination using PBR for secondary bounces.

USAGE
  vector pathtrace(vector P, vector N, ...)

pathtrace works like irradiance, but uses the physically based rendering
(PBR) engine to do secondary bounces.

pathtrace provides a simple (and not very flexible) method of invoking
the PBR rendering engine from micro-polygon rendering. It uses path
tracing and the F (BSDF) output, not Cf/Of on the hit shaders. Maximum
path depth is controlled by the "diffuse bounces" parameter on the PBR
tab of the mantra output driver.

Irradiance caching works the same way it works with occlusion.

RAY OPTIONS


    TIP
        When you specify a texture, such as with the "environment"
        keyword, you can also use the image filtering keyword arguments.
        See environment for a listing of the image filter keyword
        arguments.


    scope
        A list of objects which can be hit by the rays. When specified,
        scope overrides the default scope that would have been selected
        for the given raystyle. The "scope:default" value will cause the
        scope argument to use the default scope for the current context
        - as if the argument were not specified.

        Allows an override of the scope for ray-intersections. A special
        scope argument, scope:self, will match the currently shading
        object.

    maxdist
        The maximum distance to search for objects. This can be used to
        limit the search of objects to nearby objects only. If the
        maxdist given is negative, then it will act as if there is no
        maximum distance.

        Allows an override of the maximum distance the ray can travel
        when testing for intersections. Some functions (such as
        fastshadow) have the maximum distance implicitly defined (by the
        length of the ray) and should probably avoid using this option.
        However, this option can be used effectively when computing
        reflections, global illumination, refraction etc.

    variancevar
        The name of a VEX export variable to use for variance anti-
        aliasing. The renderer compares the value with adjacent
        micropolygons in micropolygon rendering to decide what shading
        points need additional samples (using vm_variance property as a
        threshold). If more samples are required, the algorithm takes
        samples up to the specified maximum ray samples.

        This variable must be imported from the hit surface, so it must
        be in the list of imported names (see "importing information
        back from the ray" below). If the named variable is not
        imported, this option will be ignored.

        Variance antialiasing puts more samples in areas of the image
        with high variance, for example a sharp shadow edge. It is only
        used when vm_dorayvariance is enabled. Otherwise, only the min
        ray samples (or an explicitly supplied "samples" value) are used
        for antialiasing of the gather loop.

        Overrides the global variance control (mantra's -v option) which
        is used to determine anti-aliasing quality of ray tracing. For
        more information please refer to the documentation on mantra.

    angle
        The distribution angle (specified in radians). For gather(),
        rays will be distributed over this angle. For trace(), the angle
        is used to indicate the rate at which the filter width should
        increase with increasing intersection distance. Larger angles
        will cause farther hit surfaces to use larger derivatives,
        leading to improved texturing and displacement performance.

        To be effective, the samples parameter should also be specified.

    samples
        How many samples should be sent out to filter rays. For the
        irradiance and occlusion functions, specifying a samples
        parameter will override the default irradiance sampling.

    environment
        If the ray sent out to the scene misses everything, then it's
        possible to specify an environment map to evaluate.

        Using the ray's direction, the environment map specified will be
        evaluated and the resulting color will be returned. Most likely,
        it will be necessary to specify a transform space for the
        environment map evaluations.

        In the case of refractlight and trace the Of and Af variables
        will be set to 0 regardless of the background color specified.
        the resulting color.

        When an environment map is specified, the filtering options from
        texture() are also supported.

        See how to create an environment/reflection map.

    envobject
        If an environment map is used, the orientation of the
        environment map can be specified by transforming the ray into
        the space of another object, light or fog object in the scene.
        In Houdini, null objects can be used to specify the orientation.
        For example:

      > Cf = R*reflectlight(bias, max(R), "environment", "map.rat", "envobject", "null_object_name");

    envlight
        If an environment map is used, the orientation of the
        environment map can be specified by transforming the ray into
        the space of a light in the scene.

    envtint
        If an environment map is used, tint it with this color.

    background
        If a ray misses all objects, use this as the background color of
        the scene. In the case of refractlight and trace the Of and Af
        variables will be set to 0 regardless of the background color
        specified.

    distribution
        *Functions*: irradiance, occlusion

        Distribution for computing irradiance. The default is to use a
        cosine distribution (diffuse illumination). The possible values
        for the style are "nonweighted" for uniform sampling or "cosine"
        for cosine weighted sampling.

RELATED

  * occlusion

  * irradiance

}

See bouncemask for information on component label bitmasks.

{
pcclose

This function closes the handle associated with a pcopen function.

USAGE
  void pcclose(int &handle)

This function closes the handle associated with a pcopen function. VEX
will close handles automatically, however, it's good practice to call
pcclose. When there are pcopen calls made from within a loop, VEX may
consume additional memory if pcclose isn't called when the handle is no
longer required.

RELATED

}

{
pcconvex

USAGE
  float pcconvex(int handle, string channel, vector N)

Calculates the 2D projected convex hull area for the given point cloud
handle along the given normal, where handle was returned by a prior call
to pcopen.

RELATED

  * pcopen

}

{
pcexport

Writes data to a point cloud inside a pciterate or a pcunshaded loop.

USAGES
  int pcexport(int handle, string channel_name, <type> value, ...)
  int pcexport(int handle, string channel_name, vector value, float
  radius, ...)

Returns 1 if the export succeeded or 0 if the export failed. The export
will fail if <channel_name> is not read-write or if (in the version of
pcexport taking a radius) the point being exported is at a distance less
than the specified radius from a point that is already in the point
cloud.

This function writes to the channels of points opened with pcopen or
pcgenerate. The second version of this function takes a radius parameter
and uses it to accept or reject the point being exported according to
its distance to the points that are already in the point cloud. It must
be separated from all other points by at least the specified radius. To
write new point data into a point cloud file, use pcwrite.

STORAGE TYPE

    If you add the "storage" optional keyword, the next argument
    specifies a storage type for the data. Storage types are the
    standard tile based format data types:

    int8, uint8

    8 bit signed/unsigned integers

    int16, uint16

    16 bit signed/unsigned integers

    int32, uint32

    32 bit signed/unsigned integers

    int64, uint64

    64 bit signed/unsigned integers

    real16

    16 bit floating point values

    real32

    32 bit floating point values

    real64

    64 bit floating point values

    int, uint, real

    Default precision integer/floating point values

RELATED

  * pcwrite

  * pcopen

  * pciterate

  * pcunshaded

  * pcimport

}

{
pcfarthest

Returns the distance to the farthest point found in the search performed
by pcopen.

USAGE
  float pcfarthest(int handle)

Returns the distance to the farthest point found in the search performed
by pcopen. If no points were found, the function will return a very
large value (1.0x10^37)

RELATED

}

{
pcfilter

Filters points found by pcopen using a simple reconstruction filter.

USAGE
  <type> pcfilter(int handle, string channel_name, ...)

Filters the points queued up by pcopen using a simple reconstruction
filter.

This function is roughly equivalent to:

> float pcfilter(int handle; string channel)
> {
>     float    sum, w, d;
>     float    value, result = 0;
>     while (pciterate(handle))
>     {
>         pcimport(handle, "point.distance", d);
>         pcimport(handle, channel, value);
>         w = 1 - smooth(0, radius, d);
>         sum += w;
>         result += w * value;
>     }
>     result /= sum;
>     return result;
> }

pcfilter takes the points that were opened by the point cloud and
produces a filtered value. The following equation shows how the
individual points are weighted.

> w_i = 1-smooth(0, maxd*1.1, d_i);

maxd is the farthest point, and w_i is the weight for a given point at
distance (d_i). Points that are closer to the center will be weighted
higher with that formula, rather than it being an average.

RELATED

  * pcopen

}

{
pcfind

Returns a list of closest points from a file.

USAGES
  int[] pcfind(<geometry>, string Pchannel, vector P, float radius, int
  maxpoints)
  int[] pcfind(<geometry>, string ptgroup, string Pchannel, vector P,
  float radius, int maxpoints)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

These functions open a geometry file and return a list of points with
the location <P> within <radius>, based on point positions found in
<Pchannel>. Only the <maxpoints> closest points within the given radius
will be returned. The file name may use the op: syntax to reference SOP
geometry in the OP contexts. The <Pchannel> parameter indicates the
attribute which contains the positions to be searched.

The ptgroup is a point group that limits the points to search. This is a
SOP-style group pattern, so can be something like 0-10 or @Cd.x>0.5. A
blank string is treated as matching all points.

EXAMPLES

    Performing a proximity query:

  > int[] closept = pcfind(filename, "P", P, maxdistance, maxpoints);
  > P = 0;
  > foreach (int ptnum; closept)
  > {
  > vector closepos = point(filename, "P", ptnum);
  > P += closepos;
  > }
  > P /= len(closept);

RELATED

  * nearpoint

  * nearpoints

  * pcfind_radius

  * pgfind

}

{
pcfind_radius

Returns a list of closest points from a file taking into account their
radii.

USAGES
  int[] pcfind_radius(<geometry>, string Pchannel, string RadChannel,
  float radscale, vector P, float radius, int maxpoints)
  int[] pcfind_radius(<geometry>, string ptgroup, string Pchannel,
  string RadChannel, float radscale, vector P, float radius, int
  maxpoints)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

These functions open a geometry file and return a list of points with
the location <P> within <radius>, based on point positions found in
<Pchannel>. Each of the points will be expanded by their <RadChannel>
attribute, which will be dilated by <radscale>.

Using a radius channel allows intersection detection between spheres of
varying radii. In this case you cannot use only your own sphere radius,
as the intersecting sphere may have a much larger radius so not be in
your search window. Because of this, it is also sensible to use a 0.0
<radius> with this function just find all the source spheres that your
query position is inside of.

Only the <maxpoints> closest points within the given radius will be
returned. The file name may use the op: syntax to reference SOP geometry
in the OP contexts. The <Pchannel> parameter indicates the attribute
which contains the positions to be searched.

The <ptgroup> is a point group that limits the points to search. This is
a SOP-style group pattern, so can be something like 0-10 or @Cd.x>0.5. A
blank string is treated as matching all points.


NOTE
    The radius attribute and radius scale apply to the points being
    searched, not to the point you are doing the searching with!

NOTE
    If the radius attribute does not exist, this becomes equivalent to
    pcfind.

EXAMPLES

    Performing a proximity query:

  > int[] closept = pcfind_radius(filename, "P", "pscale", 1.0, P, maxdistance, maxpoints);
  > P = 0;
  > foreach (int ptnum; closept)
  > {
  > vector closepos = point(filename, "P", ptnum);
  > P += closepos;
  > }
  > P /= len(closept);

RELATED

  * nearpoint

  * nearpoints

  * pcfind

}

{
pcgenerate

Generates a point cloud.

USAGE
  int pcgenerate(string filename, int npoints)

This function returns a handle to the point cloud with the specified
name or creates a new point cloud with the specified name and number of
points. Initially, the point cloud has no channels, but channels can be
added using pcexport in a pcunshaded loop. Note that if pcgenerate() is
called with the name of a point cloud that already exists, that point
cloud will not be re-sized to contain the specified number of points.

Once a position channel has been established, call pcopen to query the
generated point cloud. Note that calling pcopen will lock the specified
position channel. Once a point cloud has been opened, it is considered
to be generated. Calling pcgenerate() with the name of a generated point
cloud is similar to calling pcopen() and requesting 0 points: no points
will be available in a pcunshaded or pciterate loop.

This function only stores a point cloud in RAM. To write points to disk,
use pcwrite().


NOTE
    We refer to the parameter as a filename to be consistent with
    pcopen(). The two functions share the same namespace. That is, if
    you call pcgenerate("myfile.pc", ...), you can then query
    "myfile.pc" by calling pcopen("myfile.pc", ...) or
    pcopenlod("myfile.pc", ...).

    This works the other way as well. If you call pcopen("myfile.pc",
    ...) and then call pcgenerate("myfile.pc", ...), the pcgenerate()
    call will use the point cloud that is already loaded into memory
    through the pcopen() call rather than creating a new point cloud.

EXAMPLES

  > vector position;
  > int ohandle, ghandle, rval;
  > 
  > ghandle = pcgenerate(texturename, npoints);
  > while (pcunshaded(ghandle, "P"))
  > {
  >     // Compute 'position'...
  >     rval = pcexport(ghandle, "P", position);
  > }
  > 
  > ohandle = pcopen(texturename, "P", P, maxdistance, maxpoints);
  > while (pciterate(ohandle))
  > {
  >     rval = pcimport(ohandle, "P", position);
  >     // Do something with 'position'...
  > }
  > 
  > pcclose(ohandle);
  > pcclose(ghandle);

RELATED

  * pcopen

  * pcwrite

  * pcfilter

  * pciterate

  * pcunshaded

  * pcimport

  * pcexport

  * pcclose

}

{
pcimport

Imports channel data from a point cloud inside a pciterate or a
pcunshaded loop.

This function is only valid while looping with pciterate or pcunshaded.

USAGE
  int pcimport(int handle, string channel_name, <type> &value)
  Imports data from the point cloud file into the given variable.


channel_name
    There are two special channel names you can import:


    point.number
        The number of the point being processed.

    point.distance
        The distance of the point being processed from the query point.
        This is only available when iterating over unshaded points.

value
    If the import succeeds the function overwrites this variable with
    the channel value.

    1 if the import succeeded or 0 if the import failed (usually due to
    the given channel name not existing).

RELATED

  * pcopen

  * pciterate

  * pcunshaded

  * pcexport

}

{
pcimportbyidx3

Imports channel data from a point cloud outside a pciterate or a
pcunshaded loop.

USAGE
  matrix3 pcimportbyidx3(int handle, string channel_name, int idx)

After a pcopen and a pcnumfound, this can be used to extract specific
search results from the found points.

This will return 0 if the channel doesn't exist.

RELATED

  * pcopen

  * pcnumfound

}

{
pcimportbyidx4

Imports channel data from a point cloud outside a pciterate or a
pcunshaded loop.

USAGE
  matrix pcimportbyidx4(int handle, string channel_name, int idx)

After a pcopen and a pcnumfound, this can be used to extract specific
search results from the found points.

This will return 0 if the channel doesn't exist.

RELATED

  * pcopen

  * pcnumfound

}

{
pcimportbyidxf

Imports channel data from a point cloud outside a pciterate or a
pcunshaded loop.

USAGE
  float pcimportbyidxf(int handle, string channel_name, int idx)

After a pcopen and a pcnumfound, this can be used to extract specific
search results from the found points.

This will return 0 if the channel doesn't exist.

RELATED

  * pcopen

  * pcnumfound

}

{
pcimportbyidxi

Imports channel data from a point cloud outside a pciterate or a
pcunshaded loop.

USAGE
  int pcimportbyidxi(int handle, string channel_name, int idx)

After a pcopen and a pcnumfound, this can be used to extract specific
search results from the found points.

This will return 0 if the channel doesn't exist.

RELATED

  * pcopen

  * pcnumfound

}

{
pcimportbyidxp

Imports channel data from a point cloud outside a pciterate or a
pcunshaded loop.

USAGE
  vector4 pcimportbyidxp(int handle, string channel_name, int idx)

After a pcopen and a pcnumfound, this can be used to extract specific
search results from the found points.

This will return 0 if the channel doesn't exist.

RELATED

  * pcopen

  * pcnumfound

}

{
pcimportbyidxs

Imports channel data from a point cloud outside a pciterate or a
pcunshaded loop.

USAGE
  string pcimportbyidxs(int handle, string channel_name, int idx)

After a pcopen and a pcnumfound, this can be used to extract specific
search results from the found points.

This will return 0 if the channel doesn't exist.

RELATED

  * pcopen

  * pcnumfound

}

{
pcimportbyidxv

Imports channel data from a point cloud outside a pciterate or a
pcunshaded loop.

USAGE
  vector pcimportbyidxv(int handle, string channel_name, int idx)

After a pcopen and a pcnumfound, this can be used to extract specific
search results from the found points.

This will return 0 if the channel doesn't exist.

RELATED

  * pcopen

  * pcnumfound

}

{
pciterate

This function can be used to iterate over all the points which were
found in the pcopen query.

USAGE
  int pciterate(int handle)

This function can be used to iterate over all the points which were
found in a pcopen query. The first argument is the <handle> returned by
pcopen. The function returns 1 while there are points left in the
iteration loop, or 0 when there are no further points. This lets you use
the function as the condition in a while loop.

Warnings:

  * It is not possible to nest pcunshaded or pciterate loops for the
    same handle. That is, for a single pcopen call, only one pcunshaded
    or pciterate loop may be entered.

  * Computations involving derivatives inside pcunshaded loops may have
    slightly different results. If derivatives are required for
    variables which aren't set by pcimport it may be better to pre-
    compute the derivatives before the pcunshaded loop is entered.

RELATED

  * pcopen

  * pcunshaded

  * pcimport

}

{
pcnumfound

This node returns the number of points found by pcopen.

This node returns the number of points found by a pcopen query.

For example, if 10 points are being filtered, and 6 are within the
search radius, pcnumfound will return 6.

USAGE
  int pcnumfound(int handle)

Returns the number of found points from the search performed by pcopen.

RELATED

  * pcopen

}

{
pcopen

Returns a handle to a point cloud file.

USAGES
  int pcopen(string filename, string channel, int shaded, ...)
  int pcopen(string filename, string Pchannel, vector P, float radius,
  int maxpoints, ...)
  int pcopen(string filename, string Pchannel, vector P, string
  Nchannel, vector N, float radius, int maxpoints, ...)
  int pcopen(int opinput, string Pchannel, vector P, float radius, int
  maxpoints)

This function opens a point cloud file (.pc) and queues up access to the
points contained in it. You can then iterate over the points with
pcunshaded or pciterate.

The first two versions of this function queue up points centered around
a certain location <P> within <radius>, based on point positions found
in <Pchannel>. Only the <maxpoints> closest points within the given
radius will be queued. When using pcopen() with pciterate(), points will
be sorted from nearest to farthest. The file name may use the op: syntax
to reference SOP geometry in the OP contexts. The <Pchannel> parameter
indicates the channel in the texture which contains the positions to be
searched. <Pchannel> will be made read-only if it is not already. Any
subsequent attempts to use the channel with pcexport or pcunshaded will
fail. Optionally, the <Nchannel> specifies a direction channel and the
<N> vector specifies a search direction. Only points which are pointed
in the same direction (i.e. dot(N, Npoint) > 0) will be queued.

In some cases, you may need to add additional channels to a point cloud.
You can do this by using pcexport and pcunshaded. Often, you will not
need to add extra channel data to every point in the point cloud. For
example, if only part of the point cloud is inside the camera's frustum.
In these cases, it is best to only add channel data to points returned
by a proximity query. However, sometimes all points in a point cloud
must receive extra channel data before meaningful queries can be made.
For example, when adding a position channel. In these cases, the third
version of this function can be used to queue up all shaded (<shaded> !=
0) or unshaded (<shaded> == 0) points of a certain channel, <channel>.
If <channel> does not exist, all points will be queued. This function,
unlike the first two, does not lock <channel>.

You can specify an additional string parameter "prefix", with the next
parameter being a channel prefix string, used to reference tiled block
files.


NOTE
    The preload option loads the entire point cloud into memory.
    Disabling this option will cause it to use a tile cache.

EXAMPLES


    Performing a proximity query
      > int handle = pcopen(texturename, "P", P, maxdistance, maxpoints);
      > while (pcunshaded(handle, "irradiance"))
      > {
      >     pcimport(handle, "P", cloudP);
      >     pcimport(handle, "N", cloudN);
      >     ir = computeIrraciance(cloudP, cloudN);
      >     pcexport(handle, "irradiance", ir);
      > }
      > pcfilter(handle, radius, "irradiance", ir);
    Shading an entire channel
      > vector sample;
      > int rval, handle;
      > 
      > handle = pcopen(texturename, "P", 0);
      > while (pcunshaded(handle, "P"))
      > {
      >     sample = set(nrandom("qstrat"), nrandom("qstrat"), 0.0);
      >     rval = sample_geometry(
      >         sample, sample, Time,
      >         "scope", getobjectname(),
      >         "pipeline", "displacement",
      >         "P", pos);
      >     if (rval)
      >         rval = pcexport(handle, "P", pos);
      > }
      > pcclose(handle);
    Controlling the minimum dot product between the point normal and the
    normal passed to pcopen() for points to be filtered
      > // This will only return points where dot(N, Npoint) > 0.8
      > int handle = pcopen("test.pc", "P", P, "N", N, 1e6, 100, "ndot", 0.8);

RELATED

  * pcgenerate

  * pcwrite

  * pcfilter

  * pciterate

  * pcunshaded

  * pcimport

  * pcclose

}

{
pcopenlod

Returns a handle to a point cloud file.

USAGE
  int pcopenlod(string filename, string Pchannel, vector P, int min_pts,
  ...)

This function opens a point cloud file (.pc) and queues up access to the
points contained in it. You can then iterate over the points with
pcunshaded or pciterate and add new data to the point cloud using
pcexport.

While this function is similar to pcopen, the major difference is the
points that it queues up may be aggregates of entire groups of points.
In other words, a single point may represent many points. This allows
you to perform queries at any desired level of detail without ignoring
points in the point cloud. For example, you can perform a query in which
points near the query origin are queued up as usual, but points far from
the origin are averaged. This can lead to dramatic performance increases
because entire groups of points can be processed as if they are a single
point.

As in pcopen, <P> specifies the query origin and <Pchannel> specifies
the position channel. During construction, the tree structure starts out
as a single bounding box that encompasses all the points in a point
cloud, and is recursively subdivided until there are fewer than
<min_pts> points in a node - at which point subdivision stops and a leaf
node is created. A good default for <min_pts> is 8.

Queries are performed by descending the tree structure from the root
node until some condition is met. Conceptually, you start with a coarse
query and refine it until you decide that it is detailed enough. You use
a measure to decide when the query has the desired level of detail. Two
measure values are supported: distance and solidangle.

DISTANCE QUERIES

    distance mode is provided for compatibility with pcopen and does not
    queue up aggregate points. Distance queries take a threshold
    parameter that indicates the radius within which to accept points.

    The threshold argument specifies the radius within which points are
    accepted - identical to the radius passed to pcopen. For example,
    calling pcopenlod(..., "measure", "distance", "threshold", radius,
    ...) queues up points that lie within the specified radius of the
    query origin.

SOLID ANGLE QUERIES

    Solid angle queries prioritize points by how close they are to the
    query point and also by the area of the point, so points that are
    close to the query point and that have a large area are given a
    greater weight. The query process will tend to split points with a
    larger contribution by queueing their children.

    The exact equation used to compute point contribution is the
    following:

    Ai / ||Pi - P||^2,

    where Ai is an aggregate area value, Pi is the closest point to P in
    the aggregate box, and P is the query origin. Calling pcopenlod(...,
    "measure", "solidangle", "area", "A", ...) performs a solid-angle
    query in which the A channel is assumed to hold area values.

    There are two different ways to use the solid angle query - an
    unlimited (threshold) query which returns a different number of
    points depending on how many points meet the given threshold, and a
    limited (samples) query which always returns the same number of
    points. If a samples argument is present, a limited query is
    assumed.

    Limited queries work by prioritizing rather than thresholding
    samples - so that regardless of the total weight of the points being
    considered, the same number of points are returned. The algorithm
    works by iteratively picking the point that has the greatest
    contribution and splitting that point until enough points have been
    split to meet the desired sample count. Limited queries are useful
    when you need a fixed performance or minimum quality level for the
    query.

    Threshold queries work by comparing the point contribution to a
    fixed threshold - and accepting or rejecting the point based on this
    comparison. Since different query points lead to different point
    contributions, a variable number of points will be queued up for
    threshold queries. Threshold queries are useful when it is
    acceptable to use a lower number of points for query positions that
    are far from the point cloud.

AGGREGATION

    Additional string parameters indicate how point values are
    aggregated. Each channel can have a different aggregation mode:
    mean, sum, or weighted. Calling pcopenlod(..., aggregate:P, sum)
    will aggregate the values in channel P by summing them. Calling
    pcopenlod(..., aggregate:A, weighted, weight, W) will aggregate the
    values in channel A using a weighted mean with weights from channel
    W.

EXAMPLE: PROXIMITY QUERY

  > int handle = pcopenlod(texturename, "P", P, 8,
  > "measure", "distance", "threshold", 2.0,
  > "aggregate:P", "mean",
  > "aggregate:value", "sum");
  > Cf = 0;
  > while (pciterate(handle))
  > {
  > pcimport(handle, "value", valueSum);
  > Cf += valueSum;
  > }
  > pcclose(handle);

EXAMPLE: THRESHOLD SOLID-ANGLE QUERY

  > handle = pcopenlod(texturename, "P", P, 8,
  > "measure", "solidangle", "area", "A", "threshold", 0.01,
  > "aggregate:A", "sum",
  > "aggregate:irradiance", "weighted", "weight", "A",
  > "aggregate:P", "mean");
  > Cf = 0;
  > while (pciterate(handle))
  > {
  > pcimport(handle, "irradiance", irradiance);
  > Cf += irradiance;
  > }
  > pcclose(handle);

EXAMPLE: LIMITED SOLID-ANGLE QUERY

  > handle = pcopenlod(texturename, "P", P, 8,
  > "measure", "solidangle", "area", "A", "samples", 4,
  > "aggregate:A", "sum",
  > "aggregate:irradiance", "weighted", "weight", "A",
  > "aggregate:P", "mean");
  > Cf = 0;
  > while (pciterate(handle))
  > {
  > pcimport(handle, "irradiance", irradiance);
  > Cf += irradiance;
  > }
  > pcclose(handle);

RELATED

  * pcopen

  * pcgenerate

  * pcwrite

  * pcfilter

  * pciterate

  * pcunshaded

  * pcimport

  * pcclose

  * pcsampleleaf

}

{
pcsampleleaf

Changes the current iteration point to a leaf descendant of the current
aggregate point.

USAGE
  void pcsampleleaf(int handle, float sample)

This function can only be used with the pcopenlod() function, and then
only within a pciterate() loop. It replaces the current iteration point
with an importance sampled leaf descendent of that point. The weighting
used to select the leaf point is the "area" channel provided to the
pcopenlod() function's "measure" parameter, or a uniform weight if no
area channel was specified when opening the point cloud. The sample
parameter is expected to be a uniform random value between 0 and 1.

If the current iteration point is already a leaf point or the point
cloud was not opened with pcopenlod(), pcsampleleaf() has no effect.

This function is useful when aggregate point information cannot be used
in a meaningful way, and provides a mechanism to access the information
contained in child nodes in the point tree. For example, it wouldn't
make sense to trace shadow rays from an averaged point position, but it
is useful to choose one of the child points and then send the shadow ray
to that point.

EXAMPLE: SHADOW RAYS

  > // Open a point cloud and retrieve a single aggregate point representing the
  > // entire cloud
  > string texturename = "points.pc";
  > int handle = pcopenlod(texturename, "P", P, 8,
  > "measure", "solidangle",
  > "area", "A",
  > "samples", 1,
  > "aggregate:A", "sum",
  > "aggregate:P", "mean");
  > 
  > Cf = 0;
  > 
  > // This loop will iterate only once
  > while (pciterate(handle))
  > {
  >     // Query A from the averaged point
  >     float        ptarea;
  >     pcimport(handle, "A", ptarea);
  > 
  >     pcsampleleaf(handle, nrandom());
  > 
  >     // Query P from a sampled leaf point
  >     vector        pos;
  >     pcimport(handle, "P", pos);
  > 
  >     if (trace(pos, P-pos, Time))
  >         Cf += ptarea / length2(P-pos);
  > }

RELATED

  * pcopenlod

  * pciterate

}

{
pcsize

USAGE
  int pcsize(int handle)

Returns the total number of points in the point cloud specified by
handle, where handle was returned by a prior call to pcopen.

RELATED

  * pcopen

}

{
pcunshaded

Iterate over all of the points of a read-write channel which haven't had
any data written to the channel yet.

USAGE
  int pcunshaded(int handle, string channel_name)

Like pciterate, this function can be used to iterate over points which
were found in a pcopen query. The first argument is the <handle>
returned by pcopen.

However, where pciterate iterates over all the points, this function
only iterates over points where the channel in <channel_name> has not
yet been written to.

The function returns 1 while there are points left in the iteration
loop, or 0 when there are no further points. This lets you use the
function as the condition in a while loop.

Warnings:

  * This function will not work correctly when used in multi-threaded
    OPs. It is not possible to nest pcunshaded or pciterate loops for
    the same handle. That is, for a single pcopen call, only one
    pcunshaded or pciterate loop may be entered.

  * Computations involving derivatives inside pcunshaded loops may have
    slightly different results. If derivatives are required for
    variables which aren't set by pcimport it may be better to pre-
    compute the derivatives before the pcunshaded loop is entered.

RELATED

  * pcopen

  * pciterate

  * pcimport

  * pcexport

}

{
pcwrite

Writes data to a point cloud file.

USAGE
  int pcwrite(string filename, ...)
  Writes data for the current shading point out to a point cloud file.


filename
    The name of the file to write to. You can read the resulting file
    into a geometry network with the File surface node. This file should
    have a .pc extension (Houdini will use the extension to determine
    how to import the file).

...
    Subsequent arguments specify one or more pairs of a channel name (a
    string naming the attribute you're saving, such as "P", "N", "v",
    "area", "u", etc.) and value (the value you wish to store).

  > pcwrite("out.pc", "P", P, "N", N)

    To write a variable as a vector type instead of a triple, append
    :vector to the channel name.

  > pcwrite("out.pc", "P", P, "N:vector", N)

    In micropolygon rendering, points are interpolated with neighbor
    points so that duplicate vertices on corners and edges are
    eliminated in the point cloud. If you want to disable this behavior,
    use the "interpolate" argument described below.

interpolate
    When you pass this argument a value of 1 (the default), one
    interpolated point is written representing the four corners of a
    micropolygon. This prevents writing out overlapping values.

  > pcwrite("out.pc", "P", P, "interpolate", 1)

    Using a value of 0 will disable interpolation, which can be useful
    when writing points that are not based on P. Interpolation will have
    no effect in ray tracing mode.

    (Note that this means you can't use interpolate as the name of a
    data channel.)

countphotons
    For photon generation modes, add the number of points stored to the
    total number of photons, for the purposes of progress reporting and
    termination of photon map generation.

mkdir
    When you pass an argument of 1, the function will automatically
    create missing sub-directories/paths.

EXAMPLES

  > surface
  > dumpsomepoints(string fname = "points.$F4.pc"; int do_cull = 0; float keepamt = 0.05)
  > {
  >     vector    nn = normalize(frontface(N, I));
  >     int       rval=0;
  >     float     A = area(P,"smooth",0);  // area without smoothed derivs
  > 
  >     if( !do_cull  ||  do_cull & (nrandom()<keepamt) )
  >     {
  >         if( do_cull && keepamt > 0 )
  >         {
  >             A = A/keepamt;
  >         }
  >         rval = pcwrite(fname, "interpolate", 1,
  >         "P", ptransform("space:camera","space:world", P),
  >         "N", ntransform("space:camera","space:world", normalize(N)),
  >         "area", A);  // output an "area" channel in pc
  >     }
  >     Cf =abs(nn)*rval;
  > }

RELATED

  * pcopen

  * pcexport

  * File node

}

{
pgfind

Returns a list of closest points from a file.

USAGES
  int [] pgfind(<geometry>, vector P, float radius, int maxpoints, float
  divsize)
  int [] pgfind(<geometry>, string ptgroup, vector P, float radius, int
  maxpoints, float divsize)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

These functions are very similar to the pcfind functions. The difference
is that they use a grid-based acceleration structure. This can provide
faster initialization and lookups, provided the right grid size tuning
parameter is used.

If you are searching a point cloud using an near-constant search radius,
that radius can be used as the division size.


NOTE
    The division size must be not vary per point.

NOTE
    The division size is clamped above 3.0x105.

The ptgroup is a point group that limits the points to search. This is a
SOP-style group pattern, so can be something like 0-10 or @Cd.x>0.5. A
blank string is treated as matching all points.

RELATED

  * pcfind

  * pcfind_radius

}

{
phong

Returns a Phong BSDF or computes Phong shading.


USAGES
  bsdf phong(float exponent, ...)
  bsdf phong(vector nml, float exponent, ...)
  See writing a PBR shader for information on BSDFs.

  vector phong(vector nml, vector V, float shinyness, ...)
  <V> represents the normalized vector from the surface to the eye
  (-normalize(I)). <shinyness> is the Phong exponent (typically around
  20 or higher). <roughness> represents the surface roughness (typically
  0 to 1).

LIGHT INCLUSION/EXCLUSION OPTIONS


    categories
        Specifies lights to include/exclude by their "category" tags.
        This is the preferred include/exclude lights rather than pattern
        matching light names with the "lightmask" keyword argument.

        For example:

      > diff = diffuse(nml, "lightmask", "hero | fill");

        See light categories for more information.

    lightmask
        When evaluating light and shadow shaders, objects have pre-
        defined light masks. This mask is usually specified in the
        geometry object and specifies a list of lights which are used to
        illuminate a surface or fog shader. It is possible to override
        the default light mask by specifying a "lightmask" argument.

        For example:

      > diff = diffuse(nml, "lightmask", "light*,^light2");

        ...will cause all lights whose names begin with "light" except
        for a light named "light2" to be considered for diffuse
        illumination.

        All Houdini scoping patterns, excepting group expansion, are
        supported:

      * * - wild-card match

      * ? - single character match

      * ^ - exclusion operator

      * [list] - character list match

RELATED

  * ashikhmin

  * phonglobe

  * Writing a PBR shader

}

{
phongBRDF

USAGE
  float phongBRDF(vector L, vector N, vector V, float rough)

specularBRDF, phongBRDF, blinnBRDF, and diffuseBRDF return the computed
BRDF for the different lighting models used in VEX shading. You can use
them in custom illuminance loops to replicate the lighting models of the
corresponding VEX lighting functions.

See specularBRDF for some example code.

RELATED

  * specularBRDF

  * blinnBRDF

  * diffuseBRDF

  * illuminance

}

{
phonglobe

USAGES
  bsdf phonglobe(vector dir, float exponent, ...)
  bsdf phonglobe(vector nml, vector dir, float exponent, ...)
  bsdf phonglobe(vector dir, float exponentx, float exponenty, vector
  framex, vector framey, ...)
  bsdf phonglobe(vector nml, vector dir, float exponentx, float
  exponenty, vector framex, vector framey, ...)


A phong (blurred) reflection along a given direction vector. This will
produce the same result as phong() when the direction vector is the
reflection vector, but with this function you can also gather
illumination from other directions (such as transmission).

It is possible to create anisotropic phong lobes by providing x and y
exponents and tangent vectors.


dir
    the direction of specularity.

nml
    optional normal to specify the hemisphere for reflection directions.

exponent
    phong exponent.

exponentx
    phong exponent along the framex vector.

exponenty
    phong exponent along the framey vector.

framex
    highlight X direction

framey
    highlight Y direction

RELATED

  * phong

  * ashikhmin

  * Writing a PBR shader

}

{
photonmap

Samples a color from a photon map.

USAGES
  vector photonmap(string mapname, vector position, vector normal, ...)
  void photonmap(string mapname, vector position, vector normal, vector
  &color, float &area, ...)

VARIADIC ARGUMENTS

    You can specify additional keyword,value argument pairs to set the
    behavior of the evaluation. These arguments must be defined at load
    time (literals or parameters).

    To specify one of the additional arguments, pass the keyword as a
    string, with the next argument being the value for the keyword. For
    example ..., "wrap", "clamp", "border", {.1,1,1}).

    "nphotons"
    int

    Maximum number of photons to filter to produce the final color.
    Default is 50.

    "type"
    string

    How to interpret the photons.


    "diffuse" (the default)
        Scale each photon by the Lambertian cosine law.

    "irradiance"
        Use the raw energy of each photon without filtering.

    "error"
    float

    The amount of error allowed in the evaluation. Larger numbers give
    less accurate evaluations (i.e. smaller areas of the map will be
    scanned), while smaller number will result in larger areas of the
    map being scanned. Render time goes up as the error tolerance goes
    down.

    Default 0.001.

    "filter"
    string

    Specifies the "filter" for computing the irradiance from photons.
    When evaluating photon contributions, the incoming radiance is
    divided by the area that the photons cover (to determine the flux).
    The area can be computed in three different fashions:


    sphere (default)
        The minimum bounding sphere of all photons will be used to
        estimate the area. This estimator will result in soft blobby
        looking photon evaluation. It can be inaccurate near edges of
        primitives.

    volume
        Like sphere, but uses the volume of the minimum bounding sphere
        rather than area to normalize photon tracing results. When using
        volume filtering it is usually necessary to divide the photon
        lookup result by the volume density to correct for the density-
        weighted photon distribution that occurs in volumes.

        When using volume filtering, the normal passed to the photonmap
        function is ignored.

    convex
        Use the convex hull of all photons is to estimate the area. This
        estimator will result in slightly "sharper" edges in the photon
        evaluation, and can be more accurate near edges of primitives.
        However, since there are sharper edges, this estimator can
        produce very noisy evaluations.

    direct
        This filter should be used for photon maps that have been pre-
        filtered (for example, for maps that have already been filtered
        by the pcfilter utility). It will cause the photon energies to
        be averaged without area estimation.

EXAMPLES

  > Cf = photonmap(map, P, normalize(frontface(N, I)),
  > "nphotons", 100,
  > "type", "diffuse",
  > "error", 0.05,
  > "filter", "convex);
  > vector        clr;
  > float        area;
  > photonmap(map, P, normalize(frontface(N, I)), clr, area,
  > "nphotons", 100,
  > "type", "diffuse",
  > "error", 0.05,
  > "filter", "convex);
  > Cf = clr;

RELATED

}

{
planeindex

Returns the index of the plane specified by the parameter, starting at
zero.

USAGE
  int planeindex(string planename)

Returns the index of the plane specified by the parameter, starting at
zero.

RELATED

}

{
planename

Returns the name of the plane specified by the index (e.

USAGE
  string planename(int planeindex)

Returns the name of the plane specified by the index (e.g. "C", "A").

RELATED

}

{
planepointdistance

Computes the distance and closest point of a point to an infinite plane.

USAGE
  float planepointdistance(vector plane_pos, vector plane_normal, vector
  point_pos, vector &intersect_pos)

Given a 3D point point_pos, and a 3D plane with plane_normal normal
vector passing through a 3D point plane_pos, return the closest distance
and closest position between the plane and the point.

RELATED

}

{
planesize

Returns the number of components in the plane (1 for scalar planes and
up to 4 for vector planes).

USAGE
  int planesize(int planeindex)

Returns the number of components in the plane (1 for scalar planes and
up to 4 for vector planes). Returns 0 if the index is out of range.

RELATED

}

{
planesphereintersect

Computes the intersection of a 3D sphere and an infinite 3D plane.

USAGE
  int planesphereintersect(vector plane_pos, vector plane_normal, vector
  sphere_pos, float sphere_radius, vector &intersect_pos, float
  &intersect_radius, float &intersect_distance)

Given a 3D sphere centered at sphere_pos with a sphere_radius radius,
and a 3D plane with plane_normal normal vector passing through a 3D
point plane_pos, return 1 if there is an intersection or 0 if there
isn't.

The intersection is most often a 2D circle on the intersecting plane
centered at intersect_pos with a intersect_radius radius. It can also be
a single point, in which case intersect radius is set to 0. The distance
between the sphere_pos and the intersect_pos is returned even when there
is no intersection.

RELATED

}

{
pluralize

Converts an English noun to its plural.

USAGE
  string pluralize(string noun)

The English language is full of nonstandard rules for pluralizing nouns.
This function will properly create the plural ending for the input
string. Only the end of the input string is used.

EXAMPLES

  > string boxes = pluralize("box");
  > string women = pluralize("woman");
  > string geometries = pluralize("geometry");
  > 
  > // Returns the string "Pluralize the last words"
  > string phrase = pluralize("Pluralize the last word");

RELATED

}

{
pnoise

There are two forms of Perlin-style noise: a non-periodic noise which
changes randomly throughout N-dimensional space, and a periodic form
which repeats over a given range of space.

USAGES
  float|vector pnoise(float x, int px)
  float|vector pnoise(vector x, vector p)
  float|vector pnoise(vector4 xyzt, vector4 p)
  float|vector pnoise(float x, float y, int px, int py)
  float|vector pnoise(vector xyz, int px, int py, int pz)
  float|vector pnoise(vector4 xyzt, int px, int py, int pz, int pt)

There are two forms of Perlin-style noise: a non-periodic noise which
changes randomly throughout N-dimensional space, and a periodic form
which repeats over a given range of space.

This function generates periodic noise. Use the noise function to
generate non-periodic Perlin noise.

The various functions return the noise value at a 4D (vector4 argument),
3D (vector argument), 2D (two float arguments) or 1D (float argument)
position. You can get a random float value or a vector of three random
values.

The "p" int or vector arguments specify the range of periodicity. For
example, if you're making a 2D image and you want it to tile:

> clr = pnoise(X * 4, Y * 5, _4, 5_)

In this example, X is in the range 0-4, Y is in the range 0-5, and the
noise is periodic within that segment.

If a period argument is 0, VEX treats that as _no_ periodicity. Use this
to make the noise periodic in one dimension but not another.

The distribution of the noise depends on the dimension, with higher
dimensions approaching a Gaussian distribution of noise values.

RELATED

  * Noise and randomness

  * anoise

  * curlnoise

  * flownoise

  * noise

  * onoise

  * pnoise

  * snoise

  * vnoise

  * wnoise

  * xnoise

}

{
point

Reads a point attribute value from a geometry.

USAGES
  <type> point(<geometry>; string attribute_name; int pointnumber)
  <type>[] point(<geometry>; string attribute_name; int pointnumber)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

texttype
    The name of the attribute (or intrinsic) to read.

primnumber
    The point number to read the attribute on.

    The value of the given attribute on the given point number, or 0 if
    the attribute or point do not exist.

RELATED

}

{
pointattrib

Reads a point attribute value from a geometry and outputs a success/fail
flag.

USAGES
  <type> pointattrib(<geometry>, string attribute_name, int pointnumber,
  int &success)
  <type>[] pointattrib(<geometry>, string attribute_name, int
  pointnumber, int &success)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

&success
    The function overwrites this variable with 1 if the attribute exists
    and was read successfully, or 0 otherwise.

    The value of the given attribute on the given point number, or 0 if
    the attribute or point do not exist.

RELATED

}

{
pointattribsize

Returns the size of a geometry point attribute.

USAGE
  int pointattribsize(<geometry>, string attribute_name)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

See attribsize for more information.

Returns 0 if the attribute cannot be found.

RELATED

}

{
pointattribtype

Returns the type of a geometry point attribute.

USAGE
  int pointattribtype(<geometry>, string attribute_name)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

See attribtype for more information.

RELATED

}

{
pointattribtypeinfo

Returns the type info of a geometry attribute.

USAGE
  string pointattribtypeinfo(<geometry>, string attribute_name)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

See attribtypeinfo for more information.

RELATED

}

{
pointedge

Finds and returns a half-edge with the given endpoints.

USAGE
  int pointedge(<geometry>, int point1, int point2)

Returns -1 if no such half-edge exists. Otherwise returns the number of
a half-edge that either has point1 as source or has point2 as
desination, or the other way around.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

point1, point2
    The point numbers in the geometry for the two endpoints of the
    returned half-edge. 0 is the first point.

EXAMPLES

  > 
  > int edge_count = 0;
  > 
  > // Determine if there is an edge between points 23 and 25:
  > int h0 = pointedge("defgeo.bgeo", 23, 25);
  > if (h0 != -1)
  > {
  > // Edge exists!
  > }

RELATED

}

{
pointhedge

Finds and returns a half-edge with a given source point or with given
source and destination points.

USAGES
  int pointhedge(<geometry>, int point)
  int pointhedge(<geometry>, int srcpoint, int dstpoint)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

point
    The point number in the geometry for the source point of the
    returned half-edge. 0 is the first point.

srcpoint, dstpoint
    The point numbers in the geometry for source and destination of
    returned half-edge. 0 is the first point.

    The number of a half-edge that has point as source or has srcpoint
    as source and dstpoint as destination. In the former case, using
    op:pointhedgenext one can enumerate over all the half-edges that
    have point as source. Returns -1 if the half-edge is not valid.

EXAMPLES

  > 
  > int edge_count = 0;
  > 
  > // Count number of *edges* (not half-edges) incident to point number 23.
  > int hout = pointhedge("defgeo.bgeo", 23);
  > while ( hout != -1 )
  > {
  >     if (hedge_isprimary("defgeo.bgeo", hout))
  >         edge_count++;
  >     int hin = hedge_prev("defgeo.bgeo", hout);
  >     if (hedge_isprimary("defgeo.bgeo", hin))
  >         edge_count++;
  >     hout = pointhedgenext("defgeo", hout);
  > };

RELATED

}

{
pointhedgenext

Returns the *next* half-edge with the same source as a given half-edge.

USAGE
  int pointhedgenext(<geometry>, int hedge)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

point
    The point number in the geometry. 0 is the first point.

    The next half-edge that has the same source as hedge.

    Successive calls to this function iterate over all outgoing half-
    edges out of the same point. The iteration order does not
    necessarily agree with the order of the edges around a point in a
    manifold setting.

    Returns -1 if hedge is not valid, or the there are no more shared
    vertices with the source vertex of this hedge (same as
    op:vertexnext).

EXAMPLES

  > 
  > int edge_count = 0;
  > 
  > // Count number of *edges* (not half-edges) incident to point number 23.
  > int hout = pointhedge("defgeo.bgeo", 23);
  > while ( hout != -1 )
  > {
  >     if (hedge_isprimary("defgeo.bgeo", hout))
  >         edge_count++;
  >     int hin = hedge_prev("defgeo.bgeo", hout);
  >     if (hedge_isprimary("defgeo.bgeo", hin))
  >         edge_count++;
  >     hout = pointhedgenext("defgeo", hout);
  > }

RELATED

}

{
pointname

Returns the default name of the point plane (as it appears in the
compositor preferences).

USAGE
  string pointname()

Returns the default name of the point plane (as it appears in the
compositor preferences). Using this instead of hardcoding the default
makes your code more portable. Default is "P".

RELATED

}

{
pointprims

Returns the list of primitives containing a point.

USAGE
  int [] pointprims(<geometry>, int ptnum)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

ptnum
    The point number to get a primitive from.

    An array of primitive numbers. You should not rely on the numbers
    being in a particular order.

    If no primitives own the given point the array will be empty.

RELATED

}

{
pointvertex

Returns a linear vertex number of a point in a geometry.

USAGE
  int pointvertex(<geometry>, int point_num)
  Use this to find linear vertex number of the first vertex to share
  this point. Then you can use vertexnext to iterate over the other
  vertices in the point.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

    Returns the linear vertex number of the first vertex to share this
    point. Returns -1if no vertices share this point.

EXAMPLES

  > 
  > int        vtx;
  > 
  > // Get the linear vertex  of point 3
  > vtx = pointvertex("defgeo.bgeo", 3);

RELATED

  * vertexpoint

}

{
pointvertices

Returns the list of vertices connected to a point.

USAGE
  int [] pointvertices(<geometry>, int ptnum)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

ptnum
    The point number to get a vertex from.

    An array of vertices that are wired to the given point. You should
    not rely on the numbers being in a particular order.

    If the given point contains no vertices, the array will be empty.

RELATED

}

{
polardecomp

Computes the polar decomposition of a matrix.

USAGE
  matrix3 polardecomp(matrix3 transform)

Computes the polar decomposition of a 3x3 matrix. This is the orthogonal
matrix that best matches the given transform. This is very useful for
shape matching or blending of transforms.

RELATED

}

{
pop

Removes the last element of an array and returns it.

USAGES
  <type> pop(<type> &array[])
  Removes the last item from the array and returns it.

  <type> pop(<type> &array[]; int index)
  Removes the item at index from the array and returns its value.

  A negative index counts from the end of the list, so pop(array, -2)
  would remove the second-to-last value.

RELATED

  * Arrays

  * len

  * append

  * push

  * resize

}

{
pow

Raises the first argument to the power of the second argument.

USAGES
  float pow(float n, float exponent)
  <vector> pow(<vector> v, float exponent)
  Raises n to the power of exponent. For vectors, this is done per-
  component.

RELATED

}

{
predicate_incircle

Determines if a point is inside or outside a triangle circumcircle.

USAGE
  float predicate_incircle(vector2 a, vector2 b, vector2 c, vector2 d)

Given 3 points a, b, and c on the plane, return a positive value if d is
inside the circumcircle of the triangle abc, a negative value if d is
outside, and zero if d is exactly on the circumcircle.

More precisely, this function computes the determinant of the matrix:

> [a_x a_y a^2 1; b_x b_y b^2 1; c_x c_y c^2 1; d_x d_y d^2 1]

...with a guaranteed correct sign, where a^2, b^2, c^2, and d^2 are the
squared lengths of the respective input vectors.

RELATED

}

{
predicate_insphere

Determines if a point is inside or outside a tetrahedron circumsphere.

USAGE
  float predicate_insphere(vector a, vector b, vector c, vector d,
  vector e)

Given 4 points a, b, c, and d in 3D space, return a positive value if e
is inside the circumsphere of the tetrahedron abcd, a negative value if
e is outside, and zero if e lies exactly on the circumsphere.

More precisely, this function computes the determinant of the matrix

> [a_x a_y a_z a^2 1; b_x b_y b_z b^2 1; c_x c_y c_z c^2 1; d_x d_y d_z d^2 1; e_x
> e_y e_z e^2 1]

...with a guaranteed correct sign, where a^2, b^2, c^2, d^2 and e^2 are
the squared lengths of the corresponding input vectors.

RELATED

}

{
predicate_orient2d

Determines the orientation of a point with respect to a line.

USAGE
  float predicate_orient2d(vector2 a, vector2 b, vector2 c)

Given 2 points a and b in the plane, return a positive value if c is on
the left of the segment (a,b), a negative value if it is on the right of
the segment, and zero if a, b and c are colinear.

More precisely, this function computes the determinant of the matrix:

> [a_x a_y 1; b_x b_y 1; c_x c_y 1]

...with a guaranteed correct sign.

RELATED

}

{
predicate_orient3d

Determines the orientation of a point with respect to a plane.

USAGE
  float predicate_orient3d(vector a, vector b, vector c, vector d)

Given 3 points a, b and c in space, return a negative value if d is
behind the plane defined by the triangle abc (with right hand rule
winding order), a positive value if its in front of the plane, and zero
if points a, b, c and d are coplanar.

More precisely, this function computes the determinant of the matrix:

> [a_x a_y a_z 1; b_x b_y b_z 1; c_x c_y c_z 1; d_x d_y d_z 1]

...with a guaranteed correct sign.

RELATED

}

{
prim

Reads a primitive attribute value from a geometry.

USAGES
  <type> prim(<geometry>, string attribute_name, int primnumber)
  <type>[] prim(<geometry>, string attribute_name, int primnumber)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

texttype
    The name of the attribute (or intrinsic) to read.

primnumber
    The primitive number to read the attribute on.

    The value of the given attribute on the given point number, or 0 if
    the attribute or point do not exist.

RELATED

}

{
prim_attribute

Interpolates the value of an attribute at a certain parametric (u, v)
position and copies it into a variable.

This function specifies the position using _intrinsic primitive UVs_. To
use UVs stored in UV attribute, use uvsample instead.

USAGES
  int prim_attribute(string geometry, <type> &value, string
  attribute_name, int prim_number, float u, float v)
  int prim_attribute(string geometry, <type> &value[], string
  attribute_name, int prim_number, float u, float v)
  Samples the attribute value at the given UV coordinates on the
  primitive.

  int prim_attribute(string geometry, <type> &value, string
  attribute_name, int prim_number, vector uvw)
  int prim_attribute(string geometry, <type> &value[], string
  attribute_name, int prim_number, vector uvw)
  Specify the UVW coordinates using a vector instead of two floats.

If you don't need to test for errors, you can use primuv instead. This
function does not work with certain primitive types such as tetrahedra
and polysoups.


texttype
    A string specifying a geometry file (for example, a .bgeo) to read
    from. When running inside Houdini, this can be an op:/path/to/sop
    reference.

value
    The function overwrites this variable with the interpolated value
    from the primitive.

attribute_name
    The name of the attribute to read. *For point and vertex attributes,
    the value will at the given UV coordinates will be interpolated*
    from the surrounding points/vertices.

prim_number
    The primitive number to read the attribute from.

u, v
    The primitive UV coordinates at which to read the attribute.

    Returns 1 on success or 0 on an error (for example, the attribute
    doesn't exist).

    Returns 0 if the type of value is larger than the primitive type.
    For example, you can't read a vector attribute into a matrix
    variable.

RELATED

  * primuv

  * uvsample

}

{
prim_normal

Returns the normal of the primitive (prim_number) at parametric location
u, v.

USAGES
  vector prim_normal(<geometry>, int prim_number, vector uvw)
  vector prim_normal(<geometry>, int prim_number, float u, float v)
  vector prim_normal(<geometry>, int prim_number, float u, float v,
  float w)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

uvw, u, v, w
    When <w> is not given, it is treated as zero.

    The normal of the primitive (prim_number) at parametric location
    <u>, <v>, <w>.

RELATED

}

{
primarclen

Evaluates the length of an arc on a primitive using parametric uv
coordinates.

USAGE
  float primarclen(string geometry; vector2 uv1; vector2 uv2; int
  prim_num)

Returns the arc length between two parametric UV coordinates on a given
primitive. This lets you measure the distance across a polygon face or
along a curve.


texttype
    A string specifying a geometry file (for example, a .bgeo) to read
    from. When running inside Houdini, this can be an op:/path/to/sop
    reference.


uv1, uv2
    The start and end coordinates in the primitive's parametric space to
    measure between.


prim_num
    The number of the primitive across which to measure the distance.


TIP
    You can also read the arclength primitive intrinsic attribute to get
    a curve's total arc length.

RELATED

}

{
primattrib

Reads a primitive attribute value from a geometry, outputting a success
flag.

USAGES
  <type> primattrib(<geometry>, string attribute_name, int prim, int
  &success)
  <type>[] primattrib(<geometry>, string attribute_name, int prim, int
  &success)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

texttype
    The name of the attribute (or intrinsic) to read.

prim
    The primitive number.

&success
    Set to 1 if the import was successful, 0 on error (for example, the
    attribute or primitive number don't exist).

RELATED

}

{
primattribsize

Returns the size of a geometry prim attribute.

USAGE
  int primattribsize(<geometry>, string attribute_name)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

See attribsize for more information.

Returns 0 if the attribute cannot be found.

RELATED

}

{
primattribtype

Returns the type of a geometry prim attribute.

USAGE
  int primattribtype(<geometry>, string attribute_name)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

See attribtype for more information.

RELATED

}

{
primattribtypeinfo

Returns the type info of a geometry attribute.

USAGE
  string primattribtypeinfo(<geometry>, string attribute_name)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

See attribtypeinfo for more information.

RELATED

}

{
primduv

Returns position derivative on a primitive at a certain parametric (u,
v) position.

USAGE
  vector primduv(string geometry, int prim_number, vector2 uv, int du,
  int dv)


texttype
    A string specifying a geometry file (for example, a .bgeo) to read
    from. When running inside Houdini, this can be an op:/path/to/sop
    reference.

prim_number
    The number of the primitive on which to measure the derivative.

uv
    The parametric coordinates on the primitive at which to measure the
    derivative.


du, dv
    Represent the derivative order to query.

    On a curve, the curve direction is given by du==1 and the curvature
    is given by du==2.

    This only works on NURBS and Bezier curve primitives.

    <du> is currently ignored as it is meant to work with parametric
    surfaces.

RELATED

  * getderiv

  * Du

  * Dv

}

{
primfind

Returns a list of primitives potentially intersecting a given bounding
box.

USAGES
  int[] primfind(<geometry>, vector min, vector max)
  Find all the primitives whose bounding boxes overlap the given box.

  int[] primfind(<geometry>, string group, vector min, vector max)
  Find all primitives in a group whose bounding boxes overlap the given
  box.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

min, max
    These vectors define the minimum and maximum corners of the bounding
    box to search.

group
    If given, only match primitives in this group. An empty group string
    will include all primitives. The string supports Ad-hoc patterns
    like 0-10 and @Cd.x>0.

    An array of primitive numbers.


NOTE
    These functions are intended to be used as an optimization to
    finding primitives in a particular area for processing. For
    instance, to find all the curves from one input intersecting
    polygons on another input, we may naively iterate over all polygons
    for each curve to determine their intersection. To speed this
    process, we may find which primitives may intersect a particular
    curve using these functions, and iterate solely over the potentially
    intersecting primitives. This significantly improves performance
    since primfind uses an underlying tree structure to speed up search.

EXAMPLES

    Remove primitives that may be intersecting the unit box centered at
    the origin:

  > int[] prims = primfind(geometry, {-0.5, -0.5, -0.5}, {0.5, 0.5, 0.5});
  > foreach ( int prim; prims )
  > {
  >     removeprim("primitives.bgeo", prim, 1);
  > }

    Alternatively, we can use a query bounding box from an auxiliary
    source:

  > vector min, max;
  > getbbox("bbox.bgeo", min, max);
  > int[] prims = primfind(geometry, min, max);
  > foreach ( int prim; prims )
  > {
  >     removeprim("primitives.bgeo", prim, 1);
  > }

    To see the performance benefit of primfind, compare it to the
    following equivalent implementation of the function above:

  > float tol = 1e-5;
  > vector min, max;
  > getbbox("bbox.bgeo",min,max);
  > int n = nprimitives(0);
  > for ( int prim = 0; prim < n; ++prim )
  > {
  >     int[] verts = primvertices("primitives.bgeo", prim);
  > 
  >     // compute primitive bounding box and store it in prim_min and prim_max
  >     vector vert_pos = point("primitives.bgeo", "P", vertexpoint("primitives.bgeo", verts[0]));
  >     vector prim_min = vert_pos, prim_max = vert_pos;
  >     for ( int v = 1; v < len(verts); ++v )
  >     {
  >         vert_pos = point("primitives.bgeo", "P", vertexpoint("primitives.bgeo", verts[v]));
  >         prim_min = min(prim_min, vert_pos);
  >         prim_max = max(prim_max, vert_pos);
  >     }
  > 
  >     // bounding box intersection test
  >     if ( prim_max.x - min.x < -tol ) continue;
  >     if ( prim_max.y - min.y < -tol ) continue;
  >     if ( prim_max.z - min.z < -tol ) continue;
  >     if ( prim_min.x - max.x > tol ) continue;
  >     if ( prim_min.y - max.y > tol ) continue;
  >     if ( prim_min.z - max.z > tol ) continue;
  >     removeprim("primitives.bgeo", prim, 1);
  > }

RELATED

  * getbbox

  * pcfind

}

{
primhedge

Returns *one* of the half-edges contained in a primitive.

USAGE
  int primhedge(<geometry>, int prim)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

prim
    The primitive number in the geometry. 0 is the first primitive.

    The number of an arbitrary half-edge contained in prim. Returns -1
    if the primitive number is not valid.

RELATED

}

{
primintrinsic

Reads a primitive intrinsic from a geometry.


    Intrinsic values are similar to attributes, but are computed on-
    demand by Houdini rather than stored.

USAGES
  <type> primintrinsic(<geometry>, string intrinsic_name, int prim_num)
  <type>[] primintrinsic(<geometry>, string intrinsic_name, int
  prim_num)


    Intrinsic values are similar to attributes, but are computed on-
    demand by Houdini rather than stored.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

texttype
    The name of the intrinsic to read. For example, "pointattributes",
    "pointcount", or "bounds".

prim_num
    The number of the primitive to read the given intrinsic attribute
    for.

    The value of the intrinsic attribute, or 0 if the intrinsic does not
    exist.

RELATED

  * detailintrinsic

}

{
primpoint

Converts a primitive/vertex pair into a point number.

USAGE
  int primpoint(<geometry>, int primnum, int vertex)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

primnum
    The primitive number to get a vertex from.

vertex
    The vertex number inside of a primitive. 0 is the first vertex.

    The point number the vertex is wired to. Returns -1 if failed to
    find the corresponding point.

RELATED

}

{
primpoints

Returns the list of points on a primitive.

USAGE
  int [] primpoints(<geometry>, int primnum)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

primnum
    The primitive number to get the points of.

    An array of points, in the same order as stored on the primitive
    itself. If the primitive number is not valid, the array will be
    empty.

RELATED

}

{
primuv

Interpolates the value of an attribute at a certain parametric (uvw)
position.

This function specifies the position using _intrinsic primitive UVs_. To
use UVs stored in UV attribute, use uvsample instead.

USAGES
  <type> primuv( <geometry>; string attribute_name; int prim_num; vector
  uvw)
  <type>[] primuv( <geometry>; string attribute_name; int prim_num;
  vector uvw)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

attribute_name
    The name of the attribute to read. *For point and vertex attributes,
    the value will at the given UV coordinates will be interpolated*
    from the surrounding points/vertices.

prim_num
    The primitive number to read the attribute from.

uvw
    The primitive UVW coordinates at which to read the attribute.

  * Returns the (possibly interpolated) value of the attribute at the
    given coordinates. If the attribute or primitive number don't exist,
    returns 0.

  * If you need to test for errors, you can use prim_attribute instead.

RELATED

  * prim_attribute

  * uvsample

}

{
primuvconvert

Convert parametric UV locations on curve primitives between different
spaces.

USAGE
  vector2 primuvconvert(string filename, vector2 uv, int prim_num, int
  mode)


texttype
    A string specifying a geometry file (for example, a .bgeo) to read
    from. When running inside Houdini, this can be an op:/path/to/sop
    reference.

uv
    Curve coordinates to convert. The function returns the converted
    coordinates.

prim_num
    The primitive number of the curve on which to convert the
    coordinates.

mode
    One of the PRIMUV_<space>_TO_<space> constants listed below. You can
    import the constants from $HFS/houdini/vex/include/math.h.

    REAL domain is based on the number of curve segments (0 to
    nSegments). A segment can hold multiple control points based on the
    curve degree. UNIT domain is the REAL domain normalized to fit in 0
    to 1. UNITLEN domain maps the curve based on its length but
    normalized (0..1). LEN domain maps the curve based on its length
    (0..CurveLength).

    PRIMUV_REAL_TO_UNIT

    0

    PRIMUV_REAL_TO_UNITLEN

    1

    PRIMUV_REAL_TO_LEN

    2

    PRIMUV_UNIT_TO_REAL

    3

    PRIMUV_UNIT_TO_UNITLEN

    4

    PRIMUV_UNIT_TO_LEN

    5

    PRIMUV_UNITLEN_TO_REAL

    6

    PRIMUV_UNITLEN_TO_UNIT

    7

    PRIMUV_UNITLEN_TO_LEN

    8

    PRIMUV_LEN_TO_REAL

    9

    PRIMUV_LEN_TO_UNIT

    10

    PRIMUV_LEN_TO_UNITLEN

    11

RELATED

}

{
primvertex

Converts a primitive/vertex pair into a linear vertex.

USAGE
  int primvertex(<geometry>, int primnum, int vertex)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

primnum
    The primitive number to get a vertex from.

vertex
    The vertex number inside the primitive. 0 is the first vertex.

    The linear vertex index corresponding to the given primitive vertex.
    Returns -1 if the function cannot find the linear vertex index.

EXAMPLES

  > 
  > int linearvtx;
  > 
  > // Get the linear vertex value of vertex 2 of primitive 3.
  > linearvtx = primvertex("defgeo.bgeo", 3, 2);

RELATED

}

{
primvertexcount

Returns number of vertices in a primitive in a geometry.

USAGE
  int primvertexcount(<geometry>, int prim_num)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

prim_num
    The primitive number of the primitive to count vertices on.

    The number of vertices in the given primitive, or -1 if the
    primitive does not exist.

EXAMPLES

  > int        nvtx;
  > 
  > // Get the number of vertices of primitive 3
  > nvtx = primvertexcount("defgeo.bgeo", 3);

RELATED

  * vertexindex

}

{
primvertices

Returns the list of vertices on a primitive.

USAGE
  int [] primvertices(<geometry>, int primnum)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

primnum
    The primitive number to get a vertex from.

    An array of linear vertex indices, in the same order as stored on
    the primitive itself. If the primitive number is not valid, the
    array will be empty.

RELATED

}

{
print_once

Prints a message only once, even in a loop.

USAGE
  void print_once(string msg, ...)

Prints the string passed to the function exactly one time, even in a
loop. This is useful to print a message before the first iteration of a
loop, without having to count iterations.


msg
    The string to print. This string does support interpolating values.
    Use sprintf to generate the <msg> string if you need to include
    values.

global
    Normally, multiple instances of print_once() call sites will work
    independently of each other. That is, if two separate call sites to
    print_once() are passed the same string, the string will be printed
    twice (once per call site). With the "global" flag turned on,
    strings are checked across all instances of the print_once()
    functions.

EXAMPLES

  > 
  > // Only print "Hello world" one time
  > for (int i = 0; i < 100; ++i)
  >     print_once("Hello world\n");
  > 
  > // Print a missing texture warning, just one time across all shaders
  > print_once( sprintf("Missing texture map: %s\n", texture_map), "global", 1);

RELATED

}

{
printf

Prints values to the console which started the VEX program.

USAGE
  void printf(string format, ...)

The format string is a simpler version of the C printf format string.
When a % symbol is found in the string, an argument will be printed out
in a format specified by the characters following the % symbol. The
conversion of the argument is specified by a single letter: g, f, s, d,
x, c, p.

You can prefix the format option with an optional prefix characters to
control the formatting of the output. The general form of a prefix is
[flags][width][.precision][format], where Flags can be:

  * -: The result will be left justified in the field

  * +: A numeric value will be prefixed with either + for positive
    values. A non-standard behavior of this flag is that string
    arguments will be quoted when the + flag is set.

  * 0: For numeric values, leading zeros are used to pad the field.


Width
    The width can be specified by one or more decimal digits.
    Alternately, if an asterisk (*) is given, the width will be taken
    from the next value in the printf argument list.

Precision
    The precision can be specified by one or more decimal digits.
    Alternately, if an asterisk (*) is given, the width will be taken
    from the next value in the printf argument list.

The different format characters supported are


%g, %p, %c
    Print an integer float, vector, vector4, matrix3, matrix or string
    in "general" form.

%f, %e, %E
    Print a float, vector, vector4, matrix3 or matrix in floating point
    form.

%s
    Print a string.

%d, %i
    Print an integer variable in decimal.

%x, %X
    Print an integer variable in hexidecimal. The value will be prefixed
    with "0x" (i.e. 0x42).

%o
    Print an integer variable in octal.

%%
    Print a percent sign (%).

EXAMPLES

  > printf("P = %g, dot(N, P) = %g, %d = %x\n", P, dot(N, P), ptnum, ptnum);
  > printf("RGB = {%g,%g,%g}\n", clr.r, clr.g, clr.b);
  > printf("P = %20s\n", "20 chars");
  > printf("%-+20s\n", "Left justified and quoted");
  > printf("%+08.3g\n", velocity);
  > printf("%*.*g\n", width, precision, value);
  > Cf = texture(sprintf("/maps/map%d.rat", i));
  > Cf = texture(sprintf("/maps/map%04d.rat", i));

RELATED

}

{
product

Returns the product of a list of numbers.

USAGES
  float product(float n)
  int product(int n)
  Returns the argument.

  float product(vector2 v)
  float product(vector v)
  float product(vector4 v)
  Returns the product of the vector's components.

  int product(int arr[])
  float product(float arr[])
  Returns the product of the items of the array.

  <vector> product(<vector> arr[])
  Returns a vector where the components are the products of the
  corresponding components in the vectors in the array.

RELATED

  * sum

  * outerproduct

}

{
ptexture

Computes a filtered sample from a ptex texture map. Use texture instead.

USAGES
  <type> ptexture(string map, int face_id, ...)
  <type> ptexture(string map, int face_id, float s, float t, ...)

This function is deprecated since ptex support has been integrated into
the texture() function.

OPTIONAL ARGUMENTS

    Keyword
    Values

    channel td>> An integer value indicating which channel of the ptex
    image to use.


    filter td>>


    filtersharp


    A floating point value indicating the filter sharpness. This is only
    valid for the bicubic filter. The range is 0-1 (the default is 1.0).


    lerp


    An boolean value indicating whether to interpolate between Mip maps.
    The default is true.


    blur


    The texture blur value used for evaluation (default 0).


    width


    The texture width value used for evaluation (default 1).

RELATED

  * texture

}

{
ptlined

This function returns the closest distance between the point Q and a
finite line segment between points P0 and P1.

USAGE
  float ptlined(vector P0, vector P1, vector Q)

This function returns the closest distance between the point <Q> and a
finite line segment between points <P0> and <P1>.

RELATED

}

{
ptransform

Transforms a vector from one space to another.

USAGES
  vector ptransform(vector vec, matrix transform)
  vector4 ptransform( vector4 vec; matrix transform)
  Transforms the vector using the given transform matrix.

  vector ptransform(string tospace, vector vec)
  Transforms from "space:current".

  vector ptransform(string fromspace, string tospace, vector vec)
  Transforms the vector from fromspace into tospace.


fromspace, tospace
    The possible values for the space arguments are:

    An object path

    Use the object space of an object specified by a path string.


    TIP
        In some cases, such as point instancing, mantra may
        automatically mangle object paths. You can generate an .ifd file
        and look inside to try to find what mantra is calling the object
        you want.

    "space:object"

    Object space of the _current_ object.

    "space:light"

    Object space of the _current_ light when executing a shadow or light
    shader.

    "space:world"

    Houdini world space.

    "space:camera"

    mantra camera space.

    "space:ndc"

    Normal Device Coordinate space.

    "space:lightndc"

    Normal Device Coordinate space for the _current_ light when
    executing a shadow or light shader.

    "space:current"

    The current space the vector is in.

    "space:world"

    Houdini world space.

  * ptransform interprets the vector as a position.

  * vtransform interprets the vector as a direction vector, and so
    doesn't apply the translations from the matrix.

  * ntransform interprets the vector as a normal vector, and so
    multiplies by the inverse transpose of the matrix (ignoring the
    translations).

EXAMPLES

    The version with only a <tospace> argument assumes <fromspace> is
    "space:current". For example:

  > Pworld = ptransform("space:world", P);

    ...is equivalent to:

  > Pworld = ptransform("space:current", "space:world", P);

    Transform a vector from its current space to object space:

  > ospace = ptransform("space:object", P)

    Transform a vector from object space to mantra's natural coordinate
    space ("camera" space):

  > ospace = ptransform("space:object", "space:current", P)

RELATED

  * ntransform

  * vtransform

  * getspace

}

{
push

Adds an item to an array.

USAGES
  void push(<type> &array[]; <type> value)
  Appends the given value to the end of the array. Increases the size of
  array by 1. This is the same as append(array, value).

  void push(<type> &array[]; <type> values[])
  Concatenates the values from the values array to the end of array.
  Increases the size of array by len(values). This is the same as
  append(array, values).


TIP
    You can set an individual item in an array using array[n] = x.

RELATED

  * Arrays

  * len

  * append

  * resize

}

{
qconvert

Converts a quaternion represented by a vector4 to a matrix3
representation.

USAGE
  matrix3 qconvert(vector4 quaternion)

Converts a quaternion represented by a vector4 to a matrix3
representation.

USAGE
  vector qconvert(vector4 quaternion)

Converts a quaternion represented by a vector4 into a angle/axis vector.

RELATED

}

{
qdistance

Finds distance between two quaternions.

USAGE
  float qdistance(vector4 q1, vector4 q2)

Returns the approximate angle, in radians, between two quaternions.

RELATED

}

{
qinvert

Inverts a quaternion rotation.

USAGE
  vector4 qinvert(vector4 quaternion)

Creates the inverse quaternion to the supplied one. This will rotate
points in the opposite direction.

RELATED

}

{
qmultiply

Multiplies two quaternions and returns the result.

USAGE
  vector4 qmultiply(vector4 q1, vector4 q2)

Multiplies two quaternions and returns the result.

RELATED

}

{
qrotate

Rotates a vector by a quaternion.

USAGE
  vector qrotate(vector4 quaternion, vector v)

Returns the vector v rotated by the given quaternion.

RELATED

}

{
quaternion

Creates a vector4 representing a quaternion.

USAGE
  vector4 quaternion(matrix3 rotations)

Creates a vector4 representing a quaternion from a 3x3 rotational
matrix.

USAGE
  vector4 quaternion(float angle, vector axis)

Creates a vector4 representing a quaternion from an <angle> and <axis>.
The <angle> is specified in radians.

USAGE
  vector4 quaternion(vector angleaxis)

Creates a vector4 representing a quaternion from a combined angle/axis.
This is the normalized rotation axis multiplied by the rotation angle in
radians.

There used to be a fourth form that took a rotation vector. It has been
renamed to eulertoquaternion and now takes radians.

RELATED

  * dihedral

  * qconvert

  * eulertoquaternion

}

{
radians

Converts the argument from degrees into radians.

USAGES
  float radians(float num_in_degs)
  Converts the number of degrees in the argument to radians.

  <vector> radians(<vector> nums_in_degs)
  Returns a new vector with atan() applied to each component.


TIP
    The VEX trig functions work with radians, but most users are more
    comfortable with degrees. You may want to convert from radians for
    internal use to degrees in the UI.

RELATED

  * degrees

}

{
rand

Creates a random number between 0 and 1 from a seed.

USAGES
  float rand(float seed)
  vector2 rand(float seed)
  vector rand(float seed)
  vector4 rand(float seed)
  float rand(float seed, float seed2)
  vector2 rand(float seed, float seed2)
  vector rand(float seed, float seed2)
  vector4 rand(float seed, float seed2)
  float rand(vector2 seed)
  vector2 rand(vector2 seed)
  vector rand(vector2 seed)
  vector4 rand(vector2 seed)
  float rand(vector seed)
  vector2 rand(vector seed)
  vector rand(vector seed)
  vector4 rand(vector seed)
  float rand(vector4 seed)
  vector2 rand(vector4 seed)
  vector rand(vector4 seed)
  vector4 rand(vector4 seed)

Creates a random number based on the provided seed. The number will be
in the range of 0 to 1. The same number is produced for the same seed,
so to vary the random number the seed should be varied.

Note that even the smallest changes in the seed value will produce
completely different numbers, so it may produce different results on
different operating systems or compilers.

If the result is a vector2, vector, or vector4, each component will be a
different random number. Thus, if you have the code:

> 
> vector        pos = 1;
> float        seed = 0;
> 
> pos *= rand(seed);

pos will get different values in its .x, .y, and .z components. If you
wish a uniform scale, use the float() cast:

> 
> vector        pos = 1;
> float        seed = 0;
> 
> pos *= float(rand(seed));

RELATED

  * random_fhash

  * random_ihash

  * random_shash

}

{
random

Generate a random number based on the position in 1-4D space.

USAGES
  float random(int|float position)
  vector random(int|float position)
  vector2 random(int position)
  vector4 random(int|float position)
  Generate 1D, 2D, 3D, or 4D noise based on a 1D position.

  float random(int|float xpos, int|float ypos)
  vector random(int|float xpos, int|float ypos)
  vector4 random(int|float xpos, int|float ypos)
  Specify a 2D position in the noise field using two numbers.

  float random(vector position)
  vector random(vector position)
  vector4 random(vector position)
  Specify a 3D position in the noise field using a vector.

  float random(vector4 position)
  vector random(vector4 position)
  vector4 random(vector4 position)
  Specify a 4D position in the noise field using a vector4.

Generate a random number based on the position in N dimensional space
(where N is 1 to 4 dimensions). Unlike the noise functions, the random
functions do not smoothly interpolate the random values between integer
lattice points. The random() functions are very efficient ways of doing
something like noise(floor(position)).

RELATED

}

{
random_fhash

Hashes floating point numbers to integers.

USAGES
  int random_fhash(float seed)
  int random_fhash(float seed, float seed2)
  int random_fhash(vector seed)
  int random_fhash(vector4 seed)
  int random_fhash(vector2 seed)

Hashes the given number into an integer value. The hash may vary for
even the smallest differences in inputs.

RELATED

}

{
random_ihash

Hashes integer numbers to integers.

USAGE
  int random_ihash(int seed)

Hashes the given number into an integer value.

RELATED

}

{
random_shash

Hashes a string to an integer.

USAGE
  int random_shash(string seed)

Hashes the given string into an integer value.


NOTE
    Two different strings may hash to the same value.

RELATED

}

{
random_sobol

Generate a uniformly distributed random number.

USAGES
  float random_sobol( float seed; int offset)
  float random_sobol( int seed; int offset)
  float random_sobol( vector4 seed; int offset)
  float random_sobol( vector seed; int offset)
  vector4 random_sobol( float seed; int offset)
  vector4 random_sobol( int seed; int offset)
  vector4 random_sobol( vector4 seed; int offset)
  vector4 random_sobol( vector seed; int offset)
  vector random_sobol( float seed; int offset)
  vector random_sobol( int seed; int offset)
  vector random_sobol( vector4 seed; int offset)
  vector random_sobol( vector seed; int offset)

When generating a sequence of random numbers you will notice that it
tends to clump. Sometimes you want a bunch of samples that are better
distributed, however. A sobol sequence is a series of random numbers
which are relatively evenly distributed.

The seed allows you to select different sobol sequences. If it is a
floating point seed, note very small differences will select very
different sequences.

The offset is which entry in the sequence to extract. This should be an
integer sequence, like ptnum, in order for the distribution property to
work.

Each number is in the [0..1) range.

RELATED

}

{
rawbumpmap

RELATED

}

{
rawbumpmapA

RELATED

}

{
rawbumpmapB

RELATED

}

{
rawbumpmapG

RELATED

}

{
rawbumpmapL

RELATED

}

{
rawbumpmapR

RELATED

}

{
rawcolormap

Looks up an unfiltered color from a texture file.

USAGES
  vector|vector4 rawcolormap(string filename, vector uvw, ...)
  vector|vector4 rawcolormap(string filename, float u, float v, ...)
  vector|vector4 rawcolormap(string filename, vector uv, vector du,
  vector dv, int samples, ...)
  vector|vector4 rawcolormap(string filename, vector uv0, vector uv1,
  vector uv2, vector uv3, ...)
  vector|vector4 rawcolormap(string filename, vector uv0, vector uv1,
  vector uv2, vector uv3, int samples, ...)
  vector|vector4 rawcolormap(string filename, float u0, float v0, float
  u1, float v1, float u2, float v2, float u3, float v3, int samples,
  ...)

This function has the same arguments as colormap, but does not do
bilinear interpolation of the pixel values. See colomap() for
information on the arguments.

If you call the function with a vector4 return type, the fourth
component is the alpha channel of the texture. If the image does not
have alpha, the fourth component is always 1.

RELATED

  * colormap

  * texture

}

{
rayhittest

Sends a ray from the position P along the direction D.

USAGES
  float rayhittest( vector P; vector D; float bias; ... )
  float rayhittest( vector P; vector D; vector &pHit; vector &nHit;
  float bias; ... )

Sends a ray from the position <P> along the direction <D>. The length of
the <D> vector represents the farthest distance considered when check
for occlusion.

Returns the distance to the object intersected. If no object is hit,
returns less than 0.

If you specify <pHit> and <nHit>, they get the position and normal of
the hit surface.

In many cases, the area sampling features will not produce usable
results with the rayhittest() function.


TIP
    When hit testing polygons you can get lots of rays missing. In these
    cases triangulating the geometry can improves hits.

AREA SAMPLING OPTIONS

    For area sampling, you must specify both the angle and sample
    variadic parameters. For example:

  > surface
  > blurry_mirror(float angle = 3; int samples = 16; float bias=0.05)
  > {
  >     Cf = reflectlight(bias, 1, "angle", angle, "samples", samples);
  > }

RAY OPTIONS


    TIP
        When you specify a texture, such as with the "environment"
        keyword, you can also use the image filtering keyword arguments.
        See environment for a listing of the image filter keyword
        arguments.


    scope
        A list of objects which can be hit by the rays. When specified,
        scope overrides the default scope that would have been selected
        for the given raystyle. The "scope:default" value will cause the
        scope argument to use the default scope for the current context
        - as if the argument were not specified.

        Allows an override of the scope for ray-intersections. A special
        scope argument, scope:self, will match the currently shading
        object.

    maxdist
        The maximum distance to search for objects. This can be used to
        limit the search of objects to nearby objects only. If the
        maxdist given is negative, then it will act as if there is no
        maximum distance.

        Allows an override of the maximum distance the ray can travel
        when testing for intersections. Some functions (such as
        fastshadow) have the maximum distance implicitly defined (by the
        length of the ray) and should probably avoid using this option.
        However, this option can be used effectively when computing
        reflections, global illumination, refraction etc.

    variancevar
        The name of a VEX export variable to use for variance anti-
        aliasing. The renderer compares the value with adjacent
        micropolygons in micropolygon rendering to decide what shading
        points need additional samples (using vm_variance property as a
        threshold). If more samples are required, the algorithm takes
        samples up to the specified maximum ray samples.

        This variable must be imported from the hit surface, so it must
        be in the list of imported names (see "importing information
        back from the ray" below). If the named variable is not
        imported, this option will be ignored.

        Variance antialiasing puts more samples in areas of the image
        with high variance, for example a sharp shadow edge. It is only
        used when vm_dorayvariance is enabled. Otherwise, only the min
        ray samples (or an explicitly supplied "samples" value) are used
        for antialiasing of the gather loop.

        Overrides the global variance control (mantra's -v option) which
        is used to determine anti-aliasing quality of ray tracing. For
        more information please refer to the documentation on mantra.

    angle
        The distribution angle (specified in radians). For gather(),
        rays will be distributed over this angle. For trace(), the angle
        is used to indicate the rate at which the filter width should
        increase with increasing intersection distance. Larger angles
        will cause farther hit surfaces to use larger derivatives,
        leading to improved texturing and displacement performance.

        To be effective, the samples parameter should also be specified.

    samples
        How many samples should be sent out to filter rays. For the
        irradiance and occlusion functions, specifying a samples
        parameter will override the default irradiance sampling.

    environment
        If the ray sent out to the scene misses everything, then it's
        possible to specify an environment map to evaluate.

        Using the ray's direction, the environment map specified will be
        evaluated and the resulting color will be returned. Most likely,
        it will be necessary to specify a transform space for the
        environment map evaluations.

        In the case of refractlight and trace the Of and Af variables
        will be set to 0 regardless of the background color specified.
        the resulting color.

        When an environment map is specified, the filtering options from
        texture() are also supported.

        See how to create an environment/reflection map.

    envobject
        If an environment map is used, the orientation of the
        environment map can be specified by transforming the ray into
        the space of another object, light or fog object in the scene.
        In Houdini, null objects can be used to specify the orientation.
        For example:

      > Cf = R*reflectlight(bias, max(R), "environment", "map.rat", "envobject", "null_object_name");

    envlight
        If an environment map is used, the orientation of the
        environment map can be specified by transforming the ray into
        the space of a light in the scene.

    envtint
        If an environment map is used, tint it with this color.

    background
        If a ray misses all objects, use this as the background color of
        the scene. In the case of refractlight and trace the Of and Af
        variables will be set to 0 regardless of the background color
        specified.

    distribution
        *Functions*: irradiance, occlusion

        Distribution for computing irradiance. The default is to use a
        cosine distribution (diffuse illumination). The possible values
        for the style are "nonweighted" for uniform sampling or "cosine"
        for cosine weighted sampling.

RELATED

  * trace

}

{
rayimport

Imports a value sent by a shader in a gather loop.

USAGE
  int rayimport(string name, <type> &value)
  Extracts information any passed when the surface is hit by a ray fired
  by the gather.


name
    The variable name, as passed using a "send:<name>", value argument
    pair in gather (without the send: prefix).

value
    If the function can import the named variable, it overwrites this
    variable with the value.

    1 if a value by the given name was successfully imported, or 0
    otherwise.

See gather for more information.

RELATED

  * gather

  * simport

}

{
re_find

Matches a regular expression in a string

USAGES
  int re_find(const string regex, const string input)
  int re_find(const string regex, const string input, const int start)
  int re_find(const string regex, const string input, const int start,
  const int end)
  Returns 1 if regex matches in input, or 0 otherwise.

  string re_find(const string regex, const string input)
  string re_find(const string regex, const string input, const int
  start)
  string re_find(const string regex, const string input, const int
  start, const int end)
  Returns the first substring that matches regex in input.

  int re_find(int &start_pos[], int &end_pos[], const string regex,
  const string input)
  int re_find(int &start_pos[], int &end_pos[], const string regex,
  const string input, const int start)
  int re_find(int &start_pos[], int &end_pos[], const string regex,
  const string input, const int start, const int end)
  Returns 1 if regex matches in input, or 0 otherwise. Fills the
  start_pos and end_pos array variables with the start and end positions
  of each match.

  string[] re_find(const string regex, const string input)
  string[] re_find(const string regex, const string input, const int
  start)
  string[] re_find(const string regex, const string input, const int
  start, const int end)
  Returns an array of substrings that match regex in input.

RELATED

  * re_match

  * re_findall

  * re_replace

  * re_split

}

{
re_findall

Finds all instances of the given regular expression in the string

USAGES
  string[] re_findall(const string regex, const string input)
  string[] re_findall(const string regex, const string input, const int
  start)
  string[] re_findall(const string regex, const string input, const int
  start, const int end)

Returns an array of all strings that match the entire regex expression
(no capture groups).

RELATED

  * re_find

  * re_match

  * re_replace

  * re_split

}

{
re_match

Returns 1 if the entire input string matches the expression

USAGE
  int re_match(const string regex, const string input)

Returns 1 if the entire input string matches the regex, or 0 if it
doesn't match.

RELATED

  * re_find

  * re_findall

  * re_replace

  * re_split

}

{
re_replace

Replaces instances of regex_find with regex_replace

USAGE
  string re_replace(string regex, string replacement, string input, int
  maxreplace=0)

Returns a string where each non-overlapping match of regex is replaced
with replacement. The replacement string can reference captured groups
from the regex using $1 syntax.

If maxreplace is given and not 0, it specifies the maximum number of
replacements to do.

RELATED

  * re_match

  * re_find

  * re_findall

  * re_split

}

{
re_split

Splits the given string based on regex match.

USAGE
  string[] re_split(const string regex, const string input, const int
  maxsplits=0)

Splits the input string into substrings between matches of regex.

If maxsplits is given and not 0, it specifies the maximum number of
splits to do.

RELATED

  * split

  * re_match

  * re_find

  * re_findall

  * re_replace

}

{
reflect

Returns the vector representing the reflection of the direction against
the normal.

USAGE
  vector reflect(vector direction, vector normal)

Returns the vector representing the reflection of the <direction>
against the <normal>.

RELATED

}

{
reflectlight

Computes the amount of reflected light which hits the surface.

USAGES
  vector reflectlight(float bias, float max_contrib, ...)
  <bias> is typically a small number (for example 0.005) used to help
  eliminate self-reflection. If <bias> is less than 0, the default ray
  tracing bias specified with the vm_raybias setting will be used
  instead.

  <max_contrib> tells the renderer how much the reflected light will
  contribute to the final color of the pixel. This is typically the
  maximum of the reflection component of a lighting model. This has no
  effect on the resultant color. This value should typically be less
  than 1.

  vector reflectlight(vector P, vector D, float bias, float max_contrib,
  ...)
  A general form which takes a position <P> and a direction <D>.

  vector reflectlight(vector P, vector N, vector I, float bias, float
  max_contrib, ...)
  A general form which takes a position <P>, direction <D>, and incident
  angle <I> and returns the reflection vector.

AREA SAMPLING OPTIONS

    For area sampling, you must specify both the angle and sample
    variadic parameters. For example:

  > surface
  > blurry_mirror(float angle = 3; int samples = 16; float bias=0.05)
  > {
  >     Cf = reflectlight(bias, 1, "angle", angle, "samples", samples);
  > }

RAY OPTIONS


    TIP
        When you specify a texture, such as with the "environment"
        keyword, you can also use the image filtering keyword arguments.
        See environment for a listing of the image filter keyword
        arguments.


    scope
        A list of objects which can be hit by the rays. When specified,
        scope overrides the default scope that would have been selected
        for the given raystyle. The "scope:default" value will cause the
        scope argument to use the default scope for the current context
        - as if the argument were not specified.

        Allows an override of the scope for ray-intersections. A special
        scope argument, scope:self, will match the currently shading
        object.

    maxdist
        The maximum distance to search for objects. This can be used to
        limit the search of objects to nearby objects only. If the
        maxdist given is negative, then it will act as if there is no
        maximum distance.

        Allows an override of the maximum distance the ray can travel
        when testing for intersections. Some functions (such as
        fastshadow) have the maximum distance implicitly defined (by the
        length of the ray) and should probably avoid using this option.
        However, this option can be used effectively when computing
        reflections, global illumination, refraction etc.

    variancevar
        The name of a VEX export variable to use for variance anti-
        aliasing. The renderer compares the value with adjacent
        micropolygons in micropolygon rendering to decide what shading
        points need additional samples (using vm_variance property as a
        threshold). If more samples are required, the algorithm takes
        samples up to the specified maximum ray samples.

        This variable must be imported from the hit surface, so it must
        be in the list of imported names (see "importing information
        back from the ray" below). If the named variable is not
        imported, this option will be ignored.

        Variance antialiasing puts more samples in areas of the image
        with high variance, for example a sharp shadow edge. It is only
        used when vm_dorayvariance is enabled. Otherwise, only the min
        ray samples (or an explicitly supplied "samples" value) are used
        for antialiasing of the gather loop.

        Overrides the global variance control (mantra's -v option) which
        is used to determine anti-aliasing quality of ray tracing. For
        more information please refer to the documentation on mantra.

    angle
        The distribution angle (specified in radians). For gather(),
        rays will be distributed over this angle. For trace(), the angle
        is used to indicate the rate at which the filter width should
        increase with increasing intersection distance. Larger angles
        will cause farther hit surfaces to use larger derivatives,
        leading to improved texturing and displacement performance.

        To be effective, the samples parameter should also be specified.

    samples
        How many samples should be sent out to filter rays. For the
        irradiance and occlusion functions, specifying a samples
        parameter will override the default irradiance sampling.

    environment
        If the ray sent out to the scene misses everything, then it's
        possible to specify an environment map to evaluate.

        Using the ray's direction, the environment map specified will be
        evaluated and the resulting color will be returned. Most likely,
        it will be necessary to specify a transform space for the
        environment map evaluations.

        In the case of refractlight and trace the Of and Af variables
        will be set to 0 regardless of the background color specified.
        the resulting color.

        When an environment map is specified, the filtering options from
        texture() are also supported.

        See how to create an environment/reflection map.

    envobject
        If an environment map is used, the orientation of the
        environment map can be specified by transforming the ray into
        the space of another object, light or fog object in the scene.
        In Houdini, null objects can be used to specify the orientation.
        For example:

      > Cf = R*reflectlight(bias, max(R), "environment", "map.rat", "envobject", "null_object_name");

    envlight
        If an environment map is used, the orientation of the
        environment map can be specified by transforming the ray into
        the space of a light in the scene.

    envtint
        If an environment map is used, tint it with this color.

    background
        If a ray misses all objects, use this as the background color of
        the scene. In the case of refractlight and trace the Of and Af
        variables will be set to 0 regardless of the background color
        specified.

    distribution
        *Functions*: irradiance, occlusion

        Distribution for computing irradiance. The default is to use a
        cosine distribution (diffuse illumination). The possible values
        for the style are "nonweighted" for uniform sampling or "cosine"
        for cosine weighted sampling.

IMAGE FILTERING OPTIONS

    Examples of specifying filter parameters:

  > colormap(map, u, v, "smode", "decal", "tmode", "repeat", "border", {.1,1,1});
  > colormap(map, u, v, "mode", "clamp", "width", 1.3);
  > colormap(map, u, v, "filter", "gauss", "width", 1.3, "mode", "repeat");

    If the texture is a deep .rat file, you can use the "channel"
    keyword argument to specify a channel in the file:

  > string channelname = "N";
  > cf = colormap(map, u, v, "channel", channelname);

    wrap

        repeat or periodic
            The image map will repeat outside the range 0 to 1.
            Basically, the integer component of the texture coordinate
            is ignored. This is the default.

        clamp or edge or streak
            The texture coordinates will be clamped to the range 0 to 1.
            This causes evaluations outside the range to evaluate to the
            color at the closest edge of the image (the border pixels
            are streaked outside the range).

        black or decal or color
            Coordinates outside the range 0 to 1 will evaluate to the
            border color (rather than a color in the image). The border
            color is black (i.e. 0) by default.

    uwrap
        (AKA swrap) Specifies the behavior when the u coordinate is
        outside the range 0 to 1. The values are the same as with wrap.

    vwrap
        (AKA twrap) Specifies the behavior when the v coordinate is
        outside the range 0 to 1. The values are the same as with wrap.

    border
        Specifies the border color when Black/Decal/Color wrapping is
        used.

    channel
        Specifies the color channel for textures that have multiple
        color planes (for example, diffuse_indirect or N). For ptex
        images, this specifies the index of the first channel (for
        example, 0 or 4).

    blur
        Blurs in x and y directions. Blur is measured as a percentage of
        the image size - so a blur of 0.1 will blur 10% of the image
        width. Use xblur and yblur if you need different blur amounts in
        either dimension.

    xblur
        (AKA ublur, sblur) Blur amount in the x image direction.

    yblur
        (AKA vblur, tblur) Blur amount in the y image direction.

    pixelblur
        Blurs the texture by a floating point number of pixels.

      > Cf = texture("map.rat", ss, tt, "pixelblur", 2.0);

    xpixelblur
        Blurs the texture by a floating point number of pixels in the X
        direction.

    ypixelblur
        Blurs the texture by a floating point number of pixels in the Y
        direction.

    filter
        Specifies the type of anti-aliasing filter to be used for
        evaluation. The following argument should be a string specifying
        one of:


        point
            Point sampling (i.e. no filtering)

        box
            Box filter (default)

        gauss
            Gaussian filter

        bartlett
            Bartlett/Triangular filter

        sinc
            Sinc sharpening filter

        hanning
            Hanning filter

        blackman
            Blackman filter

        catrom
            Catmull-Rom filter

    xfilter
        (AKA ufilter, sfilter) Specifies the filter for the X direction.
        The filters are the same as with filter.

    yfilter
        (AKA vfilter, tfilter) Specifies the filter for the Y direction.
        The filters are the same as with filter.

    width
        Filter width in both X and Y directions.

    xwidth
        (AKA uwidth, swidth) Filter width in the X direction.

    ywidth
        (AKA vwidth, twidth) Filter width in the Y direction.

    zwidth
        Filter width in the Z direction (for shadow maps). This is
        measured in world space units, unlike the other width arguments.

    extrapolate
        whether to use derivative extrapolation when computing anti-
        aliasing information. Extrapolation of derivatives is on by
        default. The argument should be either 0 or 1.

    lerp
        Specifies whether RAT files should interpolate between different
        MIP levels. By default, this is turned off. Turning
        interpolation on will help remove discontinuities when different
        MIP levels of a .rat file are accessed. However, the results of
        texture evaluation will be slightly softer (i.e. blurrier) and
        will take more time.

        There are three possible values for this argument.


        0
            Disable MIP map interpolation (fastest).

        1
            Approximate MIP map interpolation (fast).

        2
            High Quality MIP map interpolation (slower but highest
            quality).

    depthinterp
        Specifies the depth interpolation mode for deep shadow maps, to
        control the opacity value that will be returned when the map is
        sampled between two z-records.

        The argument must be a string.


        discrete
            (default) Return the first z-record before the sample point.

        linear
            Linearly interpolate the opacities of the z-records before
            and after the sample point.

        See deep shadow maps for more on the difference between the two
        modes.

    beerlambert
        When evaluating volumetric deep shadow maps, this will enable
        Beer-Lambert interpolation of opacity. Beer-Lambert is more a
        accurate but more expensive form of interpolation.

        The argument should be either 0 or 1.

    srccolorspace
        Specifies the color space in which the texture is stored. When
        texture values are accessed, they will be translated from this
        space into linear space for rendering if needed.


        auto
            (default) Determine the source color space based on the
            file. Currently, this will assume sRGB color space for 8-bit
            textures and linear for all other textures.

        linear
            Transform to linear space. This currently only affects 8-bit
            textures, since all others are assumed to be already in
            linear space. Use this option to force linear interpretation
            of textures used for bump or displacement maps.

    face
        When using a Ptex texture map, the face argument is used to
        specify the face for ptexture lookup.

    ptexorient
        When using Ptex textures, the implicit texture coordinates on
        polygons are used as the interpolants for texture lookup
        (combined with the face). However, different software may have
        different beliefs about winding and orientation. This keyword
        argument allows you to control the interpretation of orientation
        for Houdini polygons. The ptexorient expects an integer argument
        which is composed of a bit-field

        For example, a value of 6 (0x4|0x2) is equivalent to calling
        texture(map, 1-t, s) instead of texture(map, s, t).

        The default ptexorient is 0, which works correctly with the
        examples found at .

EXAMPLES

  > surface mirror(vector refl_color=1; float bias=.005)
  > {
  >     Cf = refl_color * reflectlight(bias, max(refl_color));
  > }

RELATED

  * refractlight

  * gather

  * trace

  * irradiance

}

{
refract

Returns the refraction ray given an incoming direction, the normalized
normal and an index of refraction.

USAGE
  vector refract(vector direction, vector normal, float index)

Returns the refraction ray given an incoming <direction>, the normalized
<normal> and an <index> of refraction.

The <index> is a relative index of refraction, the ratio between the
interior and exterior index of refraction, where the exterior is defined
by the direction of the normals (normals point away from the interior).

In the case of total internal reflection, this function returns the
reflection vector.

For example:

> refract(normalize(I), normalize(N), outside_to_inside_ior)

RELATED

  * fresnel

}

{
refractlight

Computes the illumination of surfaces refracted by the current surface.

USAGES
  void refractlight(vector &cf, vector &of, float &af, vector P, vector
  D, float bias, float max_contrib, ...)
  void refractlight(vector &cf, vector &of, float &af, vector P, vector
  N, vector I, float eta, float bias, float max_contrib, ...)

Computes the illumination of surfaces refracted by the current surface.
Computes and outputs the output color (<cf>), opacity (<of>) and alpha
(<af>). See opacity vs. alpha .

<bias> is typically a small number (for example 0.005) used to help
eliminate self-reflection.

<max_contrib> tells the renderer how much the reflected light will
contribute to the final color of the pixel. This has no effect on the
resultant color.

The first form of the refractlight() function takes a position and
direction, typically computed by the refract or fresnel functions.

To prevent the renderer from computing standard transparency (i.e. non-
refracted transparency), the Of variable must be set to {1,1,1} to make
the surface "opaque". The Af variable can be set to any arbitrary value.

LIGHT INCLUSION/EXCLUSION OPTIONS


    categories
        Specifies lights to include/exclude by their "category" tags.
        This is the preferred include/exclude lights rather than pattern
        matching light names with the "lightmask" keyword argument.

        For example:

      > diff = diffuse(nml, "lightmask", "hero | fill");

        See light categories for more information.

    lightmask
        When evaluating light and shadow shaders, objects have pre-
        defined light masks. This mask is usually specified in the
        geometry object and specifies a list of lights which are used to
        illuminate a surface or fog shader. It is possible to override
        the default light mask by specifying a "lightmask" argument.

        For example:

      > diff = diffuse(nml, "lightmask", "light*,^light2");

        ...will cause all lights whose names begin with "light" except
        for a light named "light2" to be considered for diffuse
        illumination.

        All Houdini scoping patterns, excepting group expansion, are
        supported:

      * * - wild-card match

      * ? - single character match

      * ^ - exclusion operator

      * [list] - character list match

AREA SAMPLING OPTIONS

    For area sampling, you must specify both the angle and sample
    variadic parameters. For example:

  > surface
  > blurry_mirror(float angle = 3; int samples = 16; float bias=0.05)
  > {
  >     Cf = reflectlight(bias, 1, "angle", angle, "samples", samples);
  > }

RAY OPTIONS


    TIP
        When you specify a texture, such as with the "environment"
        keyword, you can also use the image filtering keyword arguments.
        See environment for a listing of the image filter keyword
        arguments.


    scope
        A list of objects which can be hit by the rays. When specified,
        scope overrides the default scope that would have been selected
        for the given raystyle. The "scope:default" value will cause the
        scope argument to use the default scope for the current context
        - as if the argument were not specified.

        Allows an override of the scope for ray-intersections. A special
        scope argument, scope:self, will match the currently shading
        object.

    maxdist
        The maximum distance to search for objects. This can be used to
        limit the search of objects to nearby objects only. If the
        maxdist given is negative, then it will act as if there is no
        maximum distance.

        Allows an override of the maximum distance the ray can travel
        when testing for intersections. Some functions (such as
        fastshadow) have the maximum distance implicitly defined (by the
        length of the ray) and should probably avoid using this option.
        However, this option can be used effectively when computing
        reflections, global illumination, refraction etc.

    variancevar
        The name of a VEX export variable to use for variance anti-
        aliasing. The renderer compares the value with adjacent
        micropolygons in micropolygon rendering to decide what shading
        points need additional samples (using vm_variance property as a
        threshold). If more samples are required, the algorithm takes
        samples up to the specified maximum ray samples.

        This variable must be imported from the hit surface, so it must
        be in the list of imported names (see "importing information
        back from the ray" below). If the named variable is not
        imported, this option will be ignored.

        Variance antialiasing puts more samples in areas of the image
        with high variance, for example a sharp shadow edge. It is only
        used when vm_dorayvariance is enabled. Otherwise, only the min
        ray samples (or an explicitly supplied "samples" value) are used
        for antialiasing of the gather loop.

        Overrides the global variance control (mantra's -v option) which
        is used to determine anti-aliasing quality of ray tracing. For
        more information please refer to the documentation on mantra.

    angle
        The distribution angle (specified in radians). For gather(),
        rays will be distributed over this angle. For trace(), the angle
        is used to indicate the rate at which the filter width should
        increase with increasing intersection distance. Larger angles
        will cause farther hit surfaces to use larger derivatives,
        leading to improved texturing and displacement performance.

        To be effective, the samples parameter should also be specified.

    samples
        How many samples should be sent out to filter rays. For the
        irradiance and occlusion functions, specifying a samples
        parameter will override the default irradiance sampling.

    environment
        If the ray sent out to the scene misses everything, then it's
        possible to specify an environment map to evaluate.

        Using the ray's direction, the environment map specified will be
        evaluated and the resulting color will be returned. Most likely,
        it will be necessary to specify a transform space for the
        environment map evaluations.

        In the case of refractlight and trace the Of and Af variables
        will be set to 0 regardless of the background color specified.
        the resulting color.

        When an environment map is specified, the filtering options from
        texture() are also supported.

        See how to create an environment/reflection map.

    envobject
        If an environment map is used, the orientation of the
        environment map can be specified by transforming the ray into
        the space of another object, light or fog object in the scene.
        In Houdini, null objects can be used to specify the orientation.
        For example:

      > Cf = R*reflectlight(bias, max(R), "environment", "map.rat", "envobject", "null_object_name");

    envlight
        If an environment map is used, the orientation of the
        environment map can be specified by transforming the ray into
        the space of a light in the scene.

    envtint
        If an environment map is used, tint it with this color.

    background
        If a ray misses all objects, use this as the background color of
        the scene. In the case of refractlight and trace the Of and Af
        variables will be set to 0 regardless of the background color
        specified.

    distribution
        *Functions*: irradiance, occlusion

        Distribution for computing irradiance. The default is to use a
        cosine distribution (diffuse illumination). The possible values
        for the style are "nonweighted" for uniform sampling or "cosine"
        for cosine weighted sampling.

EXAMPLES

  > surface
  > glass(float eta=1.3, bias = 0.005)
  > {
  >     float    Kr, Kt;
  >     vector    R, T;
  >     vector    cf, of;
  >     float    af;
  >     frensel(normalize(I), normalize(N), eta, Kr, Kt, R, T);
  >     Cf  = Kr * reflectlight(P, R, bias, Kr);
  >     refractlight(cf, of, af, P, T, bias, Kt);
  >     Cf += Kt * cf;
  >     Af = clamp(Kr + af*Kt, 0, 1);
  >     Of = 1;
  > }

RELATED

  * reflectlight

  * gather

  * trace

  * irradiance

}

{
relativepath

Computes the relative path for two full paths.

USAGE
  string relativepath(string src, string dest)

Computes the relative path required to get from the src path to the dest
path.

EXAMPLES

  * relativepath("/obj/geo1/box", "/obj/ropnet1/mantra1") - returns
    ../../ropnet1/mantra1

RELATED

}

{
relbbox

Returns the relative position of the point given with respect to the
bounding box of the geometry.

USAGES
  vector relbbox(<geometry>, vector position)
  Returns the relative position of the point given with respect to the
  bounding box of the primitives in the geometry.

  vector relbbox(<geometry>, string primgroup, vector position)
  Use the bounding box of the primitives in the named primitive group.

  vector relbbox(vector position)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

RELATED

  * relpointbbox

  * pointbbox()

  * bbox()

}

{
relpointbbox

Returns the relative position of the point given with respect to the
bounding box of the geometry.

USAGES
  vector relpointbbox(<geometry>, vector position)
  Returns the relative position of the point given with respect to the
  bounding box of the points in the geometry.

  vector relpointbbox(<geometry>, string pointgroup, vector position)
  Use the bounding box of the primitives in the named point group.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

RELATED

  * relbbox

  * pointbbox()

  * bbox()

}

{
removegroup

WARNING
    This function has been deprecated. Use setpointgroup instead.

RELATED

}

{
removeindex

Removes an item at the given index from an array.

USAGE
  <type> removeindex(<type> &array[]; int index)
  Removes the item at index from array and returns its value. This is
  the same as pop(array, index) but has a slightly clearer name.

  A negative index counts from the end of the array, so
  removeindex(array, -2) removes the second-to-last item.

RELATED

  * Arrays

  * pop

  * removevalue

}

{
removepoint

Removes a point from the geometry.

USAGES
  int removepoint(int geohandle, int point_number)
  int removepoint(int geohandle, int point_number, int andprims)

Removes a point in the geometry specified by geohandle.

If the point_number is -1, nothing is done.

If andprims is 1, any valid but degenerate primitives, (for example,
closed polygons with fewer than 3 vertices or open polygons with fewer
than 2 vertices), that referred to the specified point will be deleted.
If andprims is 0, primitives will only be deleted if they become
invalid, (for example, tetrahedra cannot have fewer than 4 vertices, and
volumes cannot have zero vertices).

RELATED

}

{
removeprim

Removes a primitive from the geometry.

USAGE
  int removeprim(int geohandle, int prim_number, int andpoints)

Removes a primitive in the geometry specified by geohandle.

If the prim_number is -1, nothing is done.

If andpoints is 1, the points that the primitive owns will also be
deleted if there are no other primitives still referring to them.

RELATED

}

{
removevalue

Removes an item from an array.

USAGE
  int removevalue(<type> &array[]; <type> value)
  Removes the first instance of value found from the array. Returns 1 if
  an item was removed, or 0 otherwise.

EXAMPLES

  > float nums[] = {0, 1, 2, 3, 1, 2, 3};
  > removevalue(nums; 2);  // == 1
  > // nums == {0, 1, 3, 1, 2, 3}

RELATED

  * Arrays

  * push

  * find

  * append

  * resize

}

{
renderstate

Queries the renderer for a named property.

USAGES
  int renderstate(string query, <type> &value)
  int renderstate(material mat, string query, <type> &value)

Returns a non-zero value and sets <value> on success, or returns 0 if
the renderer cannot evaluate the query.

The two-argument variations look up the property on the current object.
If you pass a material as the first argument, the function looks up the
property on the material instead of the current object.

See the list of IFD properties you can query. Use the *IFD* name (e.g.
image:samples), not the Houdini name (e.g. vm_samples).

USEFUL PROPERTIES

    The following properties are commonly useful and are reproduced here
    for convenience, but you can query any property from the the full
    list of IFD properties.


    image:name
        (string) The name of the image being rendered.

    image:pixelaspect
        (float) The pixel aspect ratio (X/Y) of the image.

    image:resolution
        (vector) Gives the resolution as {<x_res>, <y_res>,
        <samples_per_pixel>}.

    image:samples
        (vector) Gives samples as {<x_samples>, <y_samples>, 0}.

    image:raysamples
        (vector) Gives the raytracing samples as {<x_samples>,
        <y_samples>, 0}.

    light:name
        (string) The name of the light object which is currently active
        in the illuminance loop.

    light:shadowscope
        (string) The list of objects casting shadows from a light.

    object:name
        (string) The name of the object being shaded. This is valid
        within light and shadow shaders and can be used to query which
        object is being lit (or shadowed) by the light source.

    object:reflectscope
        (string) The default reflection scope pattern for the object
        being shaded.

    object:refractscope
        (string) The default refraction scope pattern for the object
        being shaded.

    object:reflectlimit
        (float or int) The hard limit for maximum refraction bounces for
        the object being shaded.

    object:shadingquality
        (float) The shading quality for the object being shaded.

    object:lightmask
        (string) The object's light mask string.

    object:area
        (float) The object's surface area.

    object:materialname

        (string) Path to the material that's assigned to the object
        being shaded. NOTE
            This is for informational purpose only and has no effect on
            material assignment or appearance.

    renderer:name
        (string) The name of the renderer.

    renderer:version
        As a string, gives the renderer version as
        "<major>.<minor>.<build>" As a vector, gives the renderer
        version as {<major>, <minor>, <build>}.

    renderer:renderengine
        (string) The render method in use, such as micropoly or
        raytrace. See the properties list for the full list of possible
        values.

    shader:name
        (string) The name of the current shader being run.

PACKED PRIMITIVES

    When mantra renders packed primitives, the geometry gets unpacked
    before rendering. This means primitive attributes on the packed
    primitive aren't available to shaders (since they aren't passed down
    to the unpacked geometry).

    Before unpacking, mantra will automatically convert the primitive
    attributes to custom object properties (see ray_declare on the IFD
    file format page). The property will be named packed:ATTRIBNAME
    (where ATTRIBNAME is the name of the attribute). The renderstate()
    function can be used to access these properties, just like any other
    object property.

    For example:

  > vector Cd;
  > if (!renderstate("packed:Cd", Cd))
  >     Cd = 1;   // There was no Cd attribute on packed geometry

EXAMPLES

  > surface showversion() 
  > {
  >     string    rname, rversion;
  >     if (!renderstate("renderer:name", rname))
  >         rname = "Unknown renderer";
  >     if (!renderstate("renderer:version", rversion))
  >         rversion = "Unknown version";
  >     printf("Image rendered by %s (%s)\n", rname, rversion);
  > }
  > 
  > vector mapToScreen(vector NDC_P)
  > {
  >     // Given a point in NDC space, find out which pixel it
  >     // maps to.
  >     vector    result;
  >     if (!renderstate("image:resolution", result))
  >         result = {640, 486, 0};
  >     return result * NDC_P;
  > }

RELATED

}

{
reorder

Reorders items in an array or string.

USAGES
  string reorder(string value; int indices[])
  Returns a reordered version of the _characters_ (not bytes) in the
  UTF-8 string value according to the positions in indices. The result
  is a UTF-8 encoded string.

  <type>[] reorder(<type> values[]; int indices[])
  Returns a reordered version of the items in values according to the
  positions in indices.

This usually uses a list of indices generated by argsort. See the
argsort page for an example.

  * Negative numbers in the index list will read from the end of the
    array.

  * The length of the resulting array/string is the same as the length
    of the indices.

  * Out of bound values will insert zeros, but this should be considered
    an error.

RELATED

  * Arrays

  * argsort

  * reverse

  * sort

}

{
resample_linear

USAGES
  float[] resample_linear(const float input[], int new_length)
  vector[] resample_linear(const vector input[], int new_length)
  vector2[] resample_linear(const vector2 input[], int new_length)
  vector4[] resample_linear(const vector4 input[], int new_length)

Returns a new array of size new_length, uniformly sampled from the input
array. Array elements are linearly interpolated from the input array.

RELATED

}

{
resize

Sets the length of an array.

USAGE
  void resize(<type> &array[]; int size)
  Changes the size of the given array. If size is greater than the
  current length of the array, the extra items at the end of the array
  may be uninitialized versions of the given type (for example, 0, empty
  string, {0,0,0}, etc.).

RELATED

  * Arrays

  * append

  * push

  * len

}

{
resolvemissedray

Returns the background color for rays that exit the scene.

USAGE
  vector resolvemissedray(vector dir, float time, int mask, ...)

Returns the color of the background environment for rays that exit the
scene. When no environment or background color is specified, any
environment lights in the scene using the mode "Ray Tracing Background"
will be used to look up the environment color. <mask> indicates the type
of ray that is being resolved as an integer mask.

To use the default background (environment light) for a reflection ray:

> resolvemissedray(I, 0.0, PBR_REFLECT_MASK);

To define your own background:

> resolvemissedray(I, 0.0, PBR_ALL_MASK, "environment", "Mandril.rat", "envtint", {1,2,1});
> resolvemissedray(I, 0.0, PBR_ALL_MASK, "background", {1,1,1});

RELATED

  * envlight

}

{
reverse

Returns an array or string in reverse order.

USAGES
  string reverse(string str)
  Returns a UTF-8 encoded string with the reversed _characters_ (not
  bytes) from str. This is different from what str[::-1] returns.

  <type>[] reverse(<type> values[])
  Returns a reversed copy of the given array.

EXAMPLES

  > reverse("hello") == "olleh";
  > reverse({1,2,3,4}) == {4, 3, 2, 1};

RELATED

  * Arrays

  * reorder

  * sort

}

{
rgbtohsv

Convert RGB color space to HSV color space.

USAGES
  vector rgbtohsv(vector hsv)
  vector rgbtohsv(float h, float s, float v)

Convert RGB color space to HSV color space. A vector representing the
HSV color is returned. The hue will be in the range 0 to 1.

RELATED

}

{
rgbtoxyz

Convert a linear sRGB triplet to CIE XYZ tristimulus values.

USAGE
  vector rgbtoxyz(vector rgb)

Convert a linear sRGB (Rec. 709) triplet to CIE XYZ tristimulus values.
XYZ can be thought of as a 'universal color space'.

RELATED

  * xyztorgb

  * blackbody

}

{
rint

Rounds the number to the closest whole number.

USAGES
  float rint(float n)
  <vector> rint(<vector> v)
  Returns the closest whole number to n. For vectors, this is done per-
  component.

RELATED

}

{
rotate

Applies a rotation to the given matrix.

USAGES
  void rotate(matrix2 &m, float amount)
  void rotate(matrix3 &m, float amount, vector axis)
  void rotate(matrix &m, float amount, vector axis)

Applies a rotation to the given matrix. The angle must be given in
radians and the axis must be normalized.

RELATED

}

{
rotate_x_to

Rotates a vector by a rotation that would bring the x-axis to a given
direction.

USAGES
  vector2 rotate_x_to(vector2 direction, vector2 v)
  vector rotate_x_to(vector direction, vector v)
  vector4 rotate_x_to(vector4 direction, vector4 v)


direction
    Direction to which a vector along the positive x-axis, e.g. (1,0,0),
    would be rotated. This does not need to be normalized.

v
    Vector to which to apply the rotation.

Applies to v, the rotation that would move (1,0), (1,0,0), or (1,0,0,0)
to direction most directly.

In the case of direction being (-1,0,0), there are multiple distinct
rotations that would move (1,0,0) to (-1,0,0) with a half turn rotation,
so one is chosen arbitrarily, negating v.x and v.z. In 2D, there is only
one distinct rotation that moves (1,0) to (-1,0), equivalent to negating
v. In 4D, the rotation where v is negated is also chosen.

This is used by functions like sample_direction_cone and
sample_sphere_cone to rotate the cone centre from (1,0,0) to a given
direction vector.

RELATED

  * sample_circle_arc

  * sample_direction_cone

  * sample_orientation_cone

  * sample_circle_slice

  * sample_sphere_cone

  * sample_hypersphere_cone

}

{
rstrip

Strips trailing whitespace from a string.

USAGES
  string rstrip(string value)
  string rstrip(string value, string whitespace)

Returns a string with the trailing whitespace removed. If whitespace is
provided, it is a string of characters that will be stripped.

RELATED

  * strip

  * lstrip

}

{
sample_bsdf

Samples a BSDF.

USAGES
  void sample_bsdf(bsdf F, vector viewer_u, vector &dir, vector &eval,
  int &type, float sx, float sy, ...)
  void sample_bsdf(bsdf F, vector viewer_u, vector &dir, vector &eval,
  int &type, float sx, float sy, int mask, ...)
  void sample_bsdf(bsdf F; vector viewer_u; vector &dir; vector &eval;
  float &pdf; int &type; float sx, float sy; ... )
  void sample_bsdf(bsdf F, vector viewer_u, vector &dir, vector &eval,
  float &pdf, int &type, float sx, float sy, int mask, ...)
  void sample_bsdf(bsdf b; vector viewer_u; vector normal_v; int &mask;
  vector &dir; vector &eval; float &pdf; int &type; float sx; float sy;
  int bounces; ... )


F
    The BSDF to sample.

viewer_u
    The U vector (input viewer direction).

normal_v
    The V vector (input surface normal).

&mask
    A bitfield of flags for the BSDF, defined in pbr.h.

    See bouncemask for information on component label bitmasks.

&dir
    The function overwrites this variable with the outgoing ray
    direction.

&eval
    The function overwrites this variable with the outgoing ray color,
    scaled by albedo.

    This is not the same as the evaluated vector returned by the
    eval_bsdf operation. Here, &eval will not vary with the outgoing
    sample direction.

&pdf
    The function overwrites this variable with the computed PDF of the
    BSDF.

&type
    ???

sx and sy
    Random values, such as generated by nextsample. Different values of
    sx and sy represent different random directions to sample.

&eval
    Overwritten with the color, scaled by albedo, of the sampled
    component.

&type
    Overwritten with the type of component sampled. This uses the same
    constants as in the mask argument.

&pdf
    The sampling pdf for the sampled component.

bounces
    A bitmask representing bounce types allowed.

The sample_bsdf function passes keyword arguments to the BSDF being
evaluated. For custom BSDFs these keyword arguments are bound to shader
arguments (e.g. indicating whether the BSDF is being evaluated for
direct or indirect illumination). It's also possible for a BSDF to pass
information back to sample_bsdf. To indicate that a keyword argument
value should be imported from the BSDF prefix the keyword with
"import:". For example:

EXAMPLES

  > sample_bsdf(F, inI, outI, eval, type, sx, sy,
  >     "direct", 0,                        // Specify indirect illumination
  >     "import:sssmfp", sssmfp,        // Read the exported sssmfp parameter
  >     ...
  > );

RELATED

  * albedo

  * eval_bsdf

  * emission_bsdf()

}

{
sample_cauchy

Samples the Cauchy (Lorentz) distribution.

USAGES
  float sample_cauchy(float u)
  float sample_cauchy(float scale, float u)
  vector2 sample_cauchy(float scale, vector2 u)
  float sample_cauchy(float origscale, float minvalue, float maxvalue,
  float u)
  <vector> sample_cauchy(<vector> u)
  Sample multivariate Cauchy distributions with median 0 and scale 1.
  The distribution of these vectors is forced to be isotropic, i.e.
  rotating the distribution won't change it, which can be useful in
  simulations. This wouldn't be the case if one generated components of
  the vectors as independent samples of the univariate Cauchy
  distribution.


u
    A number, or multiple numbers, in the range [0,1).

scale
    The scale of the distribution, or 1 if not specified. This is the
    difference between the 50th percentile and the 75th percentile.

origscale
    The scale the distribution would have, were it not for minvalue and
    maxvalue, limiting the range.

minvalue,maxvalue
    When given, instead of sampling the full Cauchy distribution, the
    distribution with its range limited to will be sampled.

    Monotonically increasing value with respect to u.

Samples the Cauchy distribution with median zero and the specified
scale, optionally with a minvalue and maxvalue. Given uniform random u
values in [0,1), this will return Cauchy distributed random numbers.

Note that without limits, the Cauchy distribution has no defined mean or
variance, which can cause statistical problems if not dealt with
carefully.

To add a maximum distance from the origin, while keeping the
distribution isotropic, use:

> !vex
> sample_cauchy(1,0,maxdist,u.x) * sample_direction_uniform(set(u.y,u.z))

The 2D Cauchy distribution is the distribution of photons hitting a
plane, coming from a point light that is distance scale from the plane.

RELATED

  * rand

  * sample_exponential

  * sample_normal

  * sample_lognormal

  * sample_lognormal_by_median

  * sample_discrete

  * sample_direction_uniform

}

{
sample_cdf

Samples a CDF.

See create_cdf() and create_pdf() for more information.

USAGES
  int sample_cdf(float cdf[], float uniform_rand)
  Returns the index of the sampled CDF.

  void sample_cdf(float cdf[], float uniform_rand, int &index, float &x)
  void sample_cdf(float cdf[], float uniform_rand, int &index, float &x,
  float &pdf)
  Writes the index of the sampled CDF and extra information to output
  arguments.


cdf
    The CDF to sample from (created with create_cdf()).

uniform_rand
    A uniform random variable (must be in range <0,1>).

index
    The function writes the index of the CDF element that was sampled to
    this variable.

x
    The function writes the coordinate of the CDF element that was
    sampled to this variable.

pdf
    The function writes the PDF of the CDF element that was sampled to
    this variable.

EXAMPLES

    CDFs are useful when sampling from distributions. For example, a CDF
    of light source power could be created. This would allow sampling of
    lights with a probability based on power. This is an example of a
    discrete CDF, where sampling selects among a fixed set of
    probabilities. Such a CDF could be created as follows:

  > // Iterate over all lights, sampling their power
  > int[] li = getlights();
  > float values[];
  > resize(values, len(li));
  > int nsamples = 256;
  > int sid = israytrace ? SID : newsampler();
  > vector s, pos, clr;
  > float scale;
  > for (int i = 0; i < len(li); i++)
  > {
  >     for (int j = 0; j < nsamples; j++)
  >     {
  >         nextsample(sid, s.x, s.y, "mode", "nextpixel");
  >         sample_light(li[i], P, s, Time, pos, clr, scale);
  >         values[i] += luminance(clr);
  >     }
  >     values[i] /= nsamples;
  > }
  > 
  > // Create a CDF of the power distribution
  > float cdf[] = create_cdf(values);
  > 
  > // Randomly select a light based on power distribution
  > nextsample(sid, s.x, s.y, "mode", "nextpixel");
  > int index = 0;
  > sample_cdf(cdf, s.x, index);
  > 
  > // Do something with the selected light
  > // li[index] ...

RELATED

  * create_cdf()

  * create_pdf()

}

{
sample_circle_arc

Generates a uniform unit vector2, within maxangle of center, given a
uniform number between 0 and 1.

USAGE
  vector2 sample_circle_arc(vector2 center, float maxangle, float u)


center
    Direction in the center of the arc. This does not need to be
    normalized.

maxangle
    Maximum angle, in radians, away from center that any sample of the
    arc will be, so long as u is between 0 and 1.

u
    Number between 0 and 1.

Returns a unit vector2, i.e. a vector2 of length 1, based on u. Given
uniform random u values in [0,1), the returned unit vectors will be
uniform random and continuous with respect to u on the edge of the unit
circle, in the arc within maxangle of the direction indicated by center.

RELATED

  * sample_circle_edge_uniform

  * sample_direction_uniform

  * sample_orientation_uniform

  * sample_circle_uniform

  * sample_sphere_uniform

  * sample_hypersphere_uniform

  * sample_direction_cone

  * sample_orientation_cone

  * sample_circle_slice

  * sample_sphere_cone

  * sample_hypersphere_cone

}

{
sample_circle_edge_uniform

Generates a uniform unit vector2, given a uniform number between 0 and
1.

USAGE
  vector2 sample_circle_edge_uniform(float u)


u
    Number between 0 and 1.

Returns a unit vector2, i.e. a vector2 of length 1, based on u. Given
uniform random u values in [0,1), the returned unit vectors will be
uniform random and continuous with respect to u on the edge of the unit
circle. Specifically, it returns (cos(angle),sin(angle)), where angle is
2*pi*u.

RELATED

  * sample_direction_uniform

  * sample_orientation_uniform

  * sample_circle_uniform

  * sample_sphere_uniform

  * sample_hypersphere_uniform

  * sample_circle_arc

  * sample_direction_cone

  * sample_orientation_cone

  * sample_circle_slice

  * sample_sphere_cone

  * sample_hypersphere_cone

}

{
sample_circle_slice

Generates a uniform vector2 with length < 1, within maxangle of center,
given a vector2 of uniform numbers between 0 and 1.

USAGE
  vector2 sample_circle_slice(vector2 center, float maxangle, vector2 u)


center
    Direction in the center of the slice. This does not need to be
    normalized.

maxangle
    Maximum angle, in radians, away from center that any sample of the
    slice will be, so long as all u values are between 0 and 1.

u
    Pair of numbers between 0 and 1.

Returns a vector2 of length < 1, based on u. Given uniform random u
pairs of values in [0,1), the returned vectors will be uniform random
and continuous with respect to u inside the unit circle, in the slice
within maxangle of the direction indicated by center.

RELATED

  * sample_circle_edge_uniform

  * sample_direction_uniform

  * sample_orientation_uniform

  * sample_circle_uniform

  * sample_sphere_uniform

  * sample_hypersphere_uniform

  * sample_circle_arc

  * sample_direction_cone

  * sample_orientation_cone

  * sample_sphere_cone

  * sample_hypersphere_cone

}

{
sample_circle_uniform

Generates a uniform vector2 with length < 1, given a vector2 of uniform
numbers between 0 and 1.

USAGE
  vector2 sample_circle_uniform(vector2 u)


u
    Pair of numbers between 0 and 1.

Returns a vector2 of length < 1, based on u. Given uniform random u
pairs of values in [0,1), the returned vectors will be uniform random
and continuous with respect to u inside the unit circle. Specifically,
it returns scale*(cos(angle),sin(angle)), where angle is 2*pi*u.x and
scale is sqrt(u.y).

RELATED

  * sample_circle_edge_uniform

  * sample_direction_uniform

  * sample_orientation_uniform

  * sample_sphere_uniform

  * sample_hypersphere_uniform

  * sample_circle_arc

  * sample_direction_cone

  * sample_orientation_cone

  * sample_circle_slice

  * sample_sphere_cone

  * sample_hypersphere_cone

}

{
sample_direction_cone

Generates a uniform unit vector, within maxangle of center, given a
vector2 of uniform numbers between 0 and 1.

USAGE
  vector sample_direction_cone(vector center, float maxangle, vector2 u)


center
    Direction in the center of the cone. This does not need to be
    normalized.

maxangle
    Maximum angle, in radians, away from center that any sample of the
    cone will be, so long as all u values are between 0 and 1.

u
    Pair of numbers between 0 and 1.

Returns a unit vector, i.e. a vector of length 1, based on u. Given
uniform random u pairs of values in [0,1), the returned unit vectors
will be uniform random and continuous with respect to u on the surface
of the unit sphere, in the area within maxangle of the direction
indicated by center.

RELATED

  * sample_circle_edge_uniform

  * sample_direction_uniform

  * sample_orientation_uniform

  * sample_circle_uniform

  * sample_sphere_uniform

  * sample_hypersphere_uniform

  * sample_circle_arc

  * sample_orientation_cone

  * sample_circle_slice

  * sample_sphere_cone

  * sample_hypersphere_cone

}

{
sample_direction_uniform

Generates a uniform unit vector, given a vector2 of uniform numbers
between 0 and 1.

USAGE
  vector sample_direction_uniform(vector2 u)


u
    Pair of numbers between 0 and 1.

Returns a unit vector, i.e. a vector of length 1, based on u. Given
uniform random u pairs of values in [0,1), the returned unit vectors
will be uniform random and continuous with respect to u on the surface
of the unit sphere.

RELATED

  * sample_circle_edge_uniform

  * sample_orientation_uniform

  * sample_circle_uniform

  * sample_sphere_uniform

  * sample_hypersphere_uniform

  * sample_circle_arc

  * sample_direction_cone

  * sample_orientation_cone

  * sample_circle_slice

  * sample_sphere_cone

  * sample_hypersphere_cone

}

{
sample_discrete

Returns an integer, either uniform or weighted, given a uniform number
between 0 and 1.

USAGES
  int sample_discrete(int nvalues, float u)
  int sample_discrete(float weights[], float u)


nvalues
    The returned integer will be uniform in the range [0,nvalues-1],
    returning 0 if u==0, and returning nvalues-1 if u==1. The output
    will be clamped to that range in case u is out of the range [0,1),
    to reduce the risk of roundoff on u causing problems.

weights
    Relative weights, (the sum does not need to be 1), of each integer
    value in the range [0,len(weights)-1].

u
    A number between 0 and 1.

Returns an integer, based on u, either uniformly weighted from 0 to
nvalues-1, or weighted based on the weights array from 0 to
len(weights)-1. Given uniform random u values in [0,1), the version
taking nvalues will return uniform random integers in [0,nvalues-1], and
the version taking weights will return random integers in
[0,len(weights)-1], where the probability of i is
weights[i]/sum_of_weights.

RELATED

  * rand

  * sample_normal

  * sample_exponential

  * sample_cauchy

  * sample_lognormal

  * sample_lognormal_by_median

}

{
sample_exponential

Samples the exponential distribution.

USAGES
  float sample_exponential(float u)
  float sample_exponential(float mean, float u)
  float sample_exponential(float origmean, float maxvalue, float u)


u
    A number in the range [0,1).

mean
    The mean of the distribution, or 1 if not specified.

origmean
    The mean the distribution would have, were it not for maxvalue,
    limiting the range.

maxvalue
    When given, instead of sampling the full exponential distribution,
    the distribution with its range limited to [0,maxvalue] will be
    sampled.

Samples the exponential distribution with the specified mean, optionally
with a maxvalue. Given uniform random u values in [0,1), this will
return exponentially distributed random numbers. The return value will
be monotone increasing with respect to u.

RELATED

  * rand

  * sample_normal

  * sample_cauchy

  * sample_lognormal

  * sample_lognormal_by_median

  * sample_discrete

}

{
sample_geometry

Samples geometry in the scene and returns information from the shaders
of surfaces that were sampled.

USAGE
  int sample_geometry(vector origin, vector sample, float time, ...)

The sample_geometry operation in VEX is used to distribute a single
sample point on geometry objects in the scene, and to execute the
surface shader at that point. The operation is similar to the trace and
gather functions in that it accepts a variadic argument list of shader
outputs to be exported by the operation. However, sample_geometry is
different from raytracing functions in that it does not actually send a
ray into the scene to determine where shaders should be run. The
<origin> and <sample> parameters have different meanings depending on
the type of distribution. <time> can be used with motion blur to
distribute sample points in time as well as in space.

AREA DISTRIBUTION

    In this mode, points will be distributed over multiple primitives
    according to their area. More samples will be placed on primitives
    with large surface areas than on primitives with small surface
    areas. The <sample> parameter should contain uniform random
    variables in the range of 0 to 1. The <origin> parameter has no
    effect.

PARAMETRIC DISTRIBUTION

    In this mode, primitive and subdivision IDs along with parametric
    surface coordinates are mapped to surface positions. This mode is
    useful when trying to maintain a coherent set of surface positions
    (for example, in a point cloud) across multiple frames because the
    same primitive ID, subdivision ID, s, and t coordinates map to
    similar surface positions even when a mesh is deforming. The
    <sample> parameter contains the s and t coordinates (in the first
    and second components), while the <origin> parameter contains the
    primitive and subdivision IDs (again, in the first and second
    components).

SOLID ANGLE DISTRIBUTION

    This mode is similar to the "area" mode, except that points on a
    particular primitive are distributed according to solid angle rather
    than area. More specifically, samples will be distributed according
    to hemispherical coverage relative to <origin>. The <sample>
    parameter should contain uniform random variables in the range of 0
    to 1.

DETAILS

    LIGHT INCLUSION/EXCLUSION OPTIONS


        categories
            Specifies lights to include/exclude by their "category"
            tags. This is the preferred include/exclude lights rather
            than pattern matching light names with the "lightmask"
            keyword argument.

            For example:

          > diff = diffuse(nml, "lightmask", "hero | fill");

            See light categories for more information.

        lightmask
            When evaluating light and shadow shaders, objects have pre-
            defined light masks. This mask is usually specified in the
            geometry object and specifies a list of lights which are
            used to illuminate a surface or fog shader. It is possible
            to override the default light mask by specifying a
            "lightmask" argument.

            For example:

          > diff = diffuse(nml, "lightmask", "light*,^light2");

            ...will cause all lights whose names begin with "light"
            except for a light named "light2" to be considered for
            diffuse illumination.

            All Houdini scoping patterns, excepting group expansion, are
            supported:

          * * - wild-card match

          * ? - single character match

          * ^ - exclusion operator

          * [list] - character list match

    RAY OPTIONS


        TIP
            When you specify a texture, such as with the "environment"
            keyword, you can also use the image filtering keyword
            arguments. See environment for a listing of the image filter
            keyword arguments.


        scope
            A list of objects which can be hit by the rays. When
            specified, scope overrides the default scope that would have
            been selected for the given raystyle. The "scope:default"
            value will cause the scope argument to use the default scope
            for the current context - as if the argument were not
            specified.

            Allows an override of the scope for ray-intersections. A
            special scope argument, scope:self, will match the currently
            shading object.

        maxdist
            The maximum distance to search for objects. This can be used
            to limit the search of objects to nearby objects only. If
            the maxdist given is negative, then it will act as if there
            is no maximum distance.

            Allows an override of the maximum distance the ray can
            travel when testing for intersections. Some functions (such
            as fastshadow) have the maximum distance implicitly defined
            (by the length of the ray) and should probably avoid using
            this option. However, this option can be used effectively
            when computing reflections, global illumination, refraction
            etc.

        variancevar
            The name of a VEX export variable to use for variance anti-
            aliasing. The renderer compares the value with adjacent
            micropolygons in micropolygon rendering to decide what
            shading points need additional samples (using vm_variance
            property as a threshold). If more samples are required, the
            algorithm takes samples up to the specified maximum ray
            samples.

            This variable must be imported from the hit surface, so it
            must be in the list of imported names (see "importing
            information back from the ray" below). If the named variable
            is not imported, this option will be ignored.

            Variance antialiasing puts more samples in areas of the
            image with high variance, for example a sharp shadow edge.
            It is only used when vm_dorayvariance is enabled. Otherwise,
            only the min ray samples (or an explicitly supplied
            "samples" value) are used for antialiasing of the gather
            loop.

            Overrides the global variance control (mantra's -v option)
            which is used to determine anti-aliasing quality of ray
            tracing. For more information please refer to the
            documentation on mantra.

        angle
            The distribution angle (specified in radians). For gather(),
            rays will be distributed over this angle. For trace(), the
            angle is used to indicate the rate at which the filter width
            should increase with increasing intersection distance.
            Larger angles will cause farther hit surfaces to use larger
            derivatives, leading to improved texturing and displacement
            performance.

            To be effective, the samples parameter should also be
            specified.

        samples
            How many samples should be sent out to filter rays. For the
            irradiance and occlusion functions, specifying a samples
            parameter will override the default irradiance sampling.

        environment
            If the ray sent out to the scene misses everything, then
            it's possible to specify an environment map to evaluate.

            Using the ray's direction, the environment map specified
            will be evaluated and the resulting color will be returned.
            Most likely, it will be necessary to specify a transform
            space for the environment map evaluations.

            In the case of refractlight and trace the Of and Af
            variables will be set to 0 regardless of the background
            color specified. the resulting color.

            When an environment map is specified, the filtering options
            from texture() are also supported.

            See how to create an environment/reflection map.

        envobject
            If an environment map is used, the orientation of the
            environment map can be specified by transforming the ray
            into the space of another object, light or fog object in the
            scene. In Houdini, null objects can be used to specify the
            orientation. For example:

          > Cf = R*reflectlight(bias, max(R), "environment", "map.rat", "envobject", "null_object_name");

        envlight
            If an environment map is used, the orientation of the
            environment map can be specified by transforming the ray
            into the space of a light in the scene.

        envtint
            If an environment map is used, tint it with this color.

        background
            If a ray misses all objects, use this as the background
            color of the scene. In the case of refractlight and trace
            the Of and Af variables will be set to 0 regardless of the
            background color specified.

        distribution
            *Functions*: irradiance, occlusion

            Distribution for computing irradiance. The default is to use
            a cosine distribution (diffuse illumination). The possible
            values for the style are "nonweighted" for uniform sampling
            or "cosine" for cosine weighted sampling.

    RAY SENDING OPTIONS


        width
            Specifies the filter width at the source of the ray. If
            angle is also specified, the filter width will become larger
            with increasing distance along the ray. By default, the
            filter width will be initialized from the current shading
            context, so it's normally not necessary to specify width
            directly. Negative values are ignored and will also cause
            the filter width to be initialized from the current shading
            context.

        distribution
            Determines the sampling distribution.

            For gather:

          * cosine -- Rays are distributed by the cosine (diffuse)
            function over the hemisphere.

          * uniform -- Rays are distributed uniformly over the
            hemisphere

            For sample_geometry:

          * area -- Samples are distributed by primitive area

          * parametric -- Samples are distributed by primitive ID,
            subdivision ID, and parametric surface coordinates (s, t).

          * solidangle -- Samples are distributed either by primitive
            area or by primitive area and solid angle subtended by the
            primitive.

        biasdir
            Overrides the bias direction when Bias Along Normal is
            enabled. When no biasdir is specified, the geometric normal
            Ng is used. When bias along normal is disabled, this option
            has no effect.

        SID
            Sample identifier to be passed to the called shader. If the
            calling shader has used SID to generate samples, it can be
            useful to pass the modified sample identifier to the called
            shader so that it can begin sampling at the specified
            offset. This value will be used to initialize the SID global
            in the hit surface.

        rayweight
            A hint to mantra to indicate the relative contribution of
            this ray to the final shading. This value is used by the ray
            clip threshold to limit sending of rays (similar to ray
            bounce).

        raystyle
            The type of rays you are sending. Mantra will use raystyle
            to determine both the default raytracing mask and bounce
            limit used for ray termination.

          * reflect -- Sending reflection rays. Mantra will use the
            reflection mask and reflection limit to terminate
            raytracing.

          * refract -- (default) Sending refraction rays. Mantra will
            use the refraction mask and refraction limit to terminate
            raytracing.

          * diffuse -- Sending diffuse rays. Mantra will use the diffuse
            limit for diffuse rays.

          * shadow -- Sending shadow rays. Mantra will not modify the
            raytracing level and will trace against shadowmask if inside
            a shadow or light shader.

          * primary -- Sending primary rays. This style can be used when
            a shader needs to change the direction of a primary ray
            without affecting the behavior of render settings that apply
            only to directly visible objects (such as matte and
            phantom). Mantra will still increment the raytracing level
            when sending primary rays.

          * nolimit -- Sending reflection rays with no limit on the
            number of raytracing bounces. Mantra will still increment
            the raytracing level when sending nolimit rays.

        categories
            A category expression used to select the objects which can
            be hit by rays. When specified, this overrides the existing
            reflectcategories and refractcategories parameters.

            For example, ^hidden will hit all objects which do not have
            the hidden category, and shiny|happy will hit all objects
            with either the shiny or happy category.

            The intersection of the scope and categories parameters are
            used to choose the objects which can be hit by rays.

        samplebase
            Typically, rays are distributed over the surface of the
            micro-polygon being shaded. This argument can be used to
            control the area. A value of 0 will force all rays to be
            sent from the same point. A value of 1 will cover the entire
            micro-polygon. (Gather only)

        transparentsamples
            The number of transparent samples to take for stochastic
            transparency with array outputs. Normally this value should
            be set to 1 unless you have requested exports in array
            variables - in which case the ray tracer will insert an
            entry in the array for each sample along the ray.


            NOTE
                transparentsamples must be 1 when importing F or
                ray:material using screendoor samplefilter.

    SENDING INFORMATION TO THE SURFACE'S SHADER

        Using a keyword in the form "send:<name>", value, you can pass
        data from the originating surface to surfaces which are
        intersected by the ray. These arguments pass any values you
        want.

      > gather(P, dir, "send:N", normalize(N)) { ... }

        You can extract this passed data on the receiving end (that is,
        in the surface being hit by the ray) with the rayimport
        function. The first argument is the name (without the send:
        prefix) and the second argument is a variable in which to store
        the imported value.

        int rayimport(string name, <type> &value)

        rayimport returns 1 if the value was imported successfully.

    IMPORTING INFORMATION FROM THE RAY

        You can specify names of global or exported variables to import
        from the hit shader in the form "<varname>", &var, typically
        including Cf (color vector of surface hit) and Of (opacity
        vector of surface hit).

      > vector  hitcf;
      > gather(P, dir, "bias", 0.01, "Cf", hitcf) {...}

        In addition, you can import the following special keywords to
        get information about the ray itself:


        ray:origin
            The origin of the ray (defined in else clause also).

        ray:direction
            The direction of the ray (defined in else clause also).

        ray:length
            The distance to the first surface which was hit by the ray.

        ray:area
            The total surface area of all the geometry in the raytracing
            scope.

        ray:solidangle
            The estimated solid angle subtended by all geometry in the
            raytracing scope. For large objects close to or enclosing
            the ray origin, this may be a very poor estimate while for
            individual primitives the estimate can be very good.

        You can retrieve information about more than one hit along the
        ray by requesting data in an array variable. When an imported
        value is of an array type, the trace function will automatically
        append an entry in the array for each individual hit point that
        was composited during ray tracing. For the opacity sample filter
        (see below), an entry will be created in the array for each
        semi-transparent sample encountered until full opacity is
        reached. When using array outputs, it may also be useful to use
        the all sample filter, which will cause all hits along the ray
        to be inserted regardless of whether the opacity limit was
        exceeded.

      > // Find the position and normal for all hit points along the ray,
      > // regardless of visibility.
      > vector a_pos[];
      > vector a_nml[];
      > trace(P, dir, Time,
      >         "samplefilter", "all",
      >             "P", a_pos,
      >             "N", a_nml);

    SAMPLE FILTERING OPTIONS

        By default, Houdini composites the global variables using
        opacity blending. In some cases, it's more useful to get the
        value from the closest surface (regardless of whether it's
        transparent). You can use the special samplefilter keyword with
        a string value of either closest or opacity to control whether
        the value of a global is from the closest surface or opacity
        blended.


        samplefilter
            When the samplefilter keyword is encountered in the argument
            list, _all following_ import variables will use the
            specified filtering mode. You can specify multiple
            samplefilter arguments in a single gather statement to
            filter different variables in different ways.

            The current types of allowed for samplefilter are


            minimum
                Take the minimum value of all the samples. Note that
                with tuple values, the minimum value of each component
                will be used.

            maximum
                Take the maximum value of all the samples. Note that
                with tuple values, the maximum value of each component
                will be used.

            opacity
                Composite samples using the over operation.

            closest
                This is the default behavior, returning only the closest
                surface.

            screendoor
                Use stochastic compositing of the samples.

            sum
                Return the sum of the values for all samples.

            sum_square
                Return the sum of the squares of the values of all
                samples.

            sum_reciprocal
                Return the sum of the reciprocals of each sample.


        NOTE
            When using sample_geometry, the default samplefilter is set
            to closest by default, since opacity blending only works
            when compositing data along a ray.

      > gather(P, dir,
      >         "samplefilter", "opacity",
      >             "Cf", hitCf,
      >             "Of", hitOf,
      >         "samplefilter", "closest",
      >             "P", hitP,
      >             "N", hitN)
      > {
      >     trace(pos, dir, time,
      >             // Composite the bsdf of the hit surfaces using stochastic transparency
      >             "samplefilter", "screendoor",
      >             "F", hitF,
      >             // But find the closest sample's position
      >             "samplefilter", "closest",
      >             "P", hitP);
      > }

    PIPELINE OPTIONS


        pipeline
            As you specify variables, you can intersperse pipeline
            keyword options to control where in the pipeline to fill out
            read/write variables. The value can be one of surface,
            atmosphere, or displacement. You can specify the pipeline
            option multiple times. Each use of the option affects any
            variables specified after it (up to the next usage of
            pipeline if any).

          > gather(p, d, "pipeline", "surface", "Cf", surfCf,
          >              "pipeline", "atmosphere" "Cf", fogCf, "P", hitP)

EXAMPLES

    The following example demonstrates how sample_geometry can be used
    to illuminate one surface from another. Rather than using a light
    source, illumination is gathered from other surfaces in the scene
    named /obj/sphere_object* and will illuminate any surfaces with the
    geolight surface shader assigned.

    A few observations about the shader:

  * The ray:solidangle output is used to scale back geometry sample
    contributions by the solid angle subtended by the hit surface. This
    ensures that the result of using sample_geometry will match
    physically based irradiance.

  * The trace instruction is used for shadowing

  * High-quality sampling patterns from newsampler and nextsample are
    used for antialiasing

  > surface
  > geolight(int nsamples = 64)
  > {
  >     vector        sam;
  >     vector        clr, pos;
  >     float        angle, sx, sy;
  >     int                sid;
  >     int                i;
  > 
  >     sid = newsampler();
  > 
  >     Cf = 0;
  >     for (i = 0; i < nsamples; i++)
  >     {
  >         nextsample(sid, sx, sy, "mode", "qstrat");
  >         sam = set(sx, sy, 0.0);
  >         if (sample_geometry(P, sam, Time,
  >             "distribution", "solidangle",
  >             "scope", "/obj/sphere_object*",
  >             "ray:solidangle", angle, "P", pos, "Cf", clr))
  >         {
  >             if (!trace(P, normalize(pos-P), Time,
  >                 "scope", "/obj/sphere_object*",
  >                 "maxdist", length(pos-P)-0.01))
  >             {
  >                 clr *= angle / (2*PI);
  >                 clr *= max(dot(normalize(pos-P), normalize(N)), 0);
  >             }
  >             else
  >                 clr = 0;
  >         }
  >         Cf += clr;
  >     }
  >     Cf /= nsamples;
  > }

RELATED

  * gather

  * trace

  * newsampler

  * nextsample

}

{
sample_hemisphere

Generates a unit vector, optionally biased, within a hemisphere, given a
vector2 of uniform numbers between 0 and 1.

USAGES
  vector sample_hemisphere(vector2 u)
  vector sample_hemisphere(vector center, vector2 u)
  vector sample_hemisphere(float bias, vector2 u)
  vector sample_hemisphere(vector center, float bias, vector2 u)


center
    Direction in the center of the hemisphere. This does not need to be
    normalized. If not specified, the center direction is (1,0,0), along
    the x-axis.

bias
    Bias toward the center direction, between -1 and infinity, with 0
    being unbiased, -1 forcing all points to the horizon, and infinity
    forcing all points to center. When supplied, u.y is simply replaced
    with 1-pow(1-u.y, 1.0/(bias+1.0)). To get a bias similar to this
    when using the more general sample_direction_cone,
    sample_sphere_cone, and related functions, apply the same change to
    u.x before calling those functions.

u
    Pair of numbers between 0 and 1.

Returns a unit vector, i.e. a vector of length 1, based on u. Given
uniform random u pairs of values in [0,1), if bias is 0, the returned
unit vectors will be uniform random and continuous with respect to u on
the surface of the unit hemisphere centered at center. If bias is
greater than zero, the unit vectors will be smoothly biased toward
center. If bias is between -1 and 0, the unit vectors will be biased
away from center, toward the horizon.

RELATED

  * sample_direction_uniform

  * sample_direction_cone

  * sample_sphere_uniform

  * sample_sphere_cone

  * rand

}

{
sample_hypersphere_cone

Generates a uniform vector4 with length < 1, within maxangle of center,
given a vector4 of uniform numbers between 0 and 1.

USAGE
  vector4 sample_hypersphere_cone(vector4 center, float maxangle,
  vector4 u)


center
    Direction in the center of the cone. This does not need to be
    normalized.

maxangle
    Maximum angle, in radians, away from center that any sample of the
    cone will be, so long as all u values are between 0 and 1.

u
    Four numbers between 0 and 1.

Returns a vector4 of length < 1, based on u. Given uniform random u
vectors of four values in [0,1), the returned vectors will be uniform
random and continuous with respect to u inside the unit hypersphere, in
the hypervolume within maxangle of the direction indicated by center.

RELATED

  * sample_circle_edge_uniform

  * sample_direction_uniform

  * sample_orientation_uniform

  * sample_circle_uniform

  * sample_sphere_uniform

  * sample_hypersphere_uniform

  * sample_circle_arc

  * sample_direction_cone

  * sample_orientation_cone

  * sample_circle_slice

  * sample_sphere_cone

}

{
sample_hypersphere_uniform

Generates a uniform vector4 with length < 1, given a vector4 of uniform
numbers between 0 and 1.

USAGE
  vector4 sample_hypersphere_uniform(vector4 u)


u
    Four numbers between 0 and 1.

Returns a vector4 of length < 1, based on u. Given uniform random u
vectors of four values in [0,1), the returned vectors will be uniform
random and continuous with respect to u inside the unit hypersphere.

RELATED

  * sample_circle_edge_uniform

  * sample_direction_uniform

  * sample_orientation_uniform

  * sample_circle_uniform

  * sample_sphere_uniform

  * sample_circle_arc

  * sample_direction_cone

  * sample_orientation_cone

  * sample_circle_slice

  * sample_sphere_cone

  * sample_hypersphere_cone

}

{
sample_light

Samples a 3D position on a light source and runs the light shader at
that point.

USAGE
  int sample_light(int lightid, vector pos, vector sam, float time,
  vector &pos, vector &clr, float &scale, ...)


lightid
    An integer identifying a light. You can get a list of light IDs for
    lights affecting the currently shaded surface with getlights.

pos
    The surface point from which lights should be sampled. Area light
    sources will attempt to distribute samples by solid angle from the
    position - that is, light geometry that is closer to the position
    will receive more samples.

sam
    A vector of random values, such as those generated by nextsample.
    Currently only the first 2 components of sam are used. Different
    values of sam translate into different random positions on the
    geometry of the light source.

time
    Time to shade at.

The function modifies the values of the following arguments:


pos
    The sampled position on the light source.

clr
    The light color set by the light shader.

scale
    The light average hemispherical intensity (for area lights).

    A component bitmask indicating what types of component bounces the
    light affects.


TIP
    If you are using sample_light to generate light colors, for example
    to reproduce the Cl values that would be produced by a illuminance
    loop, you will need to normalize clr to scale:

  > clr *= scale / luminance(clr);

RELATED

  * getlights

  * intersect_lights

  * nextsample

}

{
sample_lognormal

Samples the log-normal distribution based on parameters of the
underlying normal distribution.

USAGES
  float sample_lognormal(float mu, float sigma, float u)
  float sample_lognormal(float mu, float sigma, float minvalue, float
  maxvalue, float u)


mu
    The mean of the underlying normal distribution.

sigma
    The standard deviation of the underlying normal distribution.

u
    A number in the range [0,1).


minvalue,maxvalue
    When given, instead of sampling the full log-normal distribution,
    the distribution with its range limited to will be sampled.

Samples the log-normal distribution with the specified mu and sigma,
optionally with a minvalue and maxvalue. To use parameters that are more
understandable, median and stddev, please use
sample_lognormal_by_median. Given uniform random u values in [0,1), this
will return log-normally distributed random numbers. The return value
will be monotone increasing with respect to u.

The log-normal distribution is sampled by sampling a normal distribution
and exponentiating the result, giving a value that is always positive,
so this distribution is often used for generating random point scales.

RELATED

  * sample_lognormal_by_median

  * sample_normal

  * rand

  * sample_exponential

  * sample_cauchy

  * sample_discrete

  * sample_direction_uniform

  * log

  * exp

}

{
sample_lognormal_by_median

Samples the log-normal distribution based on median and standard
deviation.

USAGES
  float sample_lognormal_by_median(float median, float stddev, float u)
  float sample_lognormal_by_median(float origmedian, float origstddev,
  float minvalue, float maxvalue, float u)


median
    The median of the distribution.

origmedian
    The median the distribution would have, were it not for minvalue and
    maxvalue, limiting the range.

stddev
    The standard deviation of the distribution.

origstddev
    The standard deviation (scale) the distribution would have, were it
    not for minvalue and maxvalue, limiting the range.

u
    A number in the range [0,1).


minvalue,maxvalue
    When given, instead of sampling the full log-normal distribution,
    the distribution with its range limited to will be sampled.

Samples the log-normal distribution with the specified median and
stddev, optionally with a minvalue and maxvalue. To use parameters mu
and sigma of the underlying normal distribution instead of median and
stddev, use sample_lognormal. Given uniform random u values in [0,1),
this will return log-normally distributed random numbers. The return
value will be monotone increasing with respect to u.

The log-normal distribution is sampled by sampling a normal distribution
and exponentiating the result, giving a value that is always positive,
so this distribution is often used for generating random point scales.

RELATED

  * sample_lognormal

  * sample_normal

  * rand

  * sample_exponential

  * sample_cauchy

  * sample_discrete

  * sample_direction_uniform

  * log

  * exp

}

{
sample_normal

Samples the normal (Gaussian) distribution.

USAGES
  float sample_normal(float u)
  float sample_normal(float mean, float stddev, float u)
  float sample_normal(float origmean, float origstddev, float minvalue,
  float maxvalue, float u)
  vector2 sample_normal(vector2 u)
  vector sample_normal(vector u)
  vector4 sample_normal(vector4 u)


u
    A number, or multiple numbers, in the range [0,1).

mean
    The mean of the distribution, or 0 if not specified.

origmean
    The mean the distribution would have, were it not for minvalue and
    maxvalue, limiting the range.

stddev
    The standard deviation (scale) of the distribution, or 1 if not
    specified.

origstddev
    The standard deviation (scale) the distribution would have, were it
    not for minvalue and maxvalue, limiting the range.


minvalue,maxvalue
    When given, instead of sampling the full normal distribution, the
    distribution with its range limited to will be sampled.

Samples the normal distribution with the specified mean and stddev,
optionally with a minvalue and maxvalue. Given uniform random u values
in [0,1), this will return normally distributed random numbers. The
return value will be monotone increasing with respect to u.

The vector2, vector, and vector4 versions return multiple samples with
mean 0 and standard deviation 1. The distribution of these vectors is
naturally isotropic, i.e. rotating the distribution won't change it,
which can be useful in simulations. To add a maximum distance from the
origin, while keeping the distribution isotropic, use:

sample_normal(0,1,0,maxdist,u.x) *
sample_direction_uniform(set(u.y,u.z))

RELATED

  * rand

  * sample_exponential

  * sample_cauchy

  * sample_lognormal

  * sample_lognormal_by_median

  * sample_discrete

  * sample_direction_uniform

}

{
sample_orientation_cone

Generates a uniform unit vector4, within maxangle of center, given a
vector of uniform numbers between 0 and 1.

USAGE
  vector4 sample_orientation_cone(vector4 center, float maxangle, vector
  u)


center
    Orientation in the center of the cone. This does not need to be
    normalized.

maxangle
    Maximum angle, in radians, away from center that any sample of the
    cone will be, so long as all u values are between 0 and 1.


    NOTE
        This angle is the maximum quaternion rotation angle between the
        orientation quaternion that the output represents and center,
        which is twice the Euclidean cone angle of the unit 4D
        hypersphere being sampled. A maxangle of pi would sample all
        orientations, but only half of all 4D unit vectors; a maxangle
        of 2pi would sample all 4D unit vectors.

u
    Three numbers between 0 and 1.

Returns a unit vector4, i.e. a vector4 of length 1, based on u. Given
uniform random u vectors of three values in [0,1), the returned
quaternion orientations will be uniform random and continuous with
respect to u, in the region of orientations within maxangle of center.

RELATED

  * sample_circle_edge_uniform

  * sample_direction_uniform

  * sample_orientation_uniform

  * sample_circle_uniform

  * sample_sphere_uniform

  * sample_hypersphere_uniform

  * sample_circle_arc

  * sample_direction_cone

  * sample_circle_slice

  * sample_sphere_cone

  * sample_hypersphere_cone

}

{
sample_orientation_uniform

Generates a uniform unit vector4, given a vector of uniform numbers
between 0 and 1.

USAGE
  vector4 sample_orientation_uniform(vector u)


u
    Three numbers between 0 and 1.

Returns a unit vector4, i.e. a vector4 of length 1, based on u. Given
uniform random u vectors of three values in [0,1), the returned unit
vectors will be uniform random and continuous with respect to u on the
surface of the unit hypersphere. In other words, they will be uniform
random orientation quaternions.

RELATED

  * sample_circle_edge_uniform

  * sample_direction_uniform

  * sample_circle_uniform

  * sample_sphere_uniform

  * sample_hypersphere_uniform

  * sample_circle_arc

  * sample_direction_cone

  * sample_orientation_cone

  * sample_circle_slice

  * sample_sphere_cone

  * sample_hypersphere_cone

}

{
sample_photon

Samples a 3D position on a light source and runs the light shader at
that point.

USAGE
  int sample_photon(light lp, vector &pos, vector &dir, float &scale,
  float time)

Spawns a photon from the given light source and returns the information
for the first intersection in the scene. The pos, dir and scale are
filled out with the information about where the photon hit in the scene.

The returned integer represents the bounce type mask (this is determined
by the types of illumination labels on the light source).

The function returns 0 if the photon didn't intersect any geometry.

RELATED

  * getlight

  * photonmap

  * getphotonlight

}

{
sample_sphere_cone

Generates a uniform vector with length < 1, within maxangle of center,
given a vector of uniform numbers between 0 and 1.

USAGE
  vector sample_sphere_cone(vector center, float maxangle, vector u)


center
    Direction in the center of the cone. This does not need to be
    normalized.

maxangle
    Maximum angle, in radians, away from center that any sample of the
    cone will be, so long as all u values are between 0 and 1.

u
    Three numbers between 0 and 1.

Returns a vector of length < 1, based on u. Given uniform random u
vectors of three values in [0,1), the returned vectors will be uniform
random and continuous with respect to u inside the unit sphere, in the
volume within maxangle of the direction indicated by center.

RELATED

  * sample_circle_edge_uniform

  * sample_direction_uniform

  * sample_orientation_uniform

  * sample_circle_uniform

  * sample_sphere_uniform

  * sample_hypersphere_uniform

  * sample_circle_arc

  * sample_direction_cone

  * sample_orientation_cone

  * sample_circle_slice

  * sample_hypersphere_cone

}

{
sample_sphere_uniform

Generates a uniform vector with length < 1, given a vector of uniform
numbers between 0 and 1.

USAGE
  vector sample_sphere_uniform(vector u)


u
    Three numbers between 0 and 1.

Returns a vector of length < 1, based on u. Given uniform random u
vectors of three values in [0,1), the returned vectors will be uniform
random and continuous with respect to u inside the unit sphere.

RELATED

  * sample_circle_edge_uniform

  * sample_direction_uniform

  * sample_orientation_uniform

  * sample_circle_uniform

  * sample_hypersphere_uniform

  * sample_circle_arc

  * sample_direction_cone

  * sample_orientation_cone

  * sample_circle_slice

  * sample_sphere_cone

  * sample_hypersphere_cone

}

{
sampledisk

Warps uniform random samples to a disk.

USAGE
  void sampledisk(float &x, float &y, float sx, float sy)

This function warps uniform sample values so that they are equally
distributed on a disk. The transformation attempts to preserve
stratification properties from the original samples.


x, y
    The function overwrites these variables with uniform distributed
    points within the unit disk.

sx, sy
    Uniform random values in the range , such as generated by
    nextsample.

}

{
scale

Scales the given matrix in three directions simultaneously (X, Y, Z -
given by the components of the scale_vector).

USAGES
  void scale(matrix2 &m, vector2 scale_vector)
  void scale(matrix &m, vector scale_vector)
  void scale(matrix3 &m, vector scale_vector)
  Scales the matrix in three directions simultaneously by the factors in
  the vector. This modifies the matrix in-place, rather than returning a
  new matrix.

RELATED

}

{
scatter

Evaluates a scattering event through the domain of a geometric object.

USAGE
  int scatter(vector ipoint, vector inormal, vector idirection, vector
  idistribution, float time, float maxdist, vector &opoint, vector
  &onormal, vector &odirection)

Evaluates a single scattering event through geometry. A return value of
1 means the scattering was successful.


ipoint
    Entry point of scattering.

inormal
    Surface normal at the entry point (surfaces only). Required to
    orient the scattering plane.

idirection
    Primary scattering direction at the entry point. Required to orient
    the scattering plane.

idistribution
    Initial scatter distribution at the entry point. If a zero-valued
    vector is passed a random scatter distribution will be used.

maxdist
    Maximum distance to scatter.

opoint
    Exit point of scattering.

onormal
    Normal at the scattering exit point (surfaces only).

odirection
    Outgoing direction at the scattering exit point (surfaces only).

> // Trace for intersection with scene
> vector hitP = 0;
> vector hitN = 0;
> int hit = trace(P, I, Time, "P", hitP, "N", hitN);
> 
> // Scatter a random distance from the intersection
> vector idistribution = 0;
> int sid = israytrace ? SID : newsampler();
> vector s;
> nextsample(sid, s.x, s.y, "mode", "nextpixel");
> float maxdist = 2.0 * s.x;
> vector opoint = 0;
> vector onormal = 0;
> vector odirection = 0;
> hit = scatter(hitP, hitN, I, idistribution, Time, maxdist, opoint, onormal, odirection);
> 
> // Trace again from the exit point of the scattering
> hit = trace(opoint, odirection, Time, "P", hitP, "N", hitN);

RELATED

  * sample_geometry

  * trace

  * gather

}

{
select

Returns one of two parameters based on a conditional.

USAGES
  <type> select(int conditional, <type> a, <type> b)
  <type>[] select(int conditional, <type> a[], <type> b[])

Returns a if the conditional is true, and returns b if it is false.

The difference between select and an if statement is that select will
evaluate both a and b, regardless of the value of the conditional.
Judicious use of select can avoid comparisons, allowing larger sections
of code to be converted to native code.

RELATED

}

{
sensor_panorama_create

Sensor function to render GL scene and query the result.

USAGE
  int sensor_panorama_create(float time, vector pos, int size, float
  near, float far, string candidateobj, string includeobj, string
  excludeobj, int uselit)

This function will render the surrounding environment using the GL
render and provides a handle to use for querying the results.


NOTE
    Because this needs to render the scene, it only works in interactive
    sessions of Houdini.


time
    The period in time when the render should be performed.

pos
    The location in world space coordinates where the render should be
    performed.

size
    The resolution of the performed render.

near
    The near plane restriction.

far
    The far plane restriction.

candidateobj
    A bundle, group, or expression that represents what objects will be
    displayed if their display setting is enabled.

includeobj
    A bundle, group, or expression that represents what objects will
    always be displayed.

excludeobj
    A bundle, group, or expression that represents what objects will
    never be displayed.

uselit
    Usually for AI purposes you want to not have any lighting as you are
    using color as a key to differentiate actors. However, if you want
    to display what a creature sees, lighting makes things more visually
    accurate.

RELATED

}

{
sensor_panorama_getcolor

Sensor function query a rendered GL scene.

USAGE
  vector sensor_panorama_getcolor(int handle, vector dir)

This function will return the color in the given direction from the
scene rendered previously with sensor_panorama_create.

}

{
sensor_panorama_getcone

Sensor function to query average values from rendered GL scene.

USAGE
  void sensor_panorama_getcone(int handle, vector lookodir, float angle,
  vector colormin, vector colormax, float depthmin, float depthmax,
  float &strength, vector &dir, vector &color, float &depth)

This function will render the surrounding environment using the GL
render and provides a handle to use for querying the results.

It averages out all rendered pixels in a cone shaped area. The colormin
and colormax can be used to mask out only pixels that lie in this range,
useful for color-coding different regions of interest. The resulting dir
and strength inform the weighted center of all matching pixels, and the
relative amount that passed the color and depth filters. The color and
depth are the average of all matched pixels.

}

{
sensor_panorama_getdepth

Sensor function query a rendered GL scene.

USAGE
  float sensor_panorama_getdepth(int handle, vector dir)

This function will return the depth in the given direction from the
scene rendered previously with sensor_panorama_create.

}

{
sensor_save

Sensor function to save a rendered GL scene.

USAGE
  int sensor_save(int handle, string colorfile, string depthfile)

This will save to disk the image maps corresponding to the color and
depth information recorded in the given sensor handle.

Returns 1 if successfully saved, otherwise 0.

}

{
serialize

Flattens an array of vector or matrix types into an array of floats.

USAGES
  float[] serialize(<vector> vectors[])
  float[] serialize(<matrix> matrices[])

These functions will serialize the arrays of tuple values. That is, the
values of the tuples are extracted one by one into a flat floating point
array.

EXAMPLES

  > vector v[] = { {1,2,3}, {7,8,9} }; // A vector[] of length 2
  > float  f[];
  > 
  > f = serialize(v);
  > // Now f[] has a length of 6 and equals { 1,2,3,7,8,9 }

RELATED

  * unserialize

}

{
set

Creates a new value based on its arguments, such as creating a vector
from its components.

The set() function has a *wide variety* of forms allowing you to perform
many different types of conversions.


TIP
    When filling a matrix in Houdini, the numbers go across the first
    row, then across the second row, and so on ("row-major").

USAGES
  vector2 set( float v1; float v2 )
  vector set( float v1; float v2; float v3 )
  vector4 set( float v1; float v2; float v3; float v4 )
  matrix2 set( float v1; float v2; float v3; float v4 )
  matrix3 set( float v1; float v2; float v4; float v4; float v5; float
  v6; float v7; float v8; float v9 )
  matrix set( float v1; float v2; float v3; float v4; float v5; float
  v6; float v7; float v8; float v9; float v10; float v11; float v12;
  float v13; float v14; float v15; float v16 )
  Create a vector or matrix type from the values in the arguments.

> vector4 v = set(1.0, 2.0, 3.0, 4.0);
> matrix3 m = set(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0);

  The assign function performs the opposite of this operation (pulling
  components out into variables).

  <vector> set( float nums[] )
  <matrix> set( float nums[] )
  Creates a vector/matrix from an array of floats.

> float[] nums = {1.0, 2.0, 3.0, 4.0};
> vector4 v = set(nums);
  <vector> set( float|int v )
  <matrix> set( float|int v )
  If you set a vector or matrix type from a single value, the
  vector/matrix is filled in with that value for all components.

> vector4 v = set(2.0);  // -> {2.0, 2.0, 2.0, 2.0}
  matrix2 set( vector2 row1; vector2 row2 )
  matrix3 set( vector row1; vector row2; vector row3 )
  matrix set( vector4 row1; vector4 row2; vector4 row3; vector4 row4 )
  Creates a matrix type from a series of vector arguments of the same
  size representing the rows.

> matrix3 m = set({0.0, 1.0, 0.0}, {1.0, 0.0, 1.0}, {0.0, 1.0, 0.0});
  matrix3 set( vector rows[] )
  matrix set( vector4 rows[] )
  You can also set a matrix type from an array of vectors representing
  rows. If there are not enough vectors in the array to fill the matrix,
  the extra rows will contain zeros.

  vector[] set( matrix3 m )
  vector4[] set( matrix m )
  Creates an array of vectors from the rows of a matrix of the same
  size.

> matrix3 m3 = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0};
> vector[] vs = set(m3);  // -> array [ {1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0, 8.0, 9.0} ]
  vector set( vector2 v)
  vector4 set( vector2 v)
  vector4 set( vector v)
  matrix3 set( matrix2 m)
  matrix set( matrix2 m)
  matrix set( matrix3 m)
  If you set a larger vector or matrix type from a smaller type, the
  extra components will be zero.

> vector2 v2 = {1.0, 2.0};
> vector4 v4 = set(v2);  // -> {1.0, 2.0, 0.0, 0.0}
  float set( vector v)
  float set( vector4 v)
  vector2 set( vector4 v)
  vector2 set( vector v)
  vector set( vector4 v)
  If you set a smaller vector with a larger vector, the smaller type
  will take components from the left.

> vector4 v4 = {1.0, 2.0, 3.0, 4.0};
> vector2 v2 = set(v4)  // -> {1.0, 2.0}
  matrix2 set( matrix3 m)
  matrix2 set( matrix m)
  matrix3 set( matrix m)
  If you set a smaller matrix with a larger matrix, the smaller type
  will take the top-left corner.

> matrix3 m3 = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0};
> matrix2 m2 = set(m3);  // -> {1.0, 2.0, 4.0, 5.0}
  float[] set( <vector> v)
  float[] set( <matrix> m)
  Creates an array of floats from the components of a vector or matrix
  type.

> matrix3 m3 = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0};
> float[] nums = set(m3);  // -> array [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0 ]
  <vector>[] set( float nums[] )
  <matrix>[] set( float nums[] )
  Creates an array of vector/matrix types by taking one component at a
  time from an array of floats. This is the same as using the
  unserialize function.

> float[] nums = {1.0, 2.0, 3.0, 4.0};
> vector2[] vs = set(nums);  // -> [ {1.0, 2.0}, {3.0, 4.0} ]
  int set(float v)
  float set(int v)
  float[] set( int vs[])
  int[] set( float vs[])
  You can set a float from an int, or an int from a float, or an array
  of floats from an array of ints, or an array of ints from an array of
  floats.

> float[] fracs = { 1.1, 2.2, 3.3, 4.4, 5.5, 6.6 };
> int[] floored = set(fracs);  // -> array [ 1, 2, 3, 4, 5, 6 ]
  float[] set( float num )
  Sets all the items in an array of float to the same value.

  float set( float nums[] )
  Returns the first item in the array.

  <type> set(<type> v)
  <type>[] set(<type> v[])
  If you call set() with the same argument type and return type, it
  simply returns the argument value.

> string s = set("Hello");  // -> "Hello"

RELATED

  * assign

}

{
setagentclipnames

Sets the current animation clips for an agent primitive.

USAGE
  void setagentclipnames(int geohandle, int prim, string clipnames[])


geohandle
    Handle to the geometry to write to. geoself() can be used to get a
    handle to the current geometry.

prim
    The primitive number.

clipnames
    A list of animation clip names.

RELATED

  * agentclipcatalog

  * agentcliplength

  * agentclipnames

  * agentclipsamplelocal

  * agentclipsampleworld

  * agentcliptimes

  * agentclipweights

  * setagentcliptimes

  * setagentclipweights

}

{
setagentclips

Sets the animation clips that an agent should use to compute its
transforms.

USAGE
  int setagentclips(int geohandle, int prim, string clip_names[], float
  clip_times[], float clip_weights[], string clip_transform_groups[],
  int clip_layer_ids[], int layer_blend_modes[], float layer_weights[],
  int layer_parent_ids[])

This function can provide improved performance compared to using a
combination of setagentclipnames, setagentcliptimes, and
setagentclipweights, and also allows layering animation clips.


geohandle
    Handle to the geometry to write to. geoself() can be used to get a
    handle to the current geometry.

prim
    The primitive number.

clip_names
    A list of animation clip names.

clip_times
    A list of times that the clips should be sampled at.

clip_weights
    A list of blend weights for the animation clips.

clip_transform_groups
    A list of transform groups, which specify the joints that each clip
    should be applied to.

clip_layer_ids
    A list containing the layer that each animation clip is an input
    for.

layer_blend_modes
    A list of blend modes for each layer. The available blend modes are
    defined in $HH/vex/include/crowd_cliplayers.h.

layer_weights
    A list of blend weights for each layer. The blend weight is not used
    for the topmost layer.

layer_parent_ids
    A list containing the parent layer for each layer (or -1 for the
    topmost layer). This specifies a tree of animation layers.

RELATED

  * setagentclipnames

  * setagentcliptimes

  * setagentclipweights

}

{
setagentcliptimes

Sets the current times for an agent primitive's animation clips.

USAGE
  void setagentcliptimes(int geohandle, int prim, float cliptimes[])


geohandle
    Handle to the geometry to write to. geoself() can be used to get a
    handle to the current geometry.

prim
    The primitive number.

cliptimes
    A list of clip times (in seconds).

RELATED

  * agentclipcatalog

  * agentcliplength

  * agentclipnames

  * agentclipsamplelocal

  * agentclipsampleworld

  * agentcliptimes

  * agentclipweights

  * setagentclipnames

  * setagentclipweights

}

{
setagentclipweights

Sets the blend weights for an agent primitive's animation clips.

USAGE
  void setagentclipweights(int geohandle, int prim, float clipweights[])


geohandle
    Handle to the geometry to write to. geoself() can be used to get a
    handle to the current geometry.

prim
    The primitive number.

clipweights
    A list of weights.

RELATED

  * agentclipcatalog

  * agentcliplength

  * agentclipnames

  * agentclipsamplelocal

  * agentclipsampleworld

  * agentcliptimes

  * agentclipweights

  * setagentclipnames

  * setagentcliptimes

}

{
setagentcollisionlayer

Sets the collision layer of an agent primitive.

USAGE
  void setagentcollisionlayer(int geohandle, int prim, string layername)


geohandle
    Handle to the geometry to write to. geoself() can be used to get a
    handle to the current geometry.

prim
    The primitive number.

layername
    The name of one of the agent's layers.

RELATED

  * agentcollisionlayer

  * agentcurrentlayer

  * agentlayerbindings

  * agentlayers

  * agentlayershapes

  * setagentcurrentlayer

}

{
setagentcurrentlayer

Sets the current layer of an agent primitive.

USAGE
  void setagentcurrentlayer(int geohandle, int prim, string layername)


geohandle
    Handle to the geometry to write to. geoself() can be used to get a
    handle to the current geometry.

prim
    The primitive number.

layername
    The name of one of the agent's layers.

RELATED

  * agentcollisionlayer

  * agentcurrentlayer

  * agentlayerbindings

  * agentlayers

  * agentlayershapes

  * setagentcollisionlayer

}

{
setagentlocaltransform

Overrides the local space transform of an agent primitive's bone.

USAGE
  int setagentlocaltransform(int geohandle, int prim, matrix transform,
  int index)


geohandle
    Handle to the geometry to write to. geoself() can be used to get a
    handle to the current geometry.

prim
    The primitive number.

transform
    The new transform (in local space) of the bone.

index
    Index of a transform in the agent's rig.

RELATED

  * agentlocaltransforms

  * agenttransformtolocal

  * agenttransformtoworld

  * agentworldtransforms

  * setagentlocaltransforms

  * setagentworldtransform

  * setagentworldtransforms

}

{
setagentlocaltransforms

Overrides the local space transforms of an agent primitive.

USAGE
  void setagentlocaltransforms(int geohandle, int prim, matrix
  transforms[])

When modifying a single transform, using setagentlocaltransform instead
can be significantly faster.


geohandle
    Handle to the geometry to write to. geoself() can be used to get a
    handle to the current geometry.

prim
    The primitive number.

transforms
    The new transform (in local space) of each bone in the agent's rig.

RELATED

  * agentlocaltransforms

  * agenttransformtolocal

  * agenttransformtoworld

  * agentworldtransforms

  * setagentlocaltransform

  * setagentworldtransform

  * setagentworldtransforms

}

{
setagentworldtransform

Overrides the world space transform of an agent primitive's bone.

USAGE
  int setagentworldtransform(int geohandle, int prim, matrix transform,
  int index)


geohandle
    Handle to the geometry to write to. geoself() can be used to get a
    handle to the current geometry.

prim
    The primitive number.

transform
    The new transform (in world space) of the bone.

index
    Index of a transform in the agent's rig.

RELATED

  * agentlocaltransforms

  * agenttransformtolocal

  * agenttransformtoworld

  * agentworldtransforms

  * setagentlocaltransform

  * setagentlocaltransforms

  * setagentworldtransforms

}

{
setagentworldtransforms

Overrides the world space transforms of an agent primitive.

USAGE
  void setagentworldtransforms(int geohandle, int prim, matrix
  transforms[])

When modifying a single transform, using setagentworldtransform instead
can be significantly faster.


geohandle
    Handle to the geometry to write to. geoself() can be used to get a
    handle to the current geometry.

prim
    The primitive number.

transforms
    The new transform (in world space) of each bone in the agent's rig.

RELATED

  * agentlocaltransforms

  * agenttransformtolocal

  * agenttransformtoworld

  * agentworldtransforms

  * setagentlocaltransform

  * setagentlocaltransforms

  * setagentworldtransform

}

{
setattrib

Writes an attribute value to geometry.

If you know the attribute class ahead of time, using setdetailattrib,
setprimattrib, setpointattrib, or setvertexattrib may be faster.

USAGES
  int setattrib(int geohandle; string attribclass; string
  attribute_name; int element_num, int vertex_num, <type> value, string
  mode="set")
  int setattrib(int geohandle; string attribclass; string
  attribute_name; int element_num, int vertex_num, <type> value[],
  string mode="set")

Returns the value of geohandle on success or -1 on failure.


NOTE
    If the attribute does not exist, this function *creates the
    attribute* with a default value of zero, empty string, or an empty
    array. If you want to control the default value of a numeric
    attribute, use addattrib before setting the attribute.


texttype
    A handle to the geometry to write to. Currently the only valid value
    is 0 or geoself, which means the current geometry in a node. (This
    argument may be used in the future to allow writing to other
    geometries.)

texttype
    One of "detail" (or "global"), "point", "prim", or "vertex".

    You can also use "primgroup", "pointgroup" or "vertexgroup" to read
    from groups.

attribute_name
    The name of the attribute to change.

element_num
    The point or primitive number on which to change the attribute.

    For detail attributes, set this to 0 (the argument is ignored for
    detail attributes).

    For vertex attributes, set this to the primitive number of the
    primitive containing the vertex.

vertex_num
    For vertex attributes, this is the number of the vertex on the
    primitive specified in element_num.

    To use a linear vertex index, set element_num to -1 and use the
    linear vertex index here.

    For other detail, primitive, or point attributes, set this to 0 (the
    argument is ignored in these cases).

value
    The value to set. If the type of this argument is not compatible
    with the attribute type, the set will fail and the function will
    return -1.

texttype
    (Optional) if given, this controls how the function modifies any
    existing value in the attribute.

    "set"

    Overwrite the attribute with the given value.

    "add"

    Add to the attribute the value.

    "min", "minimum"

    Set the attribute to the minimum of itself and the value.

    "max", "maximum"

    Set the attribute to the maximum of itself and the value.

    "mult", "multiply"

    Multiply the attribute by the value. For matrices, this will do
    matrix multiplication. For vectors, component-wise.

    "toggle"

    Toggles the attribute, independent of the source value. Useful for
    toggling group membership.

    "append"

    Valid for string and array attributes. Appends the source value to
    the end of the original value.

RELATED

  * setattrib

  * setpointattrib

  * setvertexattrib

  * setprimattrib

}

{
setattribtypeinfo

Sets the meaning of an attribute in geometry.

USAGE
  int setattribtypeinfo(int geohandle, string attribclass, string name,
  string typeinfo)


texttype
    A handle to the geometry to write to. Currently the only valid value
    is 0 or geoself, which means the current geometry in a node. (This
    argument may be used in the future to allow writing to other
    geometries.)

texttype
    One of "detail" (or "global"), "point", "prim", or "vertex".

    You can also use "primgroup", "pointgroup" or "vertexgroup" to read
    from groups.

name
    The name of the attribute for which to change the transformation
    info.

typeinfo
    The meaning of the attribute, which is used by transform nodes to
    determine how to modify the attribute. It is one of:

    "none"

    Don't transform.

    "point"

    Apply scales, rotations, and transformations.

    "hpoint"

    Apply scales, rotations, and transformations to this vector4.

    "vector"

    Apply scales and rotations, but not transformations.

    "normal"

    Apply rotations, apply scales with inverse-transpose.

    "color"

    Don't transform.

    "matrix"

    Apply scales, rotations, and transformations to this matrix.

    "quaternion"

    Apply rotations.

    "indexpair"

    Don't transform.

    "integer"

    Do not blend this value when points are averaged.

    "integer-blend"

    Integer values that blend when points are averaged.

RELATED

}

{
setcomp

Sets a single component of a vector or matrix type, or an item in an
array.

USAGES
  void|float setcomp(<vector> &target, float value, int index)
  Modifies the target vector in-place by changing the component at index
  to value.

  Returns value if called with a float return type.

  void|float setcomp(<matrix> &target, float value, int row, int column)
  Modifies the target matrix in-place by changing the component
  specified by row and column to value.

  Returns value if called with a float return type.

  <type> setcomp(<type> &array[]; <type> value, int index)
  Sets the item at index in array to value, and returns value.

  This is the same as array[index] = value.

RELATED

  * Arrays

  * getcomp

}

{
setcurrentlight

Sets the current light

USAGE
  int setcurrentlight(int lightid)

Sets the current light, and returns true when the light exists and was
successfully set. The lightid should be in the set of the values
returned by getlights. The current light is used by the following
shading functions:

  * renderstate

  * getlightname

RELATED

}

{
setdetailattrib

Sets a detail attribute in a geometry.

If you don't know the attribute class ahead of time, use setattrib.

USAGES
  int setdetailattrib(int geohandle, string name, <type> value, string
  mode="set")
  int setdetailattrib(int geohandle, string name, <type> value[], string
  mode="set")

Returns the value of geohandle on success or -1 on failure.


NOTE
    If the attribute does not exist, this function *creates the
    attribute* with a default value of zero, empty string, or an empty
    array. If you want to control the default value of a numeric
    attribute, use addattrib before setting the attribute.


texttype
    A handle to the geometry to write to. Currently the only valid value
    is 0 or geoself, which means the current geometry in a node. (This
    argument may be used in the future to allow writing to other
    geometries.)

name
    The attribute to set on the detail.

value
    The value to set the attribute to.

texttype
    (Optional) if given, this controls how the function modifies any
    existing value in the attribute.

    "set"

    Overwrite the attribute with the given value.

    "add"

    Add to the attribute the value.

    "min", "minimum"

    Set the attribute to the minimum of itself and the value.

    "max", "maximum"

    Set the attribute to the maximum of itself and the value.

    "mult", "multiply"

    Multiply the attribute by the value. For matrices, this will do
    matrix multiplication. For vectors, component-wise.

    "toggle"

    Toggles the attribute, independent of the source value. Useful for
    toggling group membership.

    "append"

    Valid for string and array attributes. Appends the source value to
    the end of the original value.

RELATED

  * setattrib

  * setpointattrib

  * setvertexattrib

  * setprimattrib

  * detail

}

{
setedgegroup

Sets edge group membership in a geometry.

USAGE
  int setedgegroup(int geohandle, string name, int pt0, int pt1, int
  value)

Changes an edge group membership on the given geometry. If the group
does not exist, it will be created.

geohandle is a handle to the geometry to write to. geoself() can be used
to get a handle to the current geometry.

name is the name of the group to modify.

pt0, pt1 are the point pair the edge to change group membership for.

If the value is anything other than 0, the point will be in the group.

RELATED

}

{
setpointattrib

Sets a point attribute in a geometry.

If you don't know the attribute class ahead of time, use setattrib.

USAGES
  int setpointattrib(int geohandle, string name, int point_num, <type>
  value, string mode="set")
  int setpointattrib(int geohandle, string name, int point_num, <type>
  value[], string mode="set")

Returns the value of geohandle on success or -1 on failure.


NOTE
    If the attribute does not exist, this function *creates the
    attribute* with a default value of zero, empty string, or an empty
    array. If you want to control the default value of a numeric
    attribute, use addattrib before setting the attribute.


texttype
    A handle to the geometry to write to. Currently the only valid value
    is 0 or geoself, which means the current geometry in a node. (This
    argument may be used in the future to allow writing to other
    geometries.)

name
    The attribute to set on the given point.

point_num
    The number of the point to set the attribute on.

value
    The value to set the attribute to.

texttype
    (Optional) if given, this controls how the function modifies any
    existing value in the attribute.

    "set"

    Overwrite the attribute with the given value.

    "add"

    Add to the attribute the value.

    "min", "minimum"

    Set the attribute to the minimum of itself and the value.

    "max", "maximum"

    Set the attribute to the maximum of itself and the value.

    "mult", "multiply"

    Multiply the attribute by the value. For matrices, this will do
    matrix multiplication. For vectors, component-wise.

    "toggle"

    Toggles the attribute, independent of the source value. Useful for
    toggling group membership.

    "append"

    Valid for string and array attributes. Appends the source value to
    the end of the original value.

RELATED

  * setattrib

  * setvertexattrib

  * setprimattrib

  * setdetailattrib

  * point

}

{
setpointgroup

Adds or removes a point to/from a group in a geometry.

USAGE
  int setpointgroup(int geohandle, string name, int point_num, int
  value, string mode="set")


texttype
    A handle to the geometry to write to. Currently the only valid value
    is 0 or geoself, which means the current geometry in a node. (This
    argument may be used in the future to allow writing to other
    geometries.)

name
    The name of the group to modify.

point_num
    The point number to add or remove from the group.

value
    1 to put the point in the group, 0 to remove the point from the
    group. This is ignored if mode is "toggle".

mode
    Use "set" to set the point's membership according to the value. Use
    "toggle" to toggle the point's membership, regardless of the value.

RELATED

  * Working with geometry groups in VEX

  * setprimgroup

  * setvertexgroup

}

{
setprimattrib

Sets a primitive attribute in a geometry.

If you don't know the attribute class ahead of time, use setattrib.

USAGES
  int setprimattrib(int geohandle, string name, int prim_num, <type>
  value, string mode="set")
  int setprimattrib(int geohandle, string name, int prim_num, <type>
  value[], string mode="set")

Returns the value of geohandle on success or -1 on failure.


NOTE
    If the attribute does not exist, this function *creates the
    attribute* with a default value of zero, empty string, or an empty
    array. If you want to control the default value of a numeric
    attribute, use addattrib before setting the attribute.


texttype
    A handle to the geometry to write to. Currently the only valid value
    is 0 or geoself, which means the current geometry in a node. (This
    argument may be used in the future to allow writing to other
    geometries.)

name
    The attribute to set on the given primitive.

prim_num
    The number of the primitive to set the attribute on.

value
    The value to set the attribute to.

texttype
    (Optional) if given, this controls how the function modifies any
    existing value in the attribute.

    "set"

    Overwrite the attribute with the given value.

    "add"

    Add to the attribute the value.

    "min", "minimum"

    Set the attribute to the minimum of itself and the value.

    "max", "maximum"

    Set the attribute to the maximum of itself and the value.

    "mult", "multiply"

    Multiply the attribute by the value. For matrices, this will do
    matrix multiplication. For vectors, component-wise.

    "toggle"

    Toggles the attribute, independent of the source value. Useful for
    toggling group membership.

    "append"

    Valid for string and array attributes. Appends the source value to
    the end of the original value.

RELATED

  * setattrib

  * setpointattrib

  * setvertexattrib

  * setdetailattrib

  * prim

}

{
setprimgroup

Adds or removes a primitive to/from a group in a geometry.

USAGE
  int setprimgroup(int geohandle, string name, int prim_num, int value,
  string mode="set")


texttype
    A handle to the geometry to write to. Currently the only valid value
    is 0 or geoself, which means the current geometry in a node. (This
    argument may be used in the future to allow writing to other
    geometries.)

name
    The name of the group to modify.

prim_num
    The primitive number to add or remove from the group.

value
    1 to put the primitive in the group, 0 to remove the primitive from
    the group. This is ignored if mode is "toggle".

mode
    Use "set" to set the primitive's membership according to the value.
    Use "toggle" to toggle the primitive's membership, regardless of the
    value.

RELATED

  * Working with geometry groups in VEX

  * setpointgroup

  * setvertexgroup

}

{
setprimintrinsic

Sets the value of a writeable primitive intrinsic attribute.

USAGES
  int setprimintrinsic(int geohandle, string name, int prim_num, <type>
  value, string mode="set")
  int setprimintrinsic(int geohandle, string name, int prim_num, <type>
  value[], string mode="set")

Despite the name, some "intrinsic" attributes on primitives are
writeable.


texttype
    A handle to the geometry to write to. Currently the only valid value
    is 0 or geoself, which means the current geometry in a node. (This
    argument may be used in the future to allow writing to other
    geometries.)

name
    The name of the intrinsic to set.

prim_num
    The number of the primitive to change the value on.

texttype
    (Optional) if given, this controls how the function modifies any
    existing value in the attribute.

    "set"

    Overwrite the attribute with the given value.

    "add"

    Add to the attribute the value.

    "min", "minimum"

    Set the attribute to the minimum of itself and the value.

    "max", "maximum"

    Set the attribute to the maximum of itself and the value.

    "mult", "multiply"

    Multiply the attribute by the value. For matrices, this will do
    matrix multiplication. For vectors, component-wise.

    "toggle"

    Toggles the attribute, independent of the source value. Useful for
    toggling group membership.

    "append"

    Valid for string and array attributes. Appends the source value to
    the end of the original value.

RELATED

  * setattrib

  * setprimattrib

}

{
setprimvertex

Rewires a vertex in the geometry to a different point.

USAGE
  int setprimvertex(int geohandle, int prim, int vtxofprim, int pt)

Rewires a specified vertex to a point number.

If the point number is -1, no rewiring is done.

If prim is -1, vtxofprim is treated as a linear index, and vice versa.
Otherwise, the pair (prim, vtxofprim) is used to identify a vertex in a
primitive's vertex list.

Since this sets a vertex's point, not a primitive's vertex, it's
recommended to use the equivalent function setvertexpoint for clarity,
instead.

RELATED

  * setvertexpoint

}

{
setsamplestore

Stores sample data in a channel, referenced by a point.

USAGES
  int setsamplestore(string channel, vector P, int value)
  int setsamplestore(string channel, vector P, float value)
  int setsamplestore(string channel, vector P, vector value)
  int setsamplestore(string channel, vector P, vector4 value)

Stores a value in a named channel at a specified point. Returns a non-
zero value on success, or returns 0 if the data could not be set.

The sample store can be thought of as an in-memory point cloud, storing
shading data at points. This allows data to be accessed across shader
boundaries, unlike the internal export/import system. For example, a
lens shader could store data to be passed to the surface shader, an
operation that is not supported using export variables due to the layout
of the shading pipeline.

Please note that the stored samples can only be accessed within the same
render tile.

EXAMPLE

  > cvex displacedlens(
  >     // Inputs
  >     float x = 0;
  >     float y = 0;
  >     float Time = 0;
  >     float dofx = 0;
  >     float dofy = 0;
  >     float aspect = 1;
  > 
  >     float displaceScale = 1.0;
  >     float displaceGain = 0.1;
  > 
  >     // Outputs
  >     export vector P = 0;
  >     export vector I = 0;
  > )
  > {
  >     P = {x, y, 0};
  >     I = {1, 0, 0};
  > 
  >     vector displace = noise(P * displaceScale) * displaceGain;
  >     I += displace;
  > 
  >     // Store the displacement at the eye point, 'P'
  >     int status = setsamplestore("displacedlens_d", P, displace);
  > }
  > 
  > surface mysurface()
  > {
  >     // Get the displacement at the eye point, 'Eye'
  >     vector displace = 0;
  >     int status = getsamplestore("displacedlens_d", Eye, displace);
  > 
  >     //...
  > }

RELATED

  * getsamplestore

}

{
setvertexattrib

Sets a vertex attribute in a geometry.

USAGES
  int setvertexattrib(int geohandle, string name, int prim_num, int
  vertex_num, <type> value, string mode="set")
  int setvertexattrib(int geohandle, string name, int prim_num, int
  vertex_num, <type> value[], string mode="set")

*To use a linear vertex index*, set the prim_num to the *linear vertex
number* and set vertex_num to -1. Note that *this is different* from how
most other vertex functions work.

Returns the value of geohandle on success or -1 on failure.


NOTE
    If the attribute does not exist, this function *creates the
    attribute* with a default value of zero, empty string, or an empty
    array. If you want to control the default value of a numeric
    attribute, use addattrib before setting the attribute.


texttype
    A handle to the geometry to write to. Currently the only valid value
    is 0 or geoself, which means the current geometry in a node. (This
    argument may be used in the future to allow writing to other
    geometries.)

name
    The name of the group to modify.

prim_num
    The number of the primitive containing the vertex you want to
    add/remove.

vertex_num
    The vertex offset on the primitive of the vertex you want to
    add/remove.

value
    The value to set the attribute to.

texttype
    (Optional) if given, this controls how the function modifies any
    existing value in the attribute.

    "set"

    Overwrite the attribute with the given value.

    "add"

    Add to the attribute the value.

    "min", "minimum"

    Set the attribute to the minimum of itself and the value.

    "max", "maximum"

    Set the attribute to the maximum of itself and the value.

    "mult", "multiply"

    Multiply the attribute by the value. For matrices, this will do
    matrix multiplication. For vectors, component-wise.

    "toggle"

    Toggles the attribute, independent of the source value. Useful for
    toggling group membership.

    "append"

    Valid for string and array attributes. Appends the source value to
    the end of the original value.

RELATED

  * setattrib

  * setpointattrib

  * setprimattrib

  * setdetailattrib

  * vertex

}

{
setvertexgroup

Adds or removes a vertex to/from a group in a geometry.

USAGE
  int setvertexgroup(int geohandle, string name, int prim_num, int
  vertex_num, int value, string mode="set")


texttype
    A handle to the geometry to write to. Currently the only valid value
    is 0 or geoself, which means the current geometry in a node. (This
    argument may be used in the future to allow writing to other
    geometries.)

*To use a linear vertex index*, set the prim_num to the *linear vertex
number* and set vertex_num to -1. Note that *this is different* from how
most other vertex functions work.


name
    The name of the group to modify.

prim_num
    The number of the primitive containing the vertex you want to
    add/remove.

vertex_num
    The vertex offset on the primitive of the vertex you want to
    add/remove.

value
    1 to put the vertex in the group, 0 to remove the vertex from the
    group. This is ignored if mode is "toggle".

mode
    Use "set" to set the vertex's membership according to the value. Use
    "toggle" to toggle the vertex's membership, regardless of the value.

RELATED

  * Working with geometry groups in VEX

  * setprimgroup

  * setpointgroup

  * vertexindex

}

{
setvertexpoint

Rewires a vertex in the geometry to a different point.

USAGE
  int setvertexpoint(int geohandle, int prim, int vtxofprim, int pt)

Rewires a specified vertex to a point number.

If the point number is -1, no rewiring is done.

If prim is -1, vtxofprim is treated as a linear index, and vice versa.
Otherwise, the pair (prim, vtxofprim) is used to identify a vertex in a
primitive's vertex list.

This function is a new name for the equivalent function setprimvertex,
added for clarity.

RELATED

  * vertexpoint

  * vertexprim

  * vertexprimindex

  * vertexindex

  * vertexnext

  * vertexprev

}

{
shadow

Calls shadow shaders for the current light source.

This function can only be called from within an illuminance statement.

USAGES
  void shadow(vector &Cl)
  vector shadow(vector Cl)
  Uses the P and L global variables.

  void shadow(vector &Cl, vector P, vector L)
  vector shadow(vector Cl, vector P, vector L)

RELATED

}

{
shadow_light

Executes the shadow shader for a given light and returns the amount of
shadowing as a multiplier of the shaded color.

USAGE
  vector shadow_light(int lightid, vector pos, vector dir, float time,
  ...)

This operation is similar to the shadow() function but it allows
execution of the shadow shader outside an illuminance loop. The position
and direction toward the light source are provided directly, and the
shadow shader is executed - returning the shadow multiplier. To produce
the final shadowed color, multiply the shaded color by the value
returned by shadow_light.

Keyword variadic arguments can be passed to the shadow shader, for
import in the shadow shader with with simport().


lightid
    A light identifier, as returned by getlights.

pos
    The origin of the ray (such as the global variable P).

dir
    Direction vector from the origin. The length of this vector should
    be the distance from _pos_ to the light source.

time
    Time to send the ray at.

RELATED

  * shadow

  * sample_light

  * intersect_lights

}

{
shadowmap

The shadowmap function will treat the shadow map as if the image were
rendered from a light source.

USAGES
  float|vector shadowmap(string filename, vector Pndc, float spread,
  float bias, float quality, ...)
  float|vector shadowmap(string filename, vector Pndc, float spread,
  float bias, float quality, ...)
  vector shadowmap(string filename, vector Pndc1, vector Pndc2, vector
  Pndc3, vector Pndc4, float spread, float bias, float quality, ...)
  Allows you to specify your own sampling rectangle. If you don't want
  any filtering of the shadow map or you are unable to compute your own
  derivatives, you can just pass in the same vector repeated 4 times to
  perform no filtering.

The shadowmap function will treat the shadow map as if the image were
rendered from a light source. You use this to access both depth maps and
deep shadow maps. In both cases it returns a vector where each color
component has the visibility of the light source to the point for that
color.


filename
    A path to the shadow or depth map.

Pndc
    The position of the point being shaded in the NDC space of the
    light's projection.

spread
    A softness control on the shadow.

bias
    Controls how accurate the depth samples need to be.

quality
    A general control to increase/decrease sampling, where 1 is default
    quality.

    The fractional amount of illumination which reaches the sample
    point. For example, if the point is fully in shadow, the return
    value will be 0, if it is fully illuminated, the return value will
    be 1.

The shadowmap() VEX function takes the same variadic arguments as
texture(). For additional information, see texture.

DEEP CAMERA MAP CHANNELS

    If the shadow map is a Deep camera map, shadowmap takes an optional
    extra argument "channel", followed by the string name of the channel
    in the map evaluate.

  > shadowmap(mapname, pz, spread, bias, quality, "channel", channel);

    This uses the same opacity semantics, so the function will return
    the complement of the actual color. So, to get accurate results, you
    will usually want to evaluate:

  > {1,1,1} - shadowmap(...);

RELATED

  * depthmap

}

{
shimport

Imports a variable from the shadow shader for the surface.

This function is only valid inside an illuminance loop.

USAGE
  int shimport(string variable_name, <type> &value)


variable_name
    The variable to import from the shadow shader.

value
    If the variable is successfully read, the value is copied into this
    variable.

    1 if the variable is defined and exported, 0 otherwise.

RELATED

}

{
shl

Bit-shifts an integer left.

USAGE
  int shl(int a, int bits)

Bit-shifts a to the left by bits.

RELATED

  * shr

  * shrz

}

{
shr

Bit-shifts an integer right.

USAGE
  int shr(int a, int bits)

Bit-shifts a to the right by bits.

This is an arithmetic shift, the sign is shifted with it. Thus, shr(-1,
2) will give -1, not zero.

RELATED

  * shl

  * shrz

}

{
shrz

Bit-shifts an integer right.

USAGE
  int shrz(int a, int bits)

Bit-shifts a to the right by bits. This is a zero-extend shift, so new
bits are always zero. Thus, shrz(-1, 2) is zero, not -1.

RELATED

  * shl

  * shr

}

{
sign

Returns -1, 0, or 1 depending on the sign of the argument.

USAGES
  int sign(int n)
  float sign(float n)
  For a scalar value, returns -1 for a negative number, 0 for the number
  zero, and +1 for a positive number.

  vector2 sign(vector2 v)
  vector sign(vector v)
  vector4 sign(vector4 v)
  For vector values the sign of the individual components is returned as
  a vector.

RELATED

  * abs

}

{
simport

Imports a variable sent by a surface shader in an illuminance loop.

USAGE
  int simport(string name, <type> &value)

Imports a variable from the surface shader.

Mantra runs the shaders for a surface in a fixed order:

 1. Displacement

 2. Surface (possibly calling light shaders in illuminance loops)

 3. Fog (possibly calling light shaders in illuminance loops)

Once the displacement shader has run, you can use dimport to retrieve
exported variables from it. Once the surface shader has run, you can use
simport to retrieve exported variables from it.

If the shader variable named by the first argument is defined and
exported, the function returns 1 and puts the value in the second
argument. Otherwise, it returns 0.

RELATED

  * dimport

}

{
sin

Returns the sine of the argument.

USAGES
  float sin(float n)
  Returns the sine of n, where n is in radians.

  <vector> sin(<vector> n)
  Returns a new vector with sin() applied to each component.

RELATED

  * sinh

  * cos

  * tan

  * asin

}

{
sinh

Returns the hyperbolic sine of the argument.

USAGES
  float sinh(float n)
  Returns the hyperbolic sine of n.

  vector2 sinh(vector2 v)
  vector sinh(vector v)
  vector4 sinh(vector4 v)
  Returns a new vector with sinh() applied to each component.

RELATED

  * sin

  * cosh

  * tanh

  * cos

  * tan

}

{
sleep

Yields processing for a certain number of milliseconds.

USAGE
  void sleep(int milliseconds)

Yields processing for a certain number of milliseconds.

RELATED

}

{
slerp

Quaternion blend between q1 and q2 based on the bias.

USAGES
  vector4 slerp(vector4 q1, vector4 q2, float bias)
  Blends between quaternions <q1> and <q2> based on the <bias>.

  vector4 slerp(vector4 qs[], float weights[])
  Blends between any number of quaternions with the specified
  corresponding weights.

slerp(q1,q2,bias) should be approximately equivalent to
slerp(array(q1,q2), array(1.0-bias,bias)).

RELATED

}

{
slice

Slices a sub-string or sub-array of a string or array.

USAGES
  string slice(string s; int start; int end)
  string slice(string s; int start; int end; int step)
  Extracts a string from a larger string.

  <type>[] slice(<type> s[]; int start; int end)
  <type>[] slice(<type> s[]; int start; int end; int step)
  Extracts a sub-array from a larger array.

  string slice(string s; int hasstart; int start; int hasend; int end;
  int hasstep; int step)
  <type>[] slice(<type> array[]; int hasstart; int start; int hasend;
  int end; int hasstep; int step)
  A general-purpose signature to support the slicing syntax. If hasstart
  is 0, it ignores start and uses 0. If hasend is 0 it ignores end and
  uses the length of the array. If hasstep is 0 it ignores step and uses
  1.

  * This is the function equivalent of using value[start:end:step]
    slicing syntax.

  * If start or end are negative, they count from the end of the
    string/array.

  * The computed range is clamped to the bounds of the original
    string/array.

  * If step is zero, the function returns an empty string/array.

  * If step is negative, the items are returned in reverse, and end
    should be less than start.

EXAMPLES

  > int[] nums = {10, 20, 30, 40, 50, 60};
  > slice(nums, 1, 3) == {20, 30};  // nums[1:3]
  > slice(nums, 1, -1) == {20, 30, 30, 40, 50};  // nums[1:-1]
  > slice(nums, 0, len(nums), 2) == {20, 40, 60};  // nums[0:len(nums):2]
  > slice(nums, 0, 0, 0, 0, 1, 2) == {20, 40, 60};  // nums[::2]

RELATED

  * Arrays

  * len

  * push

  * append

  * resize

}

{
slideframe

Finds the normal component of frame slid along a curve.

USAGE
  vector slideframe(const vector x0, const vector t0, const vector n0,
  const vector x1, const vector t1)

Given two points x0 and x1 with respective tangent vectors t0 and t1
along a curve, as well as the curve normal n0 at the first point, this
function returns the minimum rotation transfer of n0 to the second
point.

You use this function to extend a curve normal at the starting point of
a curve to the entire curve in a rotation minimizing fashion.

See an example.

}

{
smooth

Computes ease in/out interpolation between values.

USAGES
  float smooth(float value1, float value2, float amount)
  float smooth(float value1, float value2, float amount, float rolloff)

Computes a number between zero and one. Returns 0 if the amount passed
in is less than or equal to value1, 1 if the amount is greater than or
equal to value2.

If the amount is between value1 and value2, a smooth (easin/easeout)
interpolation is computed. If a rolloff is specified, the inflection
point of the blend will be shifted.

If the rolloff is greater than 1, the shift will be to the right, if the
rolloff is less than 1 (and greater than 0), the shift will be to the
left.

RELATED

}

{
smoothrotation

Returns the closest equivalent Euler rotations to a reference rotation.

USAGE
  vector smoothrotation(int order, vector r, vector r_reference)

Returns the Euler rotations that have the closest values to
<r_reference> while still describing the same orientation as <r>.
Typically, <r_reference> will be the rotations from the previous sample
or frame.

The angles are in radians. Use the radians() function to convert degrees
into radians.

The rotation order is specified by the <order> parameter. Use the
constants defined in $HH/vex/include/math.h (for example, XFORM_XYZ).

RELATED

}

{
snoise

These functions are similar to wnoise.

USAGES
  float snoise(vector pos)
  vector snoise(vector pos)
  float snoise(vector pos, int turbulence, float rough, float atten)
  vector snoise(vector pos, int turbulence, float rough, float atten)

These functions are similar to wnoise. The noise returned is based on
the weights of all of the closest points, with each point's contribution
based on a meta-ball like rolloff curve. That is, if the sample point is
close to the sphere, its contribution will be greater.

The bounds on the noise are roughly (-1.7, 1.7). Only 3D noise is
supported. However, this noise has the ability to compute turbulence
with roughness and attenuation on the noise.

RELATED

  * Noise and randomness

  * anoise

  * curlnoise

  * flownoise

  * noise

  * onoise

  * pnoise

  * snoise

  * vnoise

  * wnoise

  * xnoise

}

{
solid_angle

Computes the solid angle (in steradians) a BSDF function subtends.

USAGE
  float solid_angle(bsdf b, int mask)


b
    BSDF to sample.

mask
    A bitmask indicating which types of bounces to evaluate.

    See bouncemask for information on component label bitmasks.

EXAMPLES

  > // Split BSDF into component lobes
  > bsdf lobes[] = split_bsdf(hitF);
  > 
  > // Get solid angle of lobes
  > float angles[];
  > resize(angles, len(lobes));
  > for (int i = 0; i < len(lobes); i++)
  > {
  >     angles[i] = solid_angle(lobes[i], PBR_ALL_MASK);
  > }
  > 
  > // Compute PDF from angles
  > float pdf[] = compute_pdf(angles);
  > 
  > // Compute CDF from PDF
  > float cdf[] = compute_cdf(pdf);
  > 
  > // Randomly select a BSDF based on albedo distribution
  > int id = sample_cdf(cdf, sx);
  > 
  > // Do something with the selected BSDF
  > // lobes[id] ...

RELATED

  * split_bsdf

  * sample_bsdf

  * eval_bsdf

  * albedo

}

{
solvecubic

Solves a cubic function returning the number of real roots.

USAGES
  int solvecubic(float a, float b, float c, float d, float &t1, float
  &t2, float &t3)
  int solvecubic(float a, float b, float c, float d, vector2 &t1,
  vector2 &t2, vector2 &t3)

Solves the given cubic function where <a> , <b>, <c>, and <d> are the
coefficients as so: ax^3 + bx^2 + cx + d = 0

Returns the number of real roots.

In the real case the returned roots will be in ascending order. In case
of only one root that root is filled into <t1>, <t2>, and <t3>.

In the complex case <t1>, <t2>, and <t3> are the complex roots.

RELATED

  * solvequadratic

  * solvepoly

}

{
solvepoly

Finds the real roots of a polynomial.

USAGE
  int solvepoly(float coef[], float &roots[], int maxiter=0)


coef
    An array of coefficients of the polynomial.

    You must order the coefficients such that coef[i] should be x^i.
    *This is reverse of the order you would write the polynomial out
    normally*.

&roots
    The function overwrites this array with the real roots of the
    polynomial, in ascending order.

    The number of real roots.

RELATED

  * solvequadratic

  * solvecubic

}

{
solvequadratic

Solves a quadratic function returning the number of real roots.

USAGES
  int solvequadratic(float a, float b, float c, float &t1, float &t2)
  int solvequadratic(float a, float b, float c, vector2 &t1, vector2
  &t2)

Solves the given quadratic function where <a> , <b>, and <c> are the
coefficients as so: ax^2 + bx + c = 0.

Returns the number of real roots.

In the real case <t1> and <t2> are filled such that <t1> <= <t2>. If
there is only one root then <t1> = <t2>. If there are no roots then <t1>
= <t2> and is the projection of the vertex of the quadratic function
onto the x-axis.

In the complex case <t1> and <t2> are the complex roots.

RELATED

  * solvecubic

  * solvepoly

}

{
sort

Returns the array sorted in increasing order.

USAGES
  int[] sort(int values[])
  float[] sort(float values[])
  string[] sort(string values[])

Returns a version of the given array sorted in increasing order.


  * argsort and sort use a stable sort.

  * Use reverse to reverse the order of the sort.

EXAMPLES


    Sort an array of numbers in descending order
      > int numbers[] = {5, 2, 90, 3, 1};
      > int descending_nums[] = reverse(sort(numbers));  // {90, 5, 3, 2, 1}

RELATED

  * Arrays

  * argsort

  * reorder

  * reverse

}

{
specular

Returns a specular BSDF or computes specular shading.


USAGES
  bsdf specular(vector dir, ...)
  Returns a specular BSDF where <dir> is the direction of specularity.
  See writing a PBR shader for information on BSDFs.

  vector specular(vector nml, vector V, float roughness, ...)
  Computes specular shading.

LIGHT INCLUSION/EXCLUSION OPTIONS


    categories
        Specifies lights to include/exclude by their "category" tags.
        This is the preferred include/exclude lights rather than pattern
        matching light names with the "lightmask" keyword argument.

        For example:

      > diff = diffuse(nml, "lightmask", "hero | fill");

        See light categories for more information.

    lightmask
        When evaluating light and shadow shaders, objects have pre-
        defined light masks. This mask is usually specified in the
        geometry object and specifies a list of lights which are used to
        illuminate a surface or fog shader. It is possible to override
        the default light mask by specifying a "lightmask" argument.

        For example:

      > diff = diffuse(nml, "lightmask", "light*,^light2");

        ...will cause all lights whose names begin with "light" except
        for a light named "light2" to be considered for diffuse
        illumination.

        All Houdini scoping patterns, excepting group expansion, are
        supported:

      * * - wild-card match

      * ? - single character match

      * ^ - exclusion operator

      * [list] - character list match

RELATED

  * matchvex_specular

  * phong

  * Writing a PBR shader

}

{
specularBRDF

Returns the computed BRDFs for the different lighting models used in VEX
shading.

USAGE
  float specularBRDF(vector L, vector N, vector V, float rough)

specularBRDF, phongBRDF, blinnBRDF, and diffuseBRDF return the computed
BRDF for the different lighting models used in VEX shading. You can use
them in custom illuminance loops to replicate the lighting models of the
corresponding VEX lighting functions.

> vector nn = normalize(frontface(N, I));
> vector ii = normalize(-I);
> Cf = 0;
> illuminance(P, nn)
> {
>     vector ll = normalize(L);
>     Cf += Cl * (specularBRDF(ll, nn, ii, rough) + diffuseBRDF(ll, nn));
> }

RELATED

  * phongBRDF

  * blinnBRDF

  * diffuseBRDF

  * illuminance

}

{
spline

Samples a value along a polyline or spline curve.

USAGES
  float spline(string basis; float sample_pos; float value1, ...)
  vector spline(string basis; float sample_pos; vector value1, ...)
  vector4 spline(string basis; float sample_pos; vector4 value1, ...)
  This version takes a single basis to use for all keys, and takes the
  (linearly spaced) key values as variadic arguments.

  float spline(string basis, float sample_pos, float values[], ...)
  vector spline(string basis; float sample_pos; vector values[], ...)
  vector4 spline(string basis; float sample_pos; vector4 values[], ...)
  This version takes a single basis to use for all keys, and takes the
  (linearly spaced) key values as an array.

  float spline(string bases[], float sample_pos, float values[], ...)
  vector spline(string bases[]; float sample_pos; vector values[], ...)
  vector4 spline(string bases[]; float sample_pos; vector4 values[],
  ...)
  This version takes an array specifying the bases to use between each
  pair of keys, and the (linearly spaced) key values as an array.

  float spline(string bases[], float sample_pos, float values[], float
  positions[], ...)
  vector spline(string bases[]; float sample_pos; vector values[], float
  positions[], ...)
  vector4 spline(string bases[]; float sample_pos; vector4 values[],
  float positions[], ...)
  This version takes an array specifying the bases to use between each
  pair of keys, an array of key values, and an array of key positions.

  These forms take an array of strings specifying the interpolation
  bases between the keys, an array of key values, and an array of key
  positions. They ensure that the interpolation curve is smooth
  (tangent-continuous) across the control points (keys) if the adjoining
  segments have the same basis, even if the key positions are not evenly
  spaced (i.e., are non-uniform and the distances between them are not
  equal).


basis, bases
    These are the same interpolations supported by ramp parameters.


    "constant"
        Maintains each key value until the next key, creating a "stair
        step" curve.

    "linear"
        Connects the key points with a polyline.

        For example, if you specified four values:

      > spline("linear", t, v0, v1, v2, v3)


        ...the function returns the height of the orange dot at position
        <sample_pos>.

    "cubic" (or "catmullrom", "cspline")
        Connect the point values with a Catmull-Rom spline.

        Note that the first and last values are outside the sample area
        to provide the slope of the curve at the second point (at the
        start of the sample range) and the second-to-last point (at the
        end of the sample range).

        For example, if you specified six values:

      > spline("catrom", t, v0, v1, v2, v3, v4, v5)


        ...the function returns the height of the orange dot at position
        <t>.

        (This image is for illustration only, it does not show the
        correct curve for the shown points.)

    "linearsolve" (or "solvelinear")
        Maps between a set of non-uniform positions and a set of values.
        The kspline function does this mapping implicitly.

      > tk = spline("linearsolve", t, k0, k1, k2, k3, ...);
      > v = spline(basis, tk, v1, v2, v3, ...);

        (Technically, linearsolve interprets the values as key values,
        solves the intersection of the spline, and returns the intercept
        point.)

    "monotonecubic"

sample_pos
    The position along the curve at which to sample the value.

    The value at <sample_pos> along a polyline or cubic spline.


NOTE
    For b-spline basis, this function implicitly assumes the
    multiplicity of 3 for b-spline curve end point, even though the
    given control points and knots are not explicitly repeated. This
    ensures the curve passes through the end control points, making it
    easier to create continuous ramp curves with mixed interpolation
    bases (e.g., b-spline basis segments surrounded by linear
    interpolation segments).

RELATED

  * cspline

  * kspline

  * ckspline

  * lspline

  * lkspline

}

{
split

Splits a string into tokens.

USAGES
  string[] split(string s)
  string[] split(string s, string separators)
  string[] split(string s, string separators; int maxsplits)

Splits a string into tokens by removing separator characters from the
string and creating an array entry for each substring bounded by
separators. When no separator string is provided, the string is split on
whitespace (spaces, tab, and return).

The maxsplits option limits the number of times the string is split,
this is useful to peel off one token at a time from a larger string.


NOTE
    This differs from Python's split() in that it takes a list of
    separators, not a single string to use as a separator.

RELATED

}

{
split_bsdf

Splits a bsdf into its component lobes.

USAGES
  void split_bsdf(bsdf &lobes[], bsdf source, float &weights[])
  void split_bsdf(bsdf &lobes[]; bsdf source; float &weights[]; int
  mask)
  void split_bsdf(bsdf &lobes[], bsdf source, float &weights[], int
  mask, int type)
  void split_bsdf(bsdf &lobes[], bsdf source, float &weights[], int
  mask, int type, float u)
  void split_bsdf(bsdf &lobes[], bsdf source, float &weights[], int
  mask, int type, float u, float cdf[])


&lobes
    The function overwrites this array with the BSDFs for the component
    lobes.

source
    The BSDF to split.

weights
    The function fills this array with the weights for the split lobes
    (same length as the returned bsdf array). When you sample
    Illumination using the returned lobes you must scale it by these
    weights.

mask
    A bitmask indicating which types of bounces to evaluate.

    See bouncemask for information on component label bitmasks.

type
    How to split the lobes. You can #import "pbr.h" to get constant
    values representing the different split types:

  * PBR_SPLIT_FULL = 0

  * PBR_SPLIT_RANDOM = 1

  * PBR_SPLIT_ALBEDO = 2

  * PBR_SPLIT_COMPONENT = 3

  * PBR_SPLIT_DEFAULT = PBR_SPLIT_ALBEDO

u
    Random value to sample the CDF at.

cdf
    CDF used to control sampling among components of the BSDF.

    An array of bsdf objects representing the lobes.

EXAMPLES

  > // Split BSDF into component lobes
  > float weights[];
  > bsdf lobes[];
  > split_bsdf(lobes, hitF, weights);
  > 
  > // Get albedos of lobes
  > float albedos[];
  > resize(albedos, len(lobes));
  > for (int i = 0; i < len(lobes); i++)
  > {
  >     albedos[i] = luminance(albedo(lobes[i], -hitnI)) * weights[i];
  > }
  > 
  > // Compute CDF
  > float cdf[] = compute_cdf(albedos);
  > 
  > // Randomly select a BSDF based on albedo distribution
  > int index = 0;
  > sample_cdf(cdf, s.x, index);
  > 
  > // Do something with the selected BSDF
  > // lobes[index] ...

RELATED

  * sample_bsdf

  * eval_bsdf

  * albedo

  * create_cdf()

  * sample_cdf

}

{
splitpath

Splits a file path into the directory and name parts.

USAGE
  void splitpath(string fullpath, string &dir, string &name)

Splits a string representing a path into the directory and name
components.

RELATED

}

{
sprintf

Formats a string like printf but returns the result as a string instead
of printing it.

USAGE
  string sprintf(string format, ...)
  Formats a string like printf but returns the result as a string
  instead of printing it.

RELATED

  * printf

}

{
sqrt

Returns the square root of the argument.

USAGES
  float sqrt(float value)
  <vector> sqrt(<vector> value)
  Returns the square root of value. For vectors, this is done per-
  component.


NOTE
    The square root of a negative number is defined to be zero.

    To quote Edgar Rice Burroughs, Pirates of Venus: _"I saw that
    argument was useless and said no more: there is no use arguing with
    a man who can multiply anything by the square root of minus one"_

RELATED

}

{
sssapprox

Creates an approximate SSS BSDF.

USAGE
  bsdf sssapprox(vector albedo, float meanFreePath, float roughness,
  float scale, ...)


albedo
    Average surface reflectance.

meanFreePath
    Average distance between scattering events.

roughness
    A value from '0.0' to '1.0' blending to an ideal diffuse
    transmission reflectance profile.

scale
    Physical scale of the material. Smaller scale values will make the
    material more transmissive.

See writing a PBR shader for information on BSDFs.

Models SSS illumination based on an approximate reflectance profile.

RELATED

  * diffuse

  * translucent

  * Writing a PBR shader

}

{
startswith

Returns 1 if the string starts with the specified string.

USAGE
  int startswith(const string str, const string startswith)

Returns 1 if the string ends with the given string. 0 otherwise.

RELATED

  * endswith

}

{
storelightexport

Stores exported data for a light.

USAGES
  void storelightexport(string lightname, string exportname, <type>
  value)
  void storelightexport(string lightname, string exportname, <type>
  value[])

Stores a per-light export to a shader export variable. This method
should normally be called for each light to ensure that all light
exports for the given variable are created, for example by placing the
call in an illuminance() loop or a loop over the light array.

This method replaced the storelightexports() method used in Houdini 12.5
and earlier.

EXAMPLES

  > surface test(export vector perlight = {0,0,0})
  > {
  >     int             lights[] = getlights();
  >     for (int i = 0; i < len(lights); i++)
  >     {
  >         vector val = set(lights[i], 0, 0);
  >         storelightexport(getlightname(lights[i]), "perlight", val);
  >     }
  > }

RELATED

}

{
strip

Strips leading and trailing whitespace from a string.

USAGES
  string strip(string value)
  string strip(string value, string whitespace)

Returns a string with the leading and trailing whitespace removed. If
whitespace is provided, it is a string of characters that will be
stripped.

This is also equivalent of doing both rstrip and lstrip on a string.

RELATED

  * rstrip

  * lstrip

}

{
strlen

Returns the length of the string.

USAGE
  int strlen(string string)

Returns the length of the string in bytes.

RELATED

}

{
sum

Returns the sum of a list of numbers.

USAGES
  float sum(float n)
  int sum(int n)
  Returns the argument.

  float sum(<vector> v)
  Returns the sum of the vector's components.

  int sum(int nums[])
  float sum(float nums[])
  Returns the sum of the items of the array.

  <vector> sum(<vector> arr[])
  Returns a vector where the components are the sums of the
  corresponding components in the vectors in the array.

RELATED

  * product

}

{
switch

Use a different bsdf for direct or indirect lighting.

USAGE
  bsdf switch(bsdf direct, bsdf indirect)

This makes it possible to use a different bsdf for direct and indirect
lighting.

RELATED


}

{
swizzle

Rearranges the components of a vector.

USAGES
  vector2 swizzle(vector2 v; int i0, int i1)
  vector swizzle(vector v; int i0, int i1, int i2)
  vector4 swizzle(vector4 v; int i0, int i1, int i2, int i3)

The integer arguments specify which component of the original vector to
put in each place in the returned vector. So, for example, if i0 is 3,
the third component of the original vector is copied to the zeroth
component of the returned vector.

Integer arguments less than 0 or greater than the number of components
are clamped.

EXAMPLES

  > swizzle({10, 20, 30, 40}, 3, 2, 1, 0) == {40, 30, 20, 10}
  > swizzle({10, 20, 30, 40}, 0, 0, 0, 0) == {10, 10, 10, 10}

RELATED

}

{
tan

Returns the trigonometric tangent of the argument

USAGES
  float tan(float n)
  Returns the trigonometric tangent of n, where n is in radians.

  vector2 tan(vector2 v)
  vector tan(vector v)
  vector4 tan(vector4 v)
  Returns a new vector with tan() applied to each component.

RELATED

  * atan

  * tanh

  * sin

  * cos

}

{
tanh

Returns the hyperbolic tangent of the argument

USAGES
  float tanh(float n)
  Returns the hyperbolic tangent of n.

  vector2 tanh(vector2 n)
  vector tanh(vector n)
  vector4 tanh(vector4 n)
  Returns a new vector with tanh() applied to each component.

RELATED

  * tan

  * sinh

  * cosh

  * sin

  * cos

}

{
tet_adjacent

Returns primitive number of an adjacent tetrahedron.

USAGE
  int tet_adjacent(<geometry>, int primindex, int faceno)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

primindex
    The primitive number.

faceno
    The face on the tetrahedron. Face 0 is the triangle that doesn't
    have vertex 0.

    The primitive number of the tetrahedron opposite the given vertex.
    Returns -1 f the primitive is not a tet or doesn't have an adjacent
    tetrahedron.

Use tet_faceindex to get the vertex indices of each face of a
tetrahedron.

RELATED

  * tet_faceindex

}

{
tet_faceindex

Returns vertex indices of each face of a tetrahedron.

USAGE
  int tet_faceindex(int faceno, int vtxno)

Returns -1 if an invalid number is specified.

Returns 0 to 3 to refer to the four vertices of a generic tetrahedron.


faceno
    The face on the tetrahedron. Face 0 is the triangle that doesn't
    have vertex 0.

vtxno
    Which vertex on the triangle to return, 0 to 2. Starts with the
    lowest number and follows Houdini's winding convention, ie, face 0
    is vertices 1, 2, and 3.

RELATED

}

{
teximport

Imports attributes from texture files.

USAGES
  int teximport(string map, string attribute; <type> &value)
  Reads a single value. Returns 1 on success or 0 on failure.

  int teximport(string map, string token; int|string &values[])
  Returns the number of strings in the array.

  Note that if the values cannot be imported, values will not be written
  to and may remain uninitialized.

This function queries metadata stored in an image file, and works with
most texture formats.

You can choose what properties are stored using the vm_saveoptions
Houdini property on a camera or light (image:saveoptions in IFD).
However, the defaults probably contain all the information you'd want.
See rendering properties.

QUERYABLE ATTRIBUTES

    There are several generic attributes you can always query:


    int texture:xres
        X resolution of the texture map.

    int texture:yres
        Y resolution of the texture map.

    int texture:channels
        Number of channels in the texture map.

    vector texture:resolution
        Resolution of the texture as the vector (xres, yres, channels).

    matrix texture:worldtoview
        The transform matrix that will take world space points into the
        camera space used to generate the image.

    matrix texture:projection
        The transform matrix representing the projection matrix of the
        camera used to generate the image.

    matrix texture:worldtondc
        The transform matrix that will transform world spaced points
        into the NDC space of the camera used to make the image. The
        points are generated in homogeneous coordinates. That is, to get
        the values in the range 0 to 1:

      > matrix ndc;
      > if (teximport(map, "texture:worldtoNDC", ndc))
      > {
      >     vector P_ndc = pos * ndc;
      >     // If the camera is a perspective camera,
      >     // dehomogenize the point
      >     if (getcomp(ndc, 2, 3) != 0)
      >     {
      >         P_ndc.x = P_ndc.x / P_ndc.z;
      >         P_ndc.y = P_ndc.y / P_ndc.z;
      >     }
      >     // Finally, scale and offset XY
      >     // from [-1,1] to [0,1]
      >     P_ndc *= {.5, .5, 1};
      >     P_ndc += {.5, .5, 0};
      > }

    string texture:tokens
        A space separated list of all attribute names you can query.


    The string &values[] version can query the following

        texture:channelnames
            List of all the raster plane channel names.

        texture:channelsize
            This returns an array of the number of floats in each image
            channel.

        texture:channelstorage
            This returns an array with a string for the underlying
            storage type for each channel (i.e. "uint8" or "real16").

        texture:tokens
            List of all the built-in tokens understood by teximport().

EXAMPLES

  > 
  > cvex
  >  test(string map="Mandril.rat")
  > {
  >     for (string token : {
  >                     "texture:xres",
  >                     "texture:yres",
  >                     "texture:channels",
  >                     "texture:resolution",
  >                     "texture:tokens",
  >                     "image:pixelaspect",
  >                     "space:world"
  >                 })
  >     {
  >         float fval;
  >         vector vval;
  >         matrix mval;
  > 
  >         printf("----------------- %s ---------------------\n", token);
  >         if (teximport(map, token, fval))
  >             printf("'%s' = %g\n", token, fval);
  >         else if (teximport(map, token, vval))
  >             printf("'%s' = %g\n", token, vval);
  >         else if (teximport(map, token, mval))
  >             printf("'%s' = %g\n", token, mval);
  >     }
  > }

RELATED

  * dsmpixel

}

{
texprintf

Similar to sprintf, but does expansion of UDIM or UVTILE texture
filename expansion.

USAGE
  string texprintf(float u, float v; string format; ...)

Formats a string like sprintf, but scans for special conversion
characters to perform either UDIM or UVTILE style filename expansion.

This can be significantly more efficient than calling sprintf()
directly.

The special conversion sequences are:


%(UDIM)d
    The UDIM coordinate, as computed by 1000 + int(u)+1 + int(v)*10

%(U)d
    The UVTILE style u-coordinate (int(u)+1)

%(V)d
    The UVTILE style v-coordinate (int(v)+1)

%(UVTILE)d
    Expands to both u and v coordinates in the form u%d_v%d.

The d conversion specifier for texture identification can be modified
with field modifiers. For example %(U)02d or %(V)04d.

EXAMPLES

  > !vex
  > // Returns "map_1044.rat
  > texprintf(3.1, 4.15, "map_%(UDIM)d.rat");
  > 
  > // Returns "map_04_05.rat"
  > texprintf(3.1, 4.15, "map_%(U)02d_%(V)02d.rat");
  > 
  > // Returns "map_u4_v12.rat"
  > texprintf(3.14, 11.5, "map_u%(U)d_v%(V)d.rat");
  > 
  > // Returns "/path/basename_04_05.rat"
  > texprintf(3.1, 4.1, "%s/%s_%(U)02d_%(V)02d.rat", "/path", "basename");
  > 
  > // Returns "/path/basename_u04_v05.rat"
  > texprintf(3.1, 4.1, "%s/%s_%(UVTILE)02d.rat", "/path", "basename")
  > string map = texprintf(u, v, "%s/%s_%(UDIM)d.rat", texture_path, texture_base);
  > Cf = texture(map, u, v);

RELATED

  * sprintf

  * expand_udim

  * texture

}

{
texture

Computes a filtered sample of the texture map specified.

USAGES
  vector|vector4 texture(string map, ...)
  Samples the texture at the global S and T coordinates from the shading
  context. These signatures are only available in shading contexts.

  vector|vector4 texture(string map, float ss, float tt, ...)
  Samples the texture at the given S and T coordinates, using a filter
  width based on the derivatives of S and T at that point. If you use
  this function outside a shading context, the filter width will be 0.

  vector|vector4 texture(string map, float s0, float t0, float s1, float
  t1, float s2, float t2, float s3, float t3, ...)
  Takes an explicit sampling quadrilateral with corners (s0, t0), (s1,
  t1), (s2, t2), and (s3, t3).


    A sampled color value from the texture.

    If you call the function with a vector4 return type, the function
    includes the texture alpha in the fourth component.

IMAGE FILTERING OPTIONS

    Examples of specifying filter parameters:

  > colormap(map, u, v, "smode", "decal", "tmode", "repeat", "border", {.1,1,1});
  > colormap(map, u, v, "mode", "clamp", "width", 1.3);
  > colormap(map, u, v, "filter", "gauss", "width", 1.3, "mode", "repeat");

    If the texture is a deep .rat file, you can use the "channel"
    keyword argument to specify a channel in the file:

  > string channelname = "N";
  > cf = colormap(map, u, v, "channel", channelname);

    wrap

        repeat or periodic
            The image map will repeat outside the range 0 to 1.
            Basically, the integer component of the texture coordinate
            is ignored. This is the default.

        clamp or edge or streak
            The texture coordinates will be clamped to the range 0 to 1.
            This causes evaluations outside the range to evaluate to the
            color at the closest edge of the image (the border pixels
            are streaked outside the range).

        black or decal or color
            Coordinates outside the range 0 to 1 will evaluate to the
            border color (rather than a color in the image). The border
            color is black (i.e. 0) by default.

    uwrap
        (AKA swrap) Specifies the behavior when the u coordinate is
        outside the range 0 to 1. The values are the same as with wrap.

    vwrap
        (AKA twrap) Specifies the behavior when the v coordinate is
        outside the range 0 to 1. The values are the same as with wrap.

    border
        Specifies the border color when Black/Decal/Color wrapping is
        used.

    channel
        Specifies the color channel for textures that have multiple
        color planes (for example, diffuse_indirect or N). For ptex
        images, this specifies the index of the first channel (for
        example, 0 or 4).

    blur
        Blurs in x and y directions. Blur is measured as a percentage of
        the image size - so a blur of 0.1 will blur 10% of the image
        width. Use xblur and yblur if you need different blur amounts in
        either dimension.

    xblur
        (AKA ublur, sblur) Blur amount in the x image direction.

    yblur
        (AKA vblur, tblur) Blur amount in the y image direction.

    pixelblur
        Blurs the texture by a floating point number of pixels.

      > Cf = texture("map.rat", ss, tt, "pixelblur", 2.0);

    xpixelblur
        Blurs the texture by a floating point number of pixels in the X
        direction.

    ypixelblur
        Blurs the texture by a floating point number of pixels in the Y
        direction.

    filter
        Specifies the type of anti-aliasing filter to be used for
        evaluation. The following argument should be a string specifying
        one of:


        point
            Point sampling (i.e. no filtering)

        box
            Box filter (default)

        gauss
            Gaussian filter

        bartlett
            Bartlett/Triangular filter

        sinc
            Sinc sharpening filter

        hanning
            Hanning filter

        blackman
            Blackman filter

        catrom
            Catmull-Rom filter

    xfilter
        (AKA ufilter, sfilter) Specifies the filter for the X direction.
        The filters are the same as with filter.

    yfilter
        (AKA vfilter, tfilter) Specifies the filter for the Y direction.
        The filters are the same as with filter.

    width
        Filter width in both X and Y directions.

    xwidth
        (AKA uwidth, swidth) Filter width in the X direction.

    ywidth
        (AKA vwidth, twidth) Filter width in the Y direction.

    zwidth
        Filter width in the Z direction (for shadow maps). This is
        measured in world space units, unlike the other width arguments.

    extrapolate
        whether to use derivative extrapolation when computing anti-
        aliasing information. Extrapolation of derivatives is on by
        default. The argument should be either 0 or 1.

    lerp
        Specifies whether RAT files should interpolate between different
        MIP levels. By default, this is turned off. Turning
        interpolation on will help remove discontinuities when different
        MIP levels of a .rat file are accessed. However, the results of
        texture evaluation will be slightly softer (i.e. blurrier) and
        will take more time.

        There are three possible values for this argument.


        0
            Disable MIP map interpolation (fastest).

        1
            Approximate MIP map interpolation (fast).

        2
            High Quality MIP map interpolation (slower but highest
            quality).

    depthinterp
        Specifies the depth interpolation mode for deep shadow maps, to
        control the opacity value that will be returned when the map is
        sampled between two z-records.

        The argument must be a string.


        discrete
            (default) Return the first z-record before the sample point.

        linear
            Linearly interpolate the opacities of the z-records before
            and after the sample point.

        See deep shadow maps for more on the difference between the two
        modes.

    beerlambert
        When evaluating volumetric deep shadow maps, this will enable
        Beer-Lambert interpolation of opacity. Beer-Lambert is more a
        accurate but more expensive form of interpolation.

        The argument should be either 0 or 1.

    srccolorspace
        Specifies the color space in which the texture is stored. When
        texture values are accessed, they will be translated from this
        space into linear space for rendering if needed.


        auto
            (default) Determine the source color space based on the
            file. Currently, this will assume sRGB color space for 8-bit
            textures and linear for all other textures.

        linear
            Transform to linear space. This currently only affects 8-bit
            textures, since all others are assumed to be already in
            linear space. Use this option to force linear interpretation
            of textures used for bump or displacement maps.

    face
        When using a Ptex texture map, the face argument is used to
        specify the face for ptexture lookup.

    ptexorient
        When using Ptex textures, the implicit texture coordinates on
        polygons are used as the interpolants for texture lookup
        (combined with the face). However, different software may have
        different beliefs about winding and orientation. This keyword
        argument allows you to control the interpretation of orientation
        for Houdini polygons. The ptexorient expects an integer argument
        which is composed of a bit-field

        For example, a value of 6 (0x4|0x2) is equivalent to calling
        texture(map, 1-t, s) instead of texture(map, s, t).

        The default ptexorient is 0, which works correctly with the
        examples found at .

RELATED

  * colormap

}

{
texture3d

Returns the value of the 3d image at the position specified by P.

USAGE
  <type> texture3d(string filename, string channel, vector P, ...)

Returns the value of the 3d image at the position specified by P. If P
is outside of the bounding box of the image, the value returned will be
0. If the channel specified contains more values than the return type
(i.e. a vector channel when a float return type is desired), the first
component of the vector will be returned. If the channel specified
contains fewer values than the return type, the missing components will
be filled with the last valid channel.

Texture files will be searched for in the path specified by the
HOUDINI_TEXTURE_PATH environment variable.

You can pass additional arguments to control the evaluation (see
colormap):

"filter"

Specifies the filter for evaluation.

"width"

Specifies the filter width for evaluation.

RELATED

}

{
texture3dBox

This function queries the 3D texture map specified and returns the
bounding box information of the file.

USAGE
  void texture3dBox(string filename, string channel; vector &min, vector
  &max, ...)
  Writes the minimum and maximum coordinates of the 3D texture into the
  vector variables min and max.

RELATED

}

{
titlecase

Returns a string that is the titlecase version of the input string.

USAGE
  string titlecase(const string str)

Converts a normal sentence into titlecase. The rules in use are as
follows:

  * First and last world are always capitalized

  * Subtitles are capitalized

  * Capitalize all words other than: articles, prepositions, and
    conjunctions.

  * Hyphicated words that are capitalized should have their second part
    capitalized as well

  * Words that already contain capital letters are not modified

RELATED

  * tolower

  * toupper

}

{
toNDC

Transforms a position into normal device coordinates.

USAGES
  vector toNDC(vector point)
  vector toNDC(string camera_name, vector point)

Transforms a position to the normal device coordinates for a camera. The
point should be in the local space of the object (i.e. not in the space
of the camera).

toNDC() will return values above and below the 0-1 range outside the
view of the camera or light. To the right of the camera are values of 1+
and to the left are values of 0-. The same goes for the range above and
below the camera or light.

Transforms a position into normal device coordinates. This space is only
well-defined for the shading contexts.

RELATED

}

{
tolower

Converts all charactors in string to lower case

USAGE
  string tolower(const string str)

Returns the string with A-Z replaced with a-z.

RELATED

  * toupper

  * titlecase

}

{
toupper

Convers all charactors in string to upper case

USAGE
  string toupper(const string str)

Returns the string with a-z replaced with A-Z.

RELATED

  * tolower

  * titlecase

}

{
trace

Sends a ray from P along the normalized vector D.

USAGES
  void trace(vector &cv, vector &of, float &af, vector P, vector D,
  float shadow_bias, float max_contrib, ...)
  Sends a ray from <P> along the normalized vector <D>. The resulting
  color, opacity and alpha will be put in the export variables.

  <shadow_bias> is typically a small number which is used to prevent
  self-shading.

  <max_contrib> controls how much the result of the trace() call will
  contribute to the resulting pixel color. <max_contrib> has no effect
  on the results of the trace() call.

  int trace(vector pos, vector dir, float time, ...)
  Sends a single ray into the scene at time and retrieves information
  from the hit surface. A return value of 1 means the ray hit a surface.

Only the second signature accepts any of the following variadic
arguments. The first trace signature is more specific, and is legacy
from older versions of mantra.

LIGHT INCLUSION/EXCLUSION OPTIONS


    categories
        Specifies lights to include/exclude by their "category" tags.
        This is the preferred include/exclude lights rather than pattern
        matching light names with the "lightmask" keyword argument.

        For example:

      > diff = diffuse(nml, "lightmask", "hero | fill");

        See light categories for more information.

    lightmask
        When evaluating light and shadow shaders, objects have pre-
        defined light masks. This mask is usually specified in the
        geometry object and specifies a list of lights which are used to
        illuminate a surface or fog shader. It is possible to override
        the default light mask by specifying a "lightmask" argument.

        For example:

      > diff = diffuse(nml, "lightmask", "light*,^light2");

        ...will cause all lights whose names begin with "light" except
        for a light named "light2" to be considered for diffuse
        illumination.

        All Houdini scoping patterns, excepting group expansion, are
        supported:

      * * - wild-card match

      * ? - single character match

      * ^ - exclusion operator

      * [list] - character list match

AREA SAMPLING OPTIONS

    For area sampling, you must specify both the angle and sample
    variadic parameters. For example:

  > surface
  > blurry_mirror(float angle = 3; int samples = 16; float bias=0.05)
  > {
  >     Cf = reflectlight(bias, 1, "angle", angle, "samples", samples);
  > }

RAY OPTIONS


    TIP
        When you specify a texture, such as with the "environment"
        keyword, you can also use the image filtering keyword arguments.
        See environment for a listing of the image filter keyword
        arguments.


    scope
        A list of objects which can be hit by the rays. When specified,
        scope overrides the default scope that would have been selected
        for the given raystyle. The "scope:default" value will cause the
        scope argument to use the default scope for the current context
        - as if the argument were not specified.

        Allows an override of the scope for ray-intersections. A special
        scope argument, scope:self, will match the currently shading
        object.

    maxdist
        The maximum distance to search for objects. This can be used to
        limit the search of objects to nearby objects only. If the
        maxdist given is negative, then it will act as if there is no
        maximum distance.

        Allows an override of the maximum distance the ray can travel
        when testing for intersections. Some functions (such as
        fastshadow) have the maximum distance implicitly defined (by the
        length of the ray) and should probably avoid using this option.
        However, this option can be used effectively when computing
        reflections, global illumination, refraction etc.

    variancevar
        The name of a VEX export variable to use for variance anti-
        aliasing. The renderer compares the value with adjacent
        micropolygons in micropolygon rendering to decide what shading
        points need additional samples (using vm_variance property as a
        threshold). If more samples are required, the algorithm takes
        samples up to the specified maximum ray samples.

        This variable must be imported from the hit surface, so it must
        be in the list of imported names (see "importing information
        back from the ray" below). If the named variable is not
        imported, this option will be ignored.

        Variance antialiasing puts more samples in areas of the image
        with high variance, for example a sharp shadow edge. It is only
        used when vm_dorayvariance is enabled. Otherwise, only the min
        ray samples (or an explicitly supplied "samples" value) are used
        for antialiasing of the gather loop.

        Overrides the global variance control (mantra's -v option) which
        is used to determine anti-aliasing quality of ray tracing. For
        more information please refer to the documentation on mantra.

    angle
        The distribution angle (specified in radians). For gather(),
        rays will be distributed over this angle. For trace(), the angle
        is used to indicate the rate at which the filter width should
        increase with increasing intersection distance. Larger angles
        will cause farther hit surfaces to use larger derivatives,
        leading to improved texturing and displacement performance.

        To be effective, the samples parameter should also be specified.

    samples
        How many samples should be sent out to filter rays. For the
        irradiance and occlusion functions, specifying a samples
        parameter will override the default irradiance sampling.

    environment
        If the ray sent out to the scene misses everything, then it's
        possible to specify an environment map to evaluate.

        Using the ray's direction, the environment map specified will be
        evaluated and the resulting color will be returned. Most likely,
        it will be necessary to specify a transform space for the
        environment map evaluations.

        In the case of refractlight and trace the Of and Af variables
        will be set to 0 regardless of the background color specified.
        the resulting color.

        When an environment map is specified, the filtering options from
        texture() are also supported.

        See how to create an environment/reflection map.

    envobject
        If an environment map is used, the orientation of the
        environment map can be specified by transforming the ray into
        the space of another object, light or fog object in the scene.
        In Houdini, null objects can be used to specify the orientation.
        For example:

      > Cf = R*reflectlight(bias, max(R), "environment", "map.rat", "envobject", "null_object_name");

    envlight
        If an environment map is used, the orientation of the
        environment map can be specified by transforming the ray into
        the space of a light in the scene.

    envtint
        If an environment map is used, tint it with this color.

    background
        If a ray misses all objects, use this as the background color of
        the scene. In the case of refractlight and trace the Of and Af
        variables will be set to 0 regardless of the background color
        specified.

    distribution
        *Functions*: irradiance, occlusion

        Distribution for computing irradiance. The default is to use a
        cosine distribution (diffuse illumination). The possible values
        for the style are "nonweighted" for uniform sampling or "cosine"
        for cosine weighted sampling.

RAY SENDING OPTIONS


    width
        Specifies the filter width at the source of the ray. If angle is
        also specified, the filter width will become larger with
        increasing distance along the ray. By default, the filter width
        will be initialized from the current shading context, so it's
        normally not necessary to specify width directly. Negative
        values are ignored and will also cause the filter width to be
        initialized from the current shading context.

    distribution
        Determines the sampling distribution.

        For gather:

      * cosine -- Rays are distributed by the cosine (diffuse) function
        over the hemisphere.

      * uniform -- Rays are distributed uniformly over the hemisphere

        For sample_geometry:

      * area -- Samples are distributed by primitive area

      * parametric -- Samples are distributed by primitive ID,
        subdivision ID, and parametric surface coordinates (s, t).

      * solidangle -- Samples are distributed either by primitive area
        or by primitive area and solid angle subtended by the primitive.

    biasdir
        Overrides the bias direction when Bias Along Normal is enabled.
        When no biasdir is specified, the geometric normal Ng is used.
        When bias along normal is disabled, this option has no effect.

    SID
        Sample identifier to be passed to the called shader. If the
        calling shader has used SID to generate samples, it can be
        useful to pass the modified sample identifier to the called
        shader so that it can begin sampling at the specified offset.
        This value will be used to initialize the SID global in the hit
        surface.

    rayweight
        A hint to mantra to indicate the relative contribution of this
        ray to the final shading. This value is used by the ray clip
        threshold to limit sending of rays (similar to ray bounce).

    raystyle
        The type of rays you are sending. Mantra will use raystyle to
        determine both the default raytracing mask and bounce limit used
        for ray termination.

      * reflect -- Sending reflection rays. Mantra will use the
        reflection mask and reflection limit to terminate raytracing.

      * refract -- (default) Sending refraction rays. Mantra will use
        the refraction mask and refraction limit to terminate
        raytracing.

      * diffuse -- Sending diffuse rays. Mantra will use the diffuse
        limit for diffuse rays.

      * shadow -- Sending shadow rays. Mantra will not modify the
        raytracing level and will trace against shadowmask if inside a
        shadow or light shader.

      * primary -- Sending primary rays. This style can be used when a
        shader needs to change the direction of a primary ray without
        affecting the behavior of render settings that apply only to
        directly visible objects (such as matte and phantom). Mantra
        will still increment the raytracing level when sending primary
        rays.

      * nolimit -- Sending reflection rays with no limit on the number
        of raytracing bounces. Mantra will still increment the
        raytracing level when sending nolimit rays.

    categories
        A category expression used to select the objects which can be
        hit by rays. When specified, this overrides the existing
        reflectcategories and refractcategories parameters.

        For example, ^hidden will hit all objects which do not have the
        hidden category, and shiny|happy will hit all objects with
        either the shiny or happy category.

        The intersection of the scope and categories parameters are used
        to choose the objects which can be hit by rays.

    samplebase
        Typically, rays are distributed over the surface of the micro-
        polygon being shaded. This argument can be used to control the
        area. A value of 0 will force all rays to be sent from the same
        point. A value of 1 will cover the entire micro-polygon. (Gather
        only)

    transparentsamples
        The number of transparent samples to take for stochastic
        transparency with array outputs. Normally this value should be
        set to 1 unless you have requested exports in array variables -
        in which case the ray tracer will insert an entry in the array
        for each sample along the ray.


        NOTE
            transparentsamples must be 1 when importing F or
            ray:material using screendoor samplefilter.

SENDING INFORMATION TO THE SURFACE'S SHADER

    Using a keyword in the form "send:<name>", value, you can pass data
    from the originating surface to surfaces which are intersected by
    the ray. These arguments pass any values you want.

  > gather(P, dir, "send:N", normalize(N)) { ... }

    You can extract this passed data on the receiving end (that is, in
    the surface being hit by the ray) with the rayimport function. The
    first argument is the name (without the send: prefix) and the second
    argument is a variable in which to store the imported value.

    int rayimport(string name, <type> &value)

    rayimport returns 1 if the value was imported successfully.

IMPORTING INFORMATION FROM THE RAY

    You can specify names of global or exported variables to import from
    the hit shader in the form "<varname>", &var, typically including Cf
    (color vector of surface hit) and Of (opacity vector of surface
    hit).

  > vector  hitcf;
  > gather(P, dir, "bias", 0.01, "Cf", hitcf) {...}

    In addition, you can import the following special keywords to get
    information about the ray itself:


    ray:origin
        The origin of the ray (defined in else clause also).

    ray:direction
        The direction of the ray (defined in else clause also).

    ray:length
        The distance to the first surface which was hit by the ray.

    ray:area
        The total surface area of all the geometry in the raytracing
        scope.

    ray:solidangle
        The estimated solid angle subtended by all geometry in the
        raytracing scope. For large objects close to or enclosing the
        ray origin, this may be a very poor estimate while for
        individual primitives the estimate can be very good.

    You can retrieve information about more than one hit along the ray
    by requesting data in an array variable. When an imported value is
    of an array type, the trace function will automatically append an
    entry in the array for each individual hit point that was composited
    during ray tracing. For the opacity sample filter (see below), an
    entry will be created in the array for each semi-transparent sample
    encountered until full opacity is reached. When using array outputs,
    it may also be useful to use the all sample filter, which will cause
    all hits along the ray to be inserted regardless of whether the
    opacity limit was exceeded.

  > // Find the position and normal for all hit points along the ray,
  > // regardless of visibility.
  > vector a_pos[];
  > vector a_nml[];
  > trace(P, dir, Time,
  >         "samplefilter", "all",
  >             "P", a_pos,
  >             "N", a_nml);

SAMPLE FILTERING OPTIONS

    By default, Houdini composites the global variables using opacity
    blending. In some cases, it's more useful to get the value from the
    closest surface (regardless of whether it's transparent). You can
    use the special samplefilter keyword with a string value of either
    closest or opacity to control whether the value of a global is from
    the closest surface or opacity blended.


    samplefilter
        When the samplefilter keyword is encountered in the argument
        list, _all following_ import variables will use the specified
        filtering mode. You can specify multiple samplefilter arguments
        in a single gather statement to filter different variables in
        different ways.

        The current types of allowed for samplefilter are


        minimum
            Take the minimum value of all the samples. Note that with
            tuple values, the minimum value of each component will be
            used.

        maximum
            Take the maximum value of all the samples. Note that with
            tuple values, the maximum value of each component will be
            used.

        opacity
            Composite samples using the over operation.

        closest
            This is the default behavior, returning only the closest
            surface.

        screendoor
            Use stochastic compositing of the samples.

        sum
            Return the sum of the values for all samples.

        sum_square
            Return the sum of the squares of the values of all samples.

        sum_reciprocal
            Return the sum of the reciprocals of each sample.


    NOTE
        When using sample_geometry, the default samplefilter is set to
        closest by default, since opacity blending only works when
        compositing data along a ray.

  > gather(P, dir,
  >         "samplefilter", "opacity",
  >             "Cf", hitCf,
  >             "Of", hitOf,
  >         "samplefilter", "closest",
  >             "P", hitP,
  >             "N", hitN)
  > {
  >     trace(pos, dir, time,
  >             // Composite the bsdf of the hit surfaces using stochastic transparency
  >             "samplefilter", "screendoor",
  >             "F", hitF,
  >             // But find the closest sample's position
  >             "samplefilter", "closest",
  >             "P", hitP);
  > }

PIPELINE OPTIONS


    pipeline
        As you specify variables, you can intersperse pipeline keyword
        options to control where in the pipeline to fill out read/write
        variables. The value can be one of surface, atmosphere, or
        displacement. You can specify the pipeline option multiple
        times. Each use of the option affects any variables specified
        after it (up to the next usage of pipeline if any).

      > gather(p, d, "pipeline", "surface", "Cf", surfCf,
      >              "pipeline", "atmosphere" "Cf", fogCf, "P", hitP)

RELATED

  * rayhittest

  * Ray Trace

  * reflectlight

  * gather

  * trace

  * irradiance

  * pathtrace

}

{
translate

Translates a matrix by a vector.

USAGES
  void translate(matrix &m, vector amount)
  void translate(matrix &m, vector4 amount)

RELATED

  * rotate

  * scale

}

{
translucent

Returns a Lambertian translucence BSDF.

USAGE
  bsdf translucent(vector nml, vector ng, ...)
  Returns a diffuse BSDF for the transmission direction. This can be
  used as a cheap alternative to subsurface scattering for thin
  surfaces, to allow illumination to pass from one side of the object to
  the other while also broadly diffusing the illumination like diffuse.

RELATED

  * diffuse

  * Writing a PBR shader

}

{
transpose

Transposes the given matrix.

USAGES
  void transpose(<matrix> &m)
  <matrix> transpose(<matrix> m)
  Transposes the given matrix.

RELATED

}

{
trunc

Removes the fractional part of a floating point number.

USAGES
  float trunc(float x)
  If the argument is negative, this returns ceil(x), otherwise it
  returns floor(x).

  vector2 trunc(vector2 x)
  vector trunc(vector x)
  vector4 trunc(vector4 x)
  Returns a new vector with the trunc() of each component.

RELATED

}

{
tw_nspace

Transforms a normal vector from Texture to World space.

USAGE
  vector tw_nspace(vector v)

Transforms a normal vector from _Texture_ to _World_ space.

RELATED

}

{
tw_space

Transforms a position value from Texture to World space.

USAGES
  matrix tw_space()
  vector tw_space(vector v)
  vector4 tw_space(vector4 v)

Transforms a position value from _Texture_ to _World_ space.

RELATED

}

{
tw_vspace

Transforms a direction vector from Texture to World space.

USAGE
  vector tw_vspace(vector v)

Transforms a direction vector from _Texture_ to _World_ space.

RELATED

}

{
uniqueval

Returns one of the set of unique values across all values for an int or
string attribute.

USAGE
  int|string uniqueval( <geometry>, string attribclass, string
  attribute_name, int which)

If any points/primitives/vertices in the geometry have the same value
for the given attribute, the set of _unique_ values will be smaller than
the total number of points/primitives/vertices. This function lets you
iterate through the set of unique values.

This function only works with string and integer attributes.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

texttype
    One of "detail" (or "global"), "point", "prim", or "vertex".

    You can also use "primgroup", "pointgroup" or "vertexgroup" to read
    from groups.

texttype
    The name of the attribute (or intrinsic) to read.

which
    Which one of the unique values to return. Use nuniqueval to get how
    many unique values the attribute has.

EXAMPLES


    Iterate through the unique values of the @foo point string attribute
      > int count = nuniqueval(0, "point", "foo");
      > for (int i = 0; i < count; i++) {
      >     string val = uniqueval(0, "point", "foo", i);
      >     // ...do something with the value...
      > }

RELATED

  * nuniqueval

}

{
unpack_intfromsafefloat

Reverses the packing of pack_inttosafefloat to get back the original
integer.

USAGE
  int unpack_intfromsafefloat(float f)

See pack_inttosafefloat

RELATED

  * pack_inttosafefloat

  * xyzdist

  * intersect

}

{
unserialize

Turns a flat array of floats into an array of vectors or matrices.

USAGES
  <vector>[] unserialize(float values[])
  <matrix>[] unserialize(float values[])
  The inverse operation to serialize. This operation takes an array of
  float values and creates a new array of vectors or floats by taking
  each float and assigning it to the next component of the vector or
  matrix in the output array. For example:

EXAMPLES

  > vector v[]
  > float  f[] = { 1, 2, 3,  7, 8, 9 };
  > 
  > v = vector(unserialize(f));
  > // Now v has a length of 2 and contains { {1,2,3}, {7,8,9} }

RELATED

  * serialize

}

{
upush

Adds a uniform item to an array.

USAGE
  void upush(<type> &array[]; <type> value)
  Pushes a uniform value onto an array for all SIMD processors
  (regardless of the processor enabled state).

  This is a very specialized function, primarily used to manage light
  exports in PBR lighting.

RELATED

  * push

}

{
uvdist

Finds the distance of a uv coordinate to a geometry in uv space.

USAGES
  float uvdist(<geometry>, string uvname, vector uv, int &prim, vector
  &primuv)
  float uvdist(<geometry>, string uvname, vector uv, int &prim, vector
  &primuv, float maxdist)

Returns the distance to the closest uv coordinate on the geometry in uv
space. This will find positions on the surfaces of the geometry, not
just point positions.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

uvname
    The name of a point or vertex attribute on the <geometry> to use as
    the uv space. The geometry will be unwrapped inplace based on this
    attribute. The attribute can be a 2D UV, 3D UVW, but also any vector
    attribute.

uv
    The position in uv space to find the closest position on the
    geometry to.

prim
    The number of the closest primitive. -1 if no primitive found.

primuv
    The primitive uv coordinates the closest primitive. The primuv
    function can be used to evaluate attributes at that location.

maxdist
    The maximum distance to search in uv space. The operation can be
    sped up if it is allowed to quit early.

RELATED

}

{
uvintersect

This function computes the intersection of the specified ray with the
geometry in uv space.

USAGE
  int uvintersect(<geometry>, string uvname, vector orig, vector dir,
  vector &pos, vector &primuv)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

This function computes the intersection of the specified ray with the
geometry in uv space. The primitive number is returned, or -1 if there
is an error or no intersection found.

The position in uvspace of the intersection location is stored in <p>.
The corresponding parametric location of the intersection is stored in
<primuv>. In the case of multiple intersections, the intersection
closest to the ray origin is used.

This function does not expect a normalized direction vector. Instead, it
uses the length of the vector as the maximum distance. The integer
result is the primitive hit.


NOTE
    It can be hard to visualize a 3D intersection of a ray in a 3D UV
    space. One trick that can be used is to unwrap the geometry in SOP
    to get better visualization of the space. This can be done by using
    a Split Vertex SOP followed by a Attribute Copy SOP. This will
    disconnect the faces at uv boundaries and stamp the uvw values on
    top of the P attribute.

NOTE
    When intersections are performed against metaball geometry, it is
    impossible to determine the primitive number of the metaball which
    was hit. In this case, the function returns the number of primitives
    in the intersection geometry.

RELATED

}

{
uvsample

Interpolates the value of an attribute at certain UV coordinates using a
UV attribute.

This function specifies the position using UVs from a UV attribute. To
use _intrinsic primitive UVs_, use primuv instead.

USAGES
  <type> uvsample(<geometry>, string attr_name, string uv_attr_name,
  vector uvw)
  <type>[] uvsample(<geometry>, string attr_name, string uv_attr_name,
  vector uvw)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

attr_name
    The name of a point or vertex attribute to sample. For primitive
    attributes, the value is taken from the primitive under the given
    UVs. *For point and vertex attributes, the value will at the given
    UV coordinates will be interpolated from the surrounding
    points/vertices*. The values are taken from the "lowest" level at
    which an attribute with this name exists.

uv_attr_name
    The name of a point or vertex attribute containing UVs. The default
    UVs created by Houdini are in an attribute named uv. The named
    attribute can be 2D (UV) or 3D (UVW) in any vector type.

uvw
    The position in UV(W) space at which to sample the attribute.

RELATED

  * primuv

  * prim_attribute

}

{
uvunwrap

Computes the position and normal at given (u, v) coordinates.

USAGES
  int uvunwrap( string object_path; float u; float v; float time; vector
  &P; vector &I )
  int uvunwrap( string object_path; float u; float v; float time; vector
  &P; vector &I; vector &mikkelsenUtan; vector &mikkelsenVtan )


object_path
    The object being unwrapped.

u, v
    The UV coordinates specifying where on the surface to get the
    position and normal.

time
    The time along the timeline at which to measure the geometry, in
    seconds.

&P
    If it succeeds, the function overwrites this variable with the world
    space position of the given point.

&I
    If it succeeds, the function overwrites this variable with the
    normal at the given point.

&mikkelsenUtan, &mikkelsenVtan
    The function overwrites these variables with the Mikkelsen tangent
    vectors.

    1 if the UV coordinates specified a valid point on the surface, or 0
    otherwise.

RELATED

}

{
variance

Computes the mean value and variance for a value.

USAGE
  float variance(float variable, float &mean, int &sample_size)

This function will compute the mean and variance from nearby samples.
Similar to the way that VEX is able to compute derivatives, this
function is able to inspect the variable for a nearby area and compute
the mean and variance of the variable.

The function returns the variance (sigma2). The mean value will also be
returned along with the sample_size indicating how many nearby samples
were considered.

RELATED

}

{
velocityname

Returns the default name of the velocity plane (as it appears in the
compositor preferences).

USAGE
  string velocityname()

Returns the default name of the velocity plane (as it appears in the
compositor preferences). Using this instead of hardcoding the default
makes your code more portable. Default is "V".

RELATED

}

{
vertex

Reads a vertex attribute value from a geometry.

USAGES
  <type> vertex(<geometry>, string attribute_name, int
  linear_vertex_index)
  <type>[] vertex(<geometry>, string attribute_name, int
  linear_vertex_index)
  Specifies the vertex using the linear index into the list of all
  vertices.

  <type> vertex(<geometry>, string attribute_name, int prim_num, int
  vertex_num)
  <type>[] vertex(<geometry>, string attribute_name, int prim_num, int
  vertex_num)
  Specifies the vertex as a primitive number and then an offset into the
  list of vertices on that primitive.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

texttype
    The name of the attribute (or intrinsic) to read.

    The value of the given attribute on the given vertex, or 0 if the
    attribute or vertex do not exist.

RELATED

}

{
vertexattrib

Reads a vertex attribute value from a geometry.

USAGES
  <type> vertexattrib(<geometry>, string attribute_name, int
  linear_vertex_index, int &success)
  <type>[] vertexattrib(<geometry>, string attribute_name, int
  linear_vertex_index, int &success)
  Unlike vertex, this function does not have a version that takes a
  primitive number and primitive vertex number. If you have a primitive
  number and primitive vertex number, you can convert them into a linear
  index using vertexindex.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

texttype
    The name of the attribute (or intrinsic) to read.

linear_vertex_index
    A linear index into the list of all vertices. If you have a
    primitive number and primitive vertex number, you can convert them
    into a linear index using vertexindex.

success
    The function overwrites this variable with 1 if the attribute exists
    and was read successfully, or 0 otherwise.

    The value of the given attribute on the given point number.

RELATED

}

{
vertexattribsize

Returns the size of a geometry vertex attribute.

USAGE
  int vertexattribsize(<geometry>, string attribute_name)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

See attribsize for more information.

Returns 0 if the attribute cannot be found.

RELATED

}

{
vertexattribtype

Returns the type of a geometry vertex attribute.

USAGE
  int vertexattribtype(<geometry>, string attribute_name)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

See attribtype for more information.

RELATED

}

{
vertexattribtypeinfo

Returns the type info of a geometry attribute.

USAGE
  string vertexattribtypeinfo(<geometry>, string attribute_name)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

See attribtypeinfo for more information.

RELATED

}

{
vertexhedge

Returns the half-edge which has a vertex as source.

USAGE
  int vertexhedge(<geometry>, int vertex)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

vertex
    The linear vertex number in the geometry. 0 is the first vertex.

    The number for the half-edge that has vertex as source and the
    vertex following vertex in the primitive of vertex as destination.
    Returns -1 if failed to find the corresponding vertex.

EXAMPLES

  > 
  > int vtxhedge;
  > 
  > // Get the hedge out of vertex vertex number 2.
  > vtxhedge = vertexhedge("defgeo.bgeo", 2);

RELATED

}

{
vertexindex

Converts a primitive/vertex pair into a linear vertex.

USAGE
  int vertexindex(<geometry>, int primnum, int vertex)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

primnum
    The primitive number to get a vertex from.

vertex
    The vertex number inside of a primitive. 0 is the first vertex.

    The linear vertex index corresponding to the given primitive vertex.
    Returns -1 if the function could not find the equivalent linear
    vertex index.

EXAMPLES

  > 
  > int linearvtx;
  > 
  > // Get the linear vertex value of vertex 2 of primitive 3.
  > linearvtx = vertexindex("defgeo.bgeo", 3, 2);

RELATED

}

{
vertexnext

Returns the linear vertex number of the next vertex sharing a point with
a given vertex.

USAGE
  int vertexnext(<geometry>, int linearvertex)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

texttype
    The linear index of a vertex. If you have a point number and point
    vertex number, you can use vertexindex to convert them to a linear
    index.

    The linear index of the next vertex sharing the same point with the
    given vertex, or -1 if the vertex has no later shared vertices. (To
    go in the other direction, use vertexprev.)

EXAMPLES

  > 
  > int        vtx;
  > 
  > // Get the next vertex of vertex 3
  > vtx = vertexnext("defgeo.bgeo", 3);

RELATED

  * pointvertex

  * vertexprev

  * vertexindex

}

{
vertexpoint

Returns the point number of linear vertex in a geometry.

USAGE
  int vertexpoint(<geometry>, int linearvertex)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

linearvertex
    The linear vertex number. The vertexindex function can be used to
    compute a linear vertex from a primitive number and vertex number
    pair.

    The point number associated with the vertex, or -1 if the vertex has
    no point.

EXAMPLES

  > 
  > int        pt;
  > 
  > // Get the point of vertex 3
  > pt = vertexpoint("defgeo.bgeo", 3);

RELATED

  * pointvertex

}

{
vertexprev

Returns the linear vertex number of the previous vertex sharing a point
with a given vertex.

USAGE
  int vertexprev(<geometry>, int linearvertex)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

texttype
    The linear index of a vertex. If you have a point number and point
    vertex number, you can use vertexindex to convert them to a linear
    index.

    The linear index of the previous vertex sharing the same point with
    the given vertex, or -1 if the vertex has no earlier shared
    vertices. (To go in the other direction, use vertexnext.)

EXAMPLES

  > int        vtx;
  > 
  > // Get the previous vertex of vertex 3
  > vtx = vertexprev("defgeo.bgeo", 3);

RELATED

  * pointvertex

  * vertexnext

  * vertexindex

}

{
vertexprim

Returns the number of the primitive containing a given vertex.

USAGE
  int vertexprim(<geometry>, int linearvertex)


NOTE
    To convert the linear index into a primitive number and primitive
    vertex number, use vertexprim and vertexprimindex.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

texttype
    The linear index of a vertex. If you have a point number and point
    vertex number, you can use vertexindex to convert them to a linear
    index.

    The primitive number of the primitive containing the vertex, or -1
    if the vertex has no primitive.

EXAMPLES

  > 
  > int        pt;
  > 
  > // Get the primitive of vertex 3
  > pt = vertexprim("defgeo.bgeo", 3);

RELATED

  * vertexpoint

  * vertexindex

}

{
vertexprimindex

Converts a linear vertex index into a primitive vertex number.

USAGE
  int vertexprimindex(<geometry>, int linearindex)


NOTE
    To convert the linear index into a primitive number and primitive
    vertex number, use vertexprim and vertexprimindex.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

linearindex
    The linear index of a vertex

    The vertex's number within the primitive that contains it, or -1 if
    the vertex has no primitive.

    To get the primitive number of the containing primitive, use
    vertexprim.


NOTE
    Due to the nature of the geometry structure, the first time this is
    run on a geometry it has to run over all primitives to find the look
    up table. This will be amortized out if most vertices are invoking
    this function.

EXAMPLES

  > 
  > int prim, vtx;
  > 
  > // Find the primitive and vertex offset of the linear vertex 6.
  > prim = vertexprim("defgeo.bgeo", 6);
  > vtx = vertexprimindex("defgeo.bgeo", 6);

RELATED

  * vertexprim

  * vertexindex

}

{
vnoise

Generates Voronoi (cellular) noise.

USAGES
  void vnoise( float position; float jitter; int &seed; float &f1; float
  &f2; float &pos1; float &pos2 )
  Generates 1D noise.

  void vnoise( float position; float jitter; int &seed; float &f1; float
  &f2; float &pos1; float &pos2; int period)
  Generates periodic 1D noise.

  void vnoise( float posx; float posy; float jittx; float jitty; int
  &seed; float &f1; float &f2; float &pos1x; float &pos1y; float &pos2x;
  float &pos2y )
  Generates 2D noise. This is similar to the other forms but uses pairs
  of floats instead of a vector.

  void vnoise( float posx; float posy; float jittx; float jitty; int
  &seed; float &f1; float &f2; float &pos1x; float &pos1y; float &pos2x;
  float &pos2; int periodx; int periody )
  Generates periodic 2D noise.

  void vnoise( vector position; vector jitter; int &seed; float &f1;
  float &f2; vector &pos1; vector &pos2 )
  Generates 3D noise.

  void vnoise( vector position; vector jitter; int &seed; float &f1;
  float &f2; vector &pos1; vector &pos2; int periodx; int periody; int
  periodz )
  void vnoise( vector position; vector jitter; int &seed; float &f1;
  float &f2; vector &pos1; vector &pos2; vector period )
  Generates periodic 3D noise.

  void vnoise( vector4 position; vector4 jitter; int &seed; float &f1;
  float &f2; vector4 &pos1; vector4 &pos2 )
  Generates 4D noise.

  void vnoise( vector4 position; vector4 jitter; int &seed; float &f1;
  float &f2; vector4 &pos1; vector4 &pos2; int periodx; int periody; int
  periodz; int periodw )
  void vnoise( vector4 position; vector4 jitter; int &seed; float &f1;
  float &f2; vector4 &pos1; vector4 &pos2; vector4 period )
  Generates periodic 4D noise.


texttype
    The position at which to sample the noise.

jitter
    The amount of randomness to add to the noise in each axis.

texttype
    Outputs an integer value associated with the nearest seed point.
    This seed is pretty much guaranteed to be unique for every point
    (meaning that it's unlikely that two points close by have the same
    seed associated with them).

pos1, pos2
    These variables are overwritten with the positions of the two
    nearest seed points, in order of closeness.

f1, f2
    These variables are overwritten with the distances to the nearest
    seed points, in order of closeness.

    You can combine these distances to generate noise patterns. The
    noise generated tends to be very "cellular" in nature. In fact, one
    of the nice things is that you can determine "cell" boundaries by
    using the expression: if (f2 - f1) which will be true if the point
    in space is crossing the boundary between two cells.

period, periodx, periody, periodz, periodw
    If you include the period argument(s), the function generates
    repeating (periodic) noise.

Voronoi noise gives almost identical results to the Worley noise
function (wnoise). However, this function has controls over jittering
(i.e. how randomly the points are scattered through space) and also
return the actual locations of the two nearest seed points, whereas
wnoise only returns the distances to the two nearest seed points.

Though this function is slightly more expensive than wnoise, since it
returns the actual point positions, you can overcome some of the
artifacts of Worley noise. For example, to get even boundaries along the
cell boundaries:

> if (f2 - f1 < tolerance * (distance(p1, p2) / (f1 + f2)) ...

This will "normalize" the boundary width based on the distance between
the two random points in space.

There are also periodic forms of vnoise().

EXAMPLES

  > // 1D noise
  > float    fp0, fp1, p1x, p1y, p2x, p2y;
  > vector    vp0, vp1;
  > vnoise(s*10, 0.8, seed, f1, f2, fp0, fp1);
  > vnoise(s*10, t*10, 0.8, 0.8, seed, f1, f2, p1x, p1y, p2x, p2y);
  > vnoise(P*10, {.8, .8, .8}, seed, f1, f2, vp0, vp1);

RELATED

  * Noise and randomness

  * anoise

  * curlnoise

  * flownoise

  * noise

  * onoise

  * pnoise

  * snoise

  * vnoise

  * wnoise

  * xnoise

}

{
volume

Returns the volume of the microvoxel containing a variable such as P.

USAGE
  float volume(vector pos, ...)


NOTE
    This function relies on the fact that VEX "knows" that pos has
    derivatives (dPdu, dPdv, and dPdz). Passing a literal vector instead
    of a special variables such as P will return 0 since VEX will not be
    able to access the derivatives.

DERIVATIVES OPTIONS

    Functions which compute derivatives take additional arguments to
    allow tuning of the derivative computation.


    extrapolate
        Whether derivatives are "smooth" across patch boundaries. In
        most cases this is true and if extrapolation is turned on,
        derivative computation should be exact for C2 surfaces. However,
        when the VEX variables are changing with a high frequency (for
        example, a high frequency displacement map causing high
        frequency changes to the P variable), extrapolation of
        derivative computation may cause exaggeration of discontinuities
        between patch boundaries.

    smooth
        Adjust the magnitude of the differentials non-uniformly over
        patches. This will usually reduce patch discontinuities in
        displacement/textured shaders. However, in some odd cases you
        may want to turn this feature off.

  > N = computenormal(P, "extrapolate", 1, "smooth", 0);

EXAMPLES

    Return the volume of the current micro-voxel in camera space:

  > volume(P)

    Returns 0, since the argument is not a variable VEX knows the
    derivatives for:

  > volume({0.1, 2.3, 4.5})

RELATED

  * area

  * gradient

  * Du

  * Dv

  * Dw

}

{
volumegradient

Calculates the volume primitive's gradient.

USAGES
  vector volumegradient(<geometry>, int primnum, vector pos)
  vector volumegradient(<geometry>, string volumename, vector pos)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

    The volume primitive's gradient. The gradient is a vector pointing
    in the direction of increasing value.

    Returns 0 if primnum is out of range, the geometry is invalid, or
    the given primitive is not a volume primitive.

RELATED

}

{
volumeindex

Gets the value of a specific voxel.

USAGES
  float volumeindex(<geometry>, int primnum, vector voxel)
  float volumeindex(<geometry>, string volumename, vector voxel)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.


    The value of a specific voxel in a volume primitive.

    Returns 0 if primnum is out of range, the geometry is invalid, or
    the given primitive is not a volume primitive.

RELATED

}

{
volumeindexorigin

Gets the index of the bottom left of a volume primitive.

USAGES
  vector volumeindexorigin(<geometry>, int primnum)
  vector volumeindexorigin(<geometry>, string volumename)


    The index of the bottom left of a volume primitive. For Volume
    primitives, this is always zero. However, for VDB primitives, this
    represents the bottom left of their active bounding box of voxels.

    Returns 0 if primnum is out of range, the geometry is invalid, or
    the given primitive is not a volume primitive.

RELATED

}

{
volumeindextopos

Converts a volume voxel index into a position.

USAGES
  vector volumeindextopos(<geometry>, int primnum, vector voxel)
  vector volumeindextopos(<geometry>, string volumename, vector voxel)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

    The position of the center of a voxel.

    Returns 0 if primnum is out of range, the geometry is invalid, or
    the given primitive is not a volume primitive.

RELATED

}

{
volumeindexv

Gets the vector value of a specific voxel.

USAGES
  vector volumeindexv(<geometry>, int primnum, vector voxel)
  vector volumeindexv(<geometry>, string volumename, vector voxel)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

    The vector value of a specific voxel in a volume primitive.

    Returns 0 if primnum or inputnum is out of range, the geometry is
    invalid, or the given primitive is not a vector volume primitive.

RELATED

}

{
volumepostoindex

Converts a position into a volume voxel index.

USAGES
  vector volumepostoindex(<geometry>, int primnum, vector position)
  vector volumepostoindex(<geometry>, string volumename, vector
  position)


    The index of a voxel at the given position.

    Returns 0 if primnum or inputnum is out of range, the geometry is
    invalid, or the given primitive is not a vector volume primitive.

RELATED

}

{
volumeres

Gets the resolution of a volume primitive.

USAGES
  vector volumeres(<geometry>, int primnum)
  vector volumeres(<geometry>, string volumename)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

    The resolution of the volume primitive.

    For VDBs, the valid range of indices is not 0..res-1, but
    volumeindexorigin..volumeindexorigin+res-1

    Returns 0 if primnum or inputnum is out of range, the geometry is
    invalid, or the given primitive is not a vector volume primitive.

RELATED

}

{
volumesample

Samples the volume primitive's value.

USAGES
  float volumesample(<geometry>, int primnum, vector pos)
  float volumesample(<geometry>, string volumename, vector pos)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

    The volume primitive's sampled value at the given position.

    Returns 0 if primnum or inputnum is out of range, the geometry is
    invalid, or the given primitive is not a vector volume primitive.

RELATED

}

{
volumesamplev

Samples the volume primitive's vector value.

USAGES
  vector volumesamplev(<geometry>, int primnum, vector pos)
  vector volumesamplev(<geometry>, string volumename, vector pos)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

    The volume primitive's sampled value at the given position.

    Returns 0 if primnum or inputnum is out of range, the geometry is
    invalid, or the given primitive is not a vector volume primitive.

RELATED

}

{
volumevoxeldiameter

Computes the approximate diameter of a voxel.

USAGES
  float volumevoxeldiameter(<geometry>, int primnum)
  float volumevoxeldiameter(<geometry>, string primname)


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

    The diameter of a voxel in the given primitive. To find the length
    of a side of a voxel, divide by sqrt(3).

    Returns 0 if primnum or inputnum is out of range, the geometry is
    invalid, or the given primitive is not a vector volume primitive.

RELATED

}

{
vtransform

Transforms a directional vector.

USAGES
  vector vtransform(vector v, matrix transform)
  vector vtransform(string tospace, vector v)
  vector vtransform(string fromspace, string tospace, vector v)

Transforms a vector representing a direction. See ptransform for more
information.

RELATED

  * ntransform

  * ptransform

  * getspace

}

{
warning

Reports a custom runtime VEX warning.

USAGE
  void warning(string format, ...)

Reports a custom runtime VEX warning. This uses the same format string
syntax as printf.

If something is so problematic that there is no acceptable fallback
behavior, it may be worth reporting an error, instead of a warning.


NOTE
    It's quite easy to accidentally report thousands of different
    warnings.

EXAMPLES

  > if (primintrinsic(0,"typeid",@primnum) != 1) {
  >     warning("Primitives that aren't polygons are being ignored.");
  >     return;
  > }
  > if (primintrinsic(0,"closed",@primnum) == 0 || @numvtx < 3) {
  >     warning("Open or degenerate polygons are being ignored.");
  >     return;
  > }
  > float minimumValue = chf("min");
  > float maximumValue = chf("max");
  > if (minimumValue > maximumValue) {
  >     warning("Minimum (%f) can't be greater than maximum (%f); replacing minimum with maximum.", minimumValue, maximumValue);
  >     minimumValue = maximumValue;
  > }

RELATED

  * error

  * printf

}

{
wireblinn

USAGE
  bsdf wireblinn(vector tangent, float exponent, ...)


Blinn function defined around a tangent vector. You can use this to
produce the average specular illumination for thin wire-like primitives
such as hair.

  * tangent -- tangent vector along the hair.

  * exponent -- blinn exponent.

RELATED

  * wirediffuse

  * Writing a PBR shader

}

{
wirediffuse

USAGE
  bsdf wirediffuse(vector tangent, ...)


Diffuse function defined around a tangent vector. This can be used to
produce the average diffuse illumination for thin wire-like primitives
such as hair.


tangent
    tangent vector along the hair.

RELATED

  * wireblinn

  * Writing a PBR shader

}

{
wnoise

Generates Worley (cellular) noise.

USAGES
  void wnoise( float position; int &seed; float &f1; float &f2 )
  void wnoise( float position; int &seed; float &f1; float &f2; float
  &f3; float &f4 )
  Generates 1D noise.

  void wnoise( float position; int &seed; float &f1; float &f2; int
  peiod)
  void wnoise( float position; int &seed; float &f1; float &f2; float
  &f4; float &f4; int period)
  Generates periodic 1D noise.

  void wnoise( float posx; float posy; int &seed; float &f1; float &f2 )
  void wnoise( float posx; float posy; int &seed; float &f1; float &f2;
  float &f3; float &f4 )
  Generates 2D noise. This is similar to the other forms but uses pairs
  of floats instead of a vector.

  void wnoise( float posx; float posy; int &seed; float &f1; float &f2;
  int periodx; int periody )
  void wnoise( float posx; float posy; int &seed; float &f1; float &f2;
  float &f3; float &f4; int periodx; int periody)
  Generates periodic 2D noise.

  void wnoise( vector2 position; int &seed; float &f1; float &f2 )
  void wnoise( vector2 position; int &seed; float &f1; float &f2; float
  &f3; float &f4 )
  Generates 2D noise.

  void wnoise( vector2 position; int &seed; float &f1; float &f2; int
  periodx; int periody )
  void wnoise( vector2 position; int &seed; float &f1; float &f2; float
  &f3; float &f4; int periodx; int periody)
  Generates periodic 2D noise.

  void wnoise( vector position; int &seed; float &f1; float &f2 )
  void wnoise( vector position; int &seed; float &f1; float &f2; float
  &f3; float &f4 )
  Generates 3D noise.

  void wnoise( vector position; int &seed; float &f1; float &f2; int
  periodx; int periody; int periodx )
  void wnoise( vector position; int &seed; float &f1; float &f2; float
  &f3; float &f4; int periodx; int periody; int periodz )
  Generates periodic 3D noise.

  void wnoise( vector4 position; int &seed; float &f1; float &f2 )
  void wnoise( vector4 position; int &seed; float &f1; float &f2; float
  &f3; float &f4 )
  Generates 4D noise.

  void wnoise( vector4 position; int &seed; float &f1; float &f2; int
  periodx; int periody; int periodz; int periodw )
  void wnoise( vector4 position; int &seed; float &f1; float &f2; float
  &f3; float &f4; int periodx; int periody; int periodz; int periodw )
  Generates periodic 4D noise.


position
    The position at which to sample the noise.

seed
    Outputs an integer value associated with the nearest seed point.
    This seed is pretty much guaranteed to be unique for every point
    (meaning that it's unlikely that two points close by have the same
    seed associated with them).

f1, f2, f3, f4
    These variables are overwritten with the distances to the nearest
    seed points, in order of closeness.

    You can combine these distances to generate noise patterns. The
    noise generated tends to be very "cellular" in nature. In fact, one
    of the nice things is that you can determine "cell" boundaries by
    using the expression: if (f2 - f1) which will be true if the point
    in space is crossing the boundary between two cells.

period, periodx, periody, periodz, periodw
    If you include the period argument(s), the function generates
    repeating (periodic) noise.

Worley noise scatters seed points randomly through space (according to a
nice Poisson distribution). The functions outputs the distances to the 2
(or 4) seed points nearest to the sample position.

RELATED

  * Noise and randomness

  * anoise

  * curlnoise

  * flownoise

  * noise

  * onoise

  * pnoise

  * snoise

  * vnoise

  * wnoise

  * xnoise

}

{
wo_nspace

Transforms a normal vector from World to Object space.

USAGE
  vector wo_nspace(vector v)

Transforms a normal vector from _World_ to _Object_ space.

RELATED

}

{
wo_space

Transforms a position value from World to Object space.

USAGES
  matrix wo_space()
  In shading contexts, this transforms the current position.

  vector wo_space(vector pos)
  vector4 wo_space(vector4 pos)

Transforms a position value from _World_ to _Object_ space.

RELATED

}

{
wo_vspace

Transforms a direction vector from World to Object space.

USAGE
  vector wo_vspace(vector v)

Transforms a direction vector from _World_ to _Object_ space.

RELATED

}

{
writepixel

Writes color information to a pixel in the output image

USAGE
  void writepixel(string channel, float ndc_x, float ndc_y, vector clr)

This is an experimental function which can be used by the generator
rendering engine to write pixel values into the image.

RELATED

}

{
wt_nspace

Transforms a normal vector from World to Texture space.

USAGE
  vector wt_nspace(vector v)

Transforms a normal vector from _World_ to _Texture_ space.

RELATED

}

{
wt_space

Transforms a position value from World to Texture space.

USAGES
  matrix wt_space()
  vector wt_space(vector v)
  vector4 wt_space(vector4 v)

Transforms a position value from _World_ to _Texture_ space.

RELATED

}

{
wt_vspace

Transforms a direction vector from World to Texture space.

USAGE
  vector wt_vspace(vector v)

Transforms a direction vector from _World_ to _Texture_ space.

RELATED

}

{
xnoise

Simplex noise is very close to Perlin noise, except with the samples on
a simplex mesh rather than a grid. This results in less grid artifacts.
It also uses a higher order bspline to provide better derivatives.

USAGES
  float xnoise(float x)
  vector xnoise(float x)
  float xnoise(vector xyz)
  vector xnoise(vector xyz)
  float xnoise(vector4 xyzt)
  vector xnoise(vector4 xyzt)
  float xnoise(float x, float y)
  vector xnoise(float x, float y)

Simplex noise is very close to Perlin noise, except with the samples on
a simplex mesh rather than a grid. This results in less grid artifacts.
It also uses a higher order bspline to provide better derivatives.

The various functions return the noise value at a 4D (vector4 argument),
3D (vector argument), 2D (two float arguments) or 1D (float argument)
position. You can get a random float value or a vector of three random
values.

The noise is in the range 0-1 with a median of 0.5. The distribution of
the noise depends on the dimension, with higher dimensions approaching a
Gaussian distribution of noise values.

RELATED

  * Noise and randomness

  * anoise

  * curlnoise

  * flownoise

  * noise

  * onoise

  * pnoise

  * snoise

  * vnoise

  * wnoise

  * xnoise

}

{
xnoised

Derivatives of Simplex Noise.

USAGES
  void xnoised(float x, float &v, float &dvdx)
  void xnoised(float x, vector &v, vector &dvdx)
  void xnoised(float x, float y, float &v, float &dvdx, float &dvdy)
  void xnoised(float x, float y, vector &v, vector &dvdx, vector &dvdy)
  void xnoised(vector xyz, float &v, float &dvdx, float &dvdy, float
  &dvdz)
  void xnoised(vector xyz, vector &v, vector &dvdx, vector &dvdy, vector
  &dvdz)
  void xnoised(vector4 xyzw, float &v, float &dvdx, float &dvdy, float
  &dvdz, float &dvdw)
  void xnoised(vector4 xyzw, vector &v, vector &dvdx, vector &dvdy,
  vector &dvdz, vector &dvdw)

This computes both the simplex noise value, and the derivatives of the
noise along each axis. This can be performed quite efficiently as there
are analytic derivatives available.

See noise and randomness in the VEX language guide for more information.

RELATED

  * xnoise

}

{
xyzdist

Finds the distance of a point to a geometry.

USAGES
  float xyzdist(<geometry>, vector origin)
  Finds the distance from <origin> to the closest point on the geometry.

  float xyzdist(<geometry>, vector origin, int &prim, vector &uv)
  float xyzdist(<geometry>, vector origin, int &prim, vector &uv, float
  maxdist)
  Finds the distance from <origin> to the closest point on the geometry,
  and also outputs the primitive number and UV coordinates for the
  closest point.

  float xyzdist(<geometry>, string primgroup, vector origin)
  float xyzdist(<geometry>, string primgroup, vector origin, int &prim,
  vector &uv)
  float xyzdist(<geometry>, string primgroup, vector origin, int &prim,
  vector &uv, float maxdist)
  Finds the distance from <origin> to the closest point on geometry in
  the give primitive group.

Returns the distance to the closest point on the geometry. This will
find positions on the surfaces of the geometry, not just point
positions.


<geometry>
    When running in the context of a node (such as a wrangle SOP), this
    argument can be an integer representing the input number (starting
    at 0) to read the geometry from.

    Alternatively, the argument can be a string specifying a geometry
    file (for example, a .bgeo) to read from. When running inside
    Houdini, this can be an op:/path/to/sop reference.

primgroup
    The name of a primitive group or a pattern to generate a primitive
    group. Uses the same semantics as a SOP group, so empty strings will
    match all primitives. Attribute groups like @Cd.x>0 can also be
    used, but note that the @ may need to be escaped with a backslash in
    a Snippet VOP.

origin
    The position in space to find the closest position on the geometry
    to.

&prim
    The function overwrites this variable with the number of the closest
    primitive, or -1 if no primitive was found.

&uv
    The function overwrites this variable with the uv coordinates of the
    closest point on the closest primitive. You can use primuv to sample
    an attribute value at this location.

maxdist
    The maximum distance to search. Specifying this can speed up the
    function if it allows it to quit early.

    The distance from the origin point to the closest point on the
    geometry.

RELATED

}

{
xyztorgb

Convert CIE XYZ tristimulus values to a linear sRGB triplet.

USAGE
  vector xyztorgb(vector xyz)

Convert CIE XYZ tristimulus values to linear sRGB (Rec. 709) triplet.
XYZ can be thought of as a 'universal color space'.

RELATED

  * rgbtoxyz

  * blackbody

}

